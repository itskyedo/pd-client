/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/{entity_type}/{id}/change_tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Assign tags
         * @description Assign existing or new tags.
         *
         *     A Tag is applied to Escalation Policies, Teams or Users and can be used to filter them.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#tags)
         *
         *     Scoped OAuth requires: `tags.write`
         */
        post: operations["createEntityTypeByIdChangeTags"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/{entity_type}/{id}/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get tags for entities
         * @description Get related tags for Users, Teams or Escalation Policies.
         *
         *     A Tag is applied to Escalation Policies, Teams or Users and can be used to filter them.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#tags)
         *
         *     Scoped OAuth requires: `tags.read`
         */
        get: operations["getEntityTypeByIdTags"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/abilities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List abilities
         * @description List all of your account's abilities, by name.
         *
         *     "Abilities" describes your account's capabilities by feature name. For example `"teams"`.
         *
         *     An ability may be available to your account based on things like your pricing plan or account state.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#abilities)
         *
         *     Scoped OAuth requires: `abilities.read`
         */
        get: operations["listAbilities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/abilities/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Test an ability
         * @description Test whether your account has a given ability.
         *
         *     "Abilities" describes your account's capabilities by feature name. For example `"teams"`.
         *
         *     An ability may be available to your account based on things like your pricing plan or account state.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#abilities)
         *
         *     Scoped OAuth requires: `abilities.read`
         */
        get: operations["getAbility"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/addons": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List installed Add-ons
         * @description List all of the Add-ons installed on your account.
         *
         *     Addon's are pieces of functionality that developers can write to insert new functionality into PagerDuty's UI.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#add-ons)
         *
         *     Scoped OAuth requires: `addons.read`
         */
        get: operations["listAddon"];
        put?: never;
        /**
         * Install an Add-on
         * @description Install an Add-on for your account.
         *
         *     Addon's are pieces of functionality that developers can write to insert new functionality into PagerDuty's UI.
         *
         *     Given a configuration containing a `src` parameter, that URL will be embedded in an `iframe` on a page that's available to users from a drop-down menu.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#add-ons)
         *
         *     Scoped OAuth requires: `addons.write`
         */
        post: operations["createAddon"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/addons/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Add-on
         * @description Get details about an existing Add-on.
         *
         *     Addon's are pieces of functionality that developers can write to insert new functionality into PagerDuty's UI.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#add-ons)
         *
         *     Scoped OAuth requires: `addons.read`
         */
        get: operations["getAddon"];
        /**
         * Update an Add-on
         * @description Update an existing Add-on.
         *
         *     Addon's are pieces of functionality that developers can write to insert new functionality into PagerDuty's UI.
         *
         *     Given a configuration containing a `src` parameter, that URL will be embedded in an `iframe` on a page that's available to users from a drop-down menu.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#add-ons)
         *
         *     Scoped OAuth requires: `addons.write`
         */
        put: operations["updateAddon"];
        post?: never;
        /**
         * Delete an Add-on
         * @description Remove an existing Add-on.
         *
         *     Addon's are pieces of functionality that developers can write to insert new functionality into PagerDuty's UI.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#add-ons)
         *
         *     Scoped OAuth requires: `addons.write`
         */
        delete: operations["deleteAddon"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/alert_grouping_settings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List alert grouping settings
         * @description List all of your alert grouping settings including both single service settings and global content based settings.
         *
         *     The settings part of Alert Grouper service allows us to create Alert Grouping Settings and configs that are required to be used during grouping of the alerts.
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["listAlertGroupingSettings"];
        put?: never;
        /**
         * Create an Alert Grouping Setting
         * @description Create a new Alert Grouping Setting.
         *
         *     The settings part of Alert Grouper service allows us to create Alert Grouping Settings and configs that are required to be used during grouping of the alerts.
         *
         *     This endpoint will be used to create an instance of AlertGroupingSettings for either one service or many services that are in the alert group setting.
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["postAlertGroupingSettings"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/alert_grouping_settings/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Alert Grouping Setting
         * @description Get an existing Alert Grouping Setting.
         *
         *     The settings part of Alert Grouper service allows us to create Alert Grouping Settings and configs that are required to be used during grouping of the alerts.
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getAlertGroupingSetting"];
        /**
         * Update an Alert Grouping Setting
         * @description Update an Alert Grouping Setting.
         *
         *     The settings part of Alert Grouper service allows us to create Alert Grouping Settings and configs that are required to be used during grouping of the alerts.
         *
         *     if `services` are not provided in the request, then the existing services will not be removed from the setting.
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["putAlertGroupingSetting"];
        post?: never;
        /**
         * Delete an Alert Grouping Setting
         * @description Delete an existing Alert Grouping Setting.
         *
         *     The settings part of Alert Grouper service allows us to create Alert Grouping Settings and configs that are required to be used during grouping of the alerts.
         *
         *     Scoped OAuth requires: `services.write`
         */
        delete: operations["deleteAlertGroupingSetting"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/incidents/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated incident data
         * @description Provides aggregated enriched metrics for incidents.
         *
         *     The provided metrics are aggregated by day, week, month using the aggregate_unit parameter, or for the entire period if no aggregate_unit is provided.
         *
         *     <!-- theme: info -->
         *     > A `team_ids` or `service_ids` filter is required for [user-level API keys](https://support.pagerduty.com/docs/using-the-api#section-generating-a-personal-rest-api-key) or keys generated through an OAuth flow. Account-level API keys do not have this requirement.
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsIncidentsAll"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/incidents/escalation_policies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated escalation policy data
         * @description Provides aggregated metrics for incidents aggregated into units of time by escalation policy.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#escalation-policy-list).
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsIncidentsEscalationPolicy"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/incidents/escalation_policies/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated metrics for all escalation policies
         * @description Provides aggregated metrics across all escalation policies.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#escalation-policy-list).
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsIncidentsEscalationPolicyAll"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/incidents/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated service data
         * @description Provides aggregated metrics for incidents aggregated into units of time by service.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#services-list).
         *     Data can be aggregated by day, week or month in addition to by service, or provided just as a collection of aggregates for each service in the dataset for the entire period.  If a unit is provided, each row in the returned dataset will include a 'range_start' timestamp.
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsIncidentsService"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/incidents/services/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated metrics for all services
         * @description Provides aggregated metrics across all services.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#services-list).
         *
         *     <!-- theme: info -->
         *     > A `team_ids` or `service_ids` filter is required for [user-level API keys](https://support.pagerduty.com/docs/using-the-api#section-generating-a-personal-rest-api-key) or keys generated through an OAuth flow. Account-level API keys do not have this requirement.
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsIncidentsServiceAll"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/incidents/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated team data
         * @description Provides aggregated metrics for incidents aggregated into units of time by team.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#teams-list).
         *     Data can be aggregated by day, week or month in addition to by team, or provided just as a collection of aggregates for each team in the dataset for the entire period.  If a unit is provided, each row in the returned dataset will include a 'range_start' timestamp.
         *
         *     <!-- theme: info -->
         *     > A `team_ids` or `service_ids` filter is required for [user-level API keys](https://support.pagerduty.com/docs/using-the-api#section-generating-a-personal-rest-api-key) or keys generated through an OAuth flow. Account-level API keys do not have this requirement.
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsIncidentsTeam"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/incidents/teams/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated metrics for all teams
         * @description Provides aggregated metrics across all teams.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#teams-list).
         *
         *     <!-- theme: info -->
         *     > A `team_ids` or `service_ids` filter is required for [user-level API keys](https://support.pagerduty.com/docs/using-the-api#section-generating-a-personal-rest-api-key) or keys generated through an OAuth flow. Account-level API keys do not have this requirement.
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsIncidentsTeamAll"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/pd_advance_usage/features": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated PD Advance usage data
         * @description Provides aggregated metrics for the usage of PD Advance.
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsPdAdvanceUsageFeatures"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/responders/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated metrics for all responders
         * @description Provides aggregated incident metrics for all selected responders.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#responders-list).
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsRespondersAll"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/responders/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get responder data aggregated by team
         * @description Provides incident metrics aggregated by responder.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#responders-list).
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsRespondersTeam"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/metrics/users/all": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get aggregated metrics for all users
         * @description Provides aggregated metrics across all users within their account. This endpoint provides summary statistics about user activity and performance.
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsMetricsUsersAll"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/raw/incidents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get raw data - multiple incidents
         * @description Provides enriched incident data and metrics for multiple incidents.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#incidents-list).
         *
         *     <!-- theme: info -->
         *     > A `team_ids` or `service_ids` filter is required for [user-level API keys](https://support.pagerduty.com/docs/using-the-api#section-generating-a-personal-rest-api-key) or keys generated through an OAuth flow. Account-level API keys do not have this requirement.
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsIncidents"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/raw/incidents/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /**
         * Get raw data - single incident
         * @description Provides enriched incident data and metrics for a single incident.
         *
         *     Example metrics include Seconds to Resolve, Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#incidents-list).
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        get: operations["getAnalyticsIncidentsById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/raw/incidents/{id}/responses": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /**
         * Get raw responses from a single incident
         * @description Provides enriched responder data for a single incident.
         *
         *     Example metrics include Time to Respond, Responder Type, and Response Status. See metric definitions below.
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated once per day. It takes up to 24 hours before new incident responses appear in the Analytics API.
         *     Scoped OAuth requires: `analytics.read`
         */
        get: operations["getAnalyticsIncidentResponsesById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/raw/responders/{responder_id}/incidents": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the responder. */
                responder_id: components["parameters"]["responder_id"];
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get raw incidents for a single responder_id
         * @description Provides enriched incident data and metrics for a specific responder.
         *
         *     Example metrics include Mean Seconds to Resolve, Mean Seconds to Engage, Snoozed Seconds, and Sleep Hour Interruptions. Metric definitions can be found in our [Knowledge Base](https://support.pagerduty.com/docs/insights#incidents-list).
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new incidents appear in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsResponderIncidents"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/analytics/raw/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get raw user analytics data
         * @description Allows users to retrieve a raw list of user analytics data within their account. This endpoint provides detailed data about user activity and account configuration.
         *
         *     <!-- theme: info -->
         *     > **Note:** Analytics data is updated [periodically](https://support.pagerduty.com/main/docs/insights#:~:text=Data%20Update%20Schedule). It takes up to 24 hours before new user data appears in the Analytics API.
         *
         *     Scoped OAuth requires: `analytics.read`
         */
        post: operations["getAnalyticsUsers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audit/records": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List audit records
         * @description List audit trail records matching provided query params or default criteria.
         *
         *     The returned records are sorted by the `execution_time` from newest to oldest.
         *
         *     See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
         *
         *     Only admins, account owners, or global API tokens on PagerDuty account [pricing plans](https://www.pagerduty.com/pricing) with the "Audit Trail" feature can access this endpoint.
         *
         *     For other role based access to audit records by resource ID, see the resource's API documentation.
         *
         *     For more information see the [Audit API Document](https://developer.pagerduty.com/docs/rest-api-v2/audit-records-api/).
         *
         *     Scoped OAuth requires: `audit_records.read`
         */
        get: operations["listAuditRecords"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/actions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Automation Actions
         * @description Lists Automation Actions matching provided query params.
         *
         *     The returned records are sorted by action name in alphabetical order.
         *
         *     See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
         */
        get: operations["getAllAutomationActions"];
        put?: never;
        /**
         * Create an Automation Action
         * @description Create a Script, Process Automation, or Runbook Automation action
         */
        post: operations["createAutomationAction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/actions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Automation Action
         * @description Get an Automation Action
         */
        get: operations["getAutomationAction"];
        /**
         * Update an Automation Action
         * @description Updates an Automation Action
         */
        put: operations["updateAutomationAction"];
        post?: never;
        /**
         * Delete an Automation Action
         * @description Delete an Automation Action
         */
        delete: operations["deleteAutomationAction"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/actions/{id}/invocations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create an Invocation
         * @description Invokes an Action
         */
        post: operations["createAutomationActionInvocation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/actions/{id}/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all service references associated with an Automation Action
         * @description Gets all service references associated with an Automation Action
         */
        get: operations["getAutomationActionsActionServiceAssociations"];
        put?: never;
        /**
         * Associate an Automation Action with a service
         * @description Associate an Automation Action with a service
         */
        post: operations["createAutomationActionServiceAssocation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/actions/{id}/services/{service_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the details of an Automation Action / service relation
         * @description Gets the details of a Automation Action / service relation
         */
        get: operations["getAutomationActionsActionServiceAssociation"];
        put?: never;
        post?: never;
        /**
         * Disassociate an Automation Action from a service
         * @description Disassociate an Automation Action from a service
         */
        delete: operations["deleteAutomationActionServiceAssociation"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/actions/{id}/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all team references associated with an Automation Action
         * @description Gets all team references associated with an Automation Action
         */
        get: operations["getAutomationActionsActionTeamAssociations"];
        put?: never;
        /**
         * Associate an Automation Action with a team
         * @description Associate an Automation Action with a team
         */
        post: operations["createAutomationActionTeamAssociation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/actions/{id}/teams/{team_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the details of an Automation Action / team relation
         * @description Gets the details of an Automation Action / team relation
         */
        get: operations["getAutomationActionsActionTeamAssociation"];
        put?: never;
        post?: never;
        /**
         * Disassociate an Automation Action from a team
         * @description Disassociate an Automation Action from a team
         */
        delete: operations["deleteAutomationActionTeamAssociation"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/invocations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Invocations
         * @description List Invocations
         */
        get: operations["listAutomationActionInvocations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/invocations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Invocation
         * @description Get an Automation Action Invocation
         */
        get: operations["getAutomationActionsInvocation"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/runners": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Automation Action runners
         * @description Lists Automation Action runners matching provided query params.
         *     The returned records are sorted by runner name in alphabetical order.
         *
         *     See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
         */
        get: operations["getAutomationActionsRunners"];
        put?: never;
        /**
         * Create an Automation Action runner.
         * @description Create a Process Automation or a Runbook Automation runner.
         */
        post: operations["createAutomationActionsRunner"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/runners/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Automation Action runner
         * @description Get an Automation Action runner
         */
        get: operations["getAutomationActionsRunner"];
        /**
         * Update an Automation Action runner
         * @description Update an Automation Action runner
         */
        put: operations["updateAutomationActionsRunner"];
        post?: never;
        /**
         * Delete an Automation Action runner
         * @description Delete an Automation Action runner
         */
        delete: operations["deleteAutomationActionsRunner"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/runners/{id}/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get all team references associated with a runner
         * @description Gets all team references associated with a runner
         */
        get: operations["getAutomationActionsRunnerTeamAssociations"];
        put?: never;
        /**
         * Associate a runner with a team
         * @description Associate a runner with a team
         */
        post: operations["createAutomationActionsRunnerTeamAssociation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/automation_actions/runners/{id}/teams/{team_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the details of a runner / team relation
         * @description Gets the details of a runner / team relation
         */
        get: operations["getAutomationActionsRunnerTeamAssociation"];
        put?: never;
        post?: never;
        /**
         * Disassociate a runner from a team
         * @description Disassociates a runner from a team
         */
        delete: operations["deleteAutomationActionsRunnerTeamAssociation"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/business_services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Business Services
         * @description List existing Business Services.
         *
         *     Business services model capabilities that span multiple technical services and that may be owned by several different teams.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#business-services)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["listBusinessServices"];
        put?: never;
        /**
         * Create a Business Service
         * @description Create a new Business Service.
         *
         *     Business services model capabilities that span multiple technical services and that may be owned by several different teams.
         *
         *     There is a limit of 5,000 business services per account. If the limit is reached, the API will respond with an error.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#business-services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["createBusinessService"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/business_services/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Business Service
         * @description Get details about an existing Business Service.
         *
         *     Business services model capabilities that span multiple technical services and that may be owned by several different teams.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#business-services)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getBusinessService"];
        /**
         * Update a Business Service
         * @description Update an existing Business Service. NOTE that this endpoint also accepts the PATCH verb.
         *
         *     Business services model capabilities that span multiple technical services and that may be owned by several different teams.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#business-services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateBusinessService"];
        post?: never;
        /**
         * Delete a Business Service
         * @description Delete an existing Business Service.
         *
         *     Once the service is deleted, it will not be accessible from the web UI and new incidents won't be able to be created for this service.
         *
         *     Business services model capabilities that span multiple technical services and that may be owned by several different teams.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#business-services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        delete: operations["deleteBusinessService"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/business_services/{id}/account_subscription": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Business Service Account Subscription
         * @description Subscribe your Account to a Business Service.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        post: operations["createBusinessServiceAccountSubscription"];
        /**
         * Delete Business Service Account Subscription
         * @description Unsubscribe your Account from a Business Service.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        delete: operations["removeBusinessServiceAccountSubscription"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/business_services/{id}/subscribers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Business Service Subscribers
         * @description Retrieve a list of Notification Subscribers on the Business Service.
         *
         *     <!-- theme: warning -->
         *     > Users must be added through `POST /business_services/{id}/subscribers` to be returned from this endpoint.
         *     Scoped OAuth requires: `subscribers.read`
         */
        get: operations["getBusinessServiceSubscribers"];
        put?: never;
        /**
         * Create Business Service Subscribers
         * @description Subscribe the given entities to the given Business Service.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        post: operations["createBusinessServiceNotificationSubscribers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/business_services/{id}/supporting_services/impacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List the supporting Business Services for the given Business Service Id, sorted by impacted status.
         * @description Retrieve of Business Services that support the given Business Service sorted by highest Impact with `status` included.
         *     This endpoint does not return an exhaustive list of Business Services but rather provides access to the most impacted up to the limit of 200.
         *
         *     The returned Business Services are sorted first by Impact, secondarily by most recently impacted, and finally by name.
         *
         *     To get impact information about a specific set of Business Services, use the `ids[]` parameter on the `/business_services/impacts` endpoint.
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getBusinessServiceSupportingServiceImpacts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/business_services/{id}/unsubscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Remove Business Service Subscribers
         * @description Unsubscribes the matching Subscribers from a Business Service.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        post: operations["removeBusinessServiceNotificationSubscriber"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/business_services/impactors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Impactors affecting Business Services
         * @description Retrieve a list of Impactors for the top-level Business Services on the account. Impactors are currently limited to Incidents.
         *
         *     This endpoint does not return an exhaustive list of Impactors but rather provides access to the highest priority Impactors for the Business Services in question up to the limit of 200.
         *
         *     To get Impactors for a specific set of Business Services, use the `ids[]` parameter.
         *
         *     The returned Impactors are sorted first by priority and secondarily by their creation date.
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getBusinessServiceTopLevelImpactors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/business_services/impacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Business Services sorted by impacted status
         * @description Retrieve a list top-level Business Services sorted by highest Impact with `status` included.
         *     When called without the `ids[]` parameter, this endpoint does not return an exhaustive list of Business Services but rather provides access to the most impacted up to the limit of 200.
         *
         *     The returned Business Services are sorted first by Impact, secondarily by most recently impacted, and finally by name.
         *
         *     To get impact information about a specific set of Business Services, use the `ids[]` parameter.
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getBusinessServiceImpacts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/business_services/priority_thresholds": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the global priority threshold for a Business Service to be considered impacted by an Incident
         * @description Retrieves the priority threshold information for an account.  Currently, there is a `global_threshold` that can be set for the account.  Incidents that have a priority meeting or exceeding this threshold will be considered impacting on any Business Service that depends on the Service to which the Incident belongs.
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getBusinessServicePriorityThresholds"];
        /**
         * Set the Account-level priority threshold for Business Service impact.
         * @description Set the Account-level priority threshold for Business Service.
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["putBusinessServicePriorityThresholds"];
        post?: never;
        /**
         * Deletes the account-level priority threshold for Business Service impact
         * @description Clears the Priority Threshold for the account.  If the priority threshold is cleared, any Incident with a Priority set will be able to impact Business Services.
         *     Scoped OAuth requires: `services.write`
         */
        delete: operations["deleteBusinessServicePriorityThresholds"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/change_events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Change Events
         * @description List all of the existing Change Events.
         *
         *     Scoped OAuth requires: `change_events.read`
         */
        get: operations["listChangeEvents"];
        put?: never;
        /**
         * Create a Change Event
         * @description Sending Change Events is documented as part of the V2 Events API. See [`Send Change Event`](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODI2Ng-send-change-events-to-the-pager-duty-events-api).
         */
        post: operations["createChangeEvent"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/change_events/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Change Event
         * @description Get details about an existing Change Event.
         *
         *     Scoped OAuth requires: `change_events.read`
         */
        get: operations["getChangeEvent"];
        /**
         * Update a Change Event
         * @description Update an existing Change Event
         *
         *     Scoped OAuth requires: `change_events.write`
         */
        put: operations["updateChangeEvent"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/escalation_policies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List escalation policies
         * @description List all of the existing escalation policies.
         *
         *     Escalation policies define which user should be alerted at which time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#escalation-policies)
         *
         *     Scoped OAuth requires: `escalation_policies.read`
         */
        get: operations["listEscalationPolicies"];
        put?: never;
        /**
         * Create an escalation policy
         * @description Creates a new escalation policy. At least one escalation rule must be provided.
         *
         *     Escalation policies define which user should be alerted at which time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#escalation-policies)
         *
         *     Scoped OAuth requires: `escalation_policies.write`
         */
        post: operations["createEscalationPolicy"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/escalation_policies/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an escalation policy
         * @description Get information about an existing escalation policy and its rules.
         *
         *     Escalation policies define which user should be alerted at which time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#escalation-policies)
         *
         *     Scoped OAuth requires: `escalation_policies.read`
         */
        get: operations["getEscalationPolicy"];
        /**
         * Update an escalation policy
         * @description Updates an existing escalation policy and rules.
         *
         *     Escalation policies define which user should be alerted at which time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#escalation-policies)
         *
         *     Scoped OAuth requires: `escalation_policies.write`
         */
        put: operations["updateEscalationPolicy"];
        post?: never;
        /**
         * Delete an escalation policy
         * @description Deletes an existing escalation policy and rules. The escalation policy must not be in use by any services.
         *
         *     Escalation policies define which user should be alerted at which time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#escalation-policies)
         *
         *     Scoped OAuth requires: `escalation_policies.write`
         */
        delete: operations["deleteEscalationPolicy"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/escalation_policies/{id}/audit/records": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List audit records for an escalation policy
         * @description The returned records are sorted by the `execution_time` from newest to oldest.
         *
         *     See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
         *
         *     For more information see the [Audit API Document](https://developer.pagerduty.com/docs/rest-api-v2/audit-records-api/).
         *
         *     Scoped OAuth requires: `audit_records.read`
         */
        get: operations["listEscalationPolicyAuditRecords"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Event Orchestrations
         * @description List all Global Event Orchestrations on an Account.
         *
         *     Global Event Orchestrations allow you define a set of Global Rules and Router Rules, so that when you ingest events using the Orchestration's Routing Key your events will have actions applied via the Global Rules & then routed to the correct Service by the Router Rules, based on the event's content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["listEventOrchestrations"];
        put?: never;
        /**
         * Create an Orchestration
         * @description Create a Global Event Orchestration.
         *
         *     Global Event Orchestrations allow you define a set of Global Rules and Router Rules, so that when you ingest events using the Orchestration's Routing Key your events will have actions applied via the Global Rules & then routed to the correct Service by the Router Rules, based on the event's content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        post: operations["postOrchestration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Orchestration
         * @description Get a Global Event Orchestration.
         *
         *     Global Event Orchestrations allow you define a set of Global Rules and Router Rules, so that when you ingest events using the Orchestration's Routing Key your events will have actions applied via the Global Rules & then routed to the correct Service by the Router Rules, based on the event's content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["getOrchestration"];
        /**
         * Update an Orchestration
         * @description Update a Global Event Orchestration.
         *
         *     Global Event Orchestrations allow you define a set of Global Rules and Router Rules, so that when you ingest events using the Orchestration's Routing Key your events will have actions applied via the Global Rules & then routed to the correct Service by the Router Rules, based on the event's content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        put: operations["updateOrchestration"];
        post?: never;
        /**
         * Delete an Orchestration
         * @description Delete a Global Event Orchestration.
         *
         *     Once deleted, you will no longer be able to ingest events into PagerDuty using this Orchestration's Routing Key.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        delete: operations["deleteOrchestration"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/integrations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Integrations for an Event Orchestration
         * @description List the Integrations associated with this Event Orchestrations.
         *
         *     You can use a Routing Key from these Integrations to send events to PagerDuty!
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["listOrchestrationIntegrations"];
        put?: never;
        /**
         * Create an Integration for an Event Orchestration
         * @description Create an Integration associated with this Event Orchestration.
         *
         *     You can then use the Routing Key from this new Integration to send events to PagerDuty!
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        post: operations["postOrchestrationIntegration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/integrations/{integration_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Integration for an Event Orchestration
         * @description Get an Integration associated with this Event Orchestrations.
         *
         *     You can use the Routing Key from this Integration to send events to PagerDuty!
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["getOrchestrationIntegration"];
        /**
         * Update an Integration for an Event Orchestration
         * @description Update an Integration associated with this Event Orchestrations.
         *
         *     You can use the Routing Key from this Integration to send events to PagerDuty!
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        put: operations["updateOrchestrationIntegration"];
        post?: never;
        /**
         * Delete an Integration for an Event Orchestration
         * @description Delete an Integration and its associated Routing Key.
         *
         *     Once deleted, PagerDuty will drop all future events sent to PagerDuty using the Routing Key.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        delete: operations["deleteOrchestrationIntegration"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/integrations/migration": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Migrate an Integration from one Event Orchestration to another
         * @description Move an Integration and its Routing Key from the Event Orchestration specified in the request payload, to the Event Orchestration specified in the request URL.
         *
         *     Any future events sent to this Integration's Routing Key will be processed by this Event Orchestration's Rules.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        post: operations["migrateOrchestrationIntegration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/global": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the Global Orchestration for an Event Orchestration
         * @description Get the Global Orchestration for an Event Orchestration.
         *
         *     Global Orchestration Rules allows you to create a set of Event Rules. These rules evaluate against all Events sent to an Event Orchestration. When a matching rule is found, it can modify and enhance the event and can route the event to another set of Global Rules within this Orchestration for further processing.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["getOrchPathGlobal"];
        /**
         * Update the Global Orchestration for an Event Orchestration
         * @description Update the Global Orchestration for an Event Orchestration.
         *
         *     Global Orchestration Rules allows you to create a set of Event Rules. These rules evaluate against all Events sent to an Event Orchestration. When a matching rule is found, it can modify and enhance the event and can route the event to another set of Global Rules within this Orchestration for further processing.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        put: operations["updateOrchPathGlobal"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/router": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the Router for an Event Orchestration
         * @description Get a Global Orchestration's Routing Rules.
         *
         *     An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Global Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn't match any rules, it'll be sent to service specified in as the `catch_all` or the "Unrouted" Orchestration if no service is specified.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["getOrchPathRouter"];
        /**
         * Update the Router for an Event Orchestration
         * @description Update a Global Orchestration's Routing Rules.
         *
         *     An Orchestration Router allows you to create a set of Event Rules. The Router evaluates Events you send to this Global Orchestration against each of its rules, one at a time, and routes the event to a specific Service based on the first rule that matches. If an event doesn't match any rules, it'll be sent to service specified in as the `catch_all` or the "Unrouted" Orchestration if no service is specified.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        put: operations["updateOrchPathRouter"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/unrouted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the Unrouted Orchestration for an Event Orchestration
         * @description Get a Global Event Orchestration's Rules for Unrouted events.
         *
         *     An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don't match any rules in the Global Orchestration's Router. Events that reach the Unrouted Orchestration will never be routed to a specific Service.
         *
         *     The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the "start" set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["getOrchPathUnrouted"];
        /**
         * Update the Unrouted Orchestration for an Event Orchestration
         * @description Update a Global Event Orchestration's Rules for Unrouted events.
         *
         *     An Unrouted Orchestration allows you to create a set of Event Rules that will be evaluated against all events that don't match any rules in the Global Orchestration's Router. Events that reach the Unrouted Orchestration will never be routed to a specific Service.
         *
         *     The Unrouted Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the "start" set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Unrouted Orchestration for further processing.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        put: operations["updateOrchPathUnrouted"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/services/{service_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the Service Orchestration for a Service
         * @description Get a Service Orchestration.
         *
         *     A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the "start" set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getOrchPathService"];
        /**
         * Update the Service Orchestration for a Service
         * @description Update a Service Orchestration.
         *
         *     A Service Orchestration allows you to create a set of Event Rules. The Service Orchestration evaluates Events sent to this Service against each of its rules, beginning with the rules in the "start" set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Service Orchestration for further processing.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateOrchPathService"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/services/{service_id}/active": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the Service Orchestration active status for a Service
         * @description Get a Service Orchestration's active status.
         *
         *     A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getOrchActiveStatus"];
        /**
         * Update the Service Orchestration active status for a Service
         * @description Update a Service Orchestration's active status.
         *
         *     A Service Orchestration allows you to set an active status based on whether an event will be evaluated against a service orchestration path (true) or service ruleset (false).
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateOrchActiveStatus"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/cache_variables": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Cache Variables for a Global Event Orchestration
         * @description List Cache Variables for a Global Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["listCacheVarOnGlobalOrch"];
        put?: never;
        /**
         * Create a Cache Variable for a Global Event Orchestration
         * @description Create a Cache Variable for a Global Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        post: operations["createCacheVarOnGlobalOrch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/cache_variables/{cache_variable_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Cache Variable for a Global Event Orchestration
         * @description Get a Cache Variable for a Global Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["getCacheVarOnGlobalOrch"];
        /**
         * Update a Cache Variable for a Global Event Orchestration
         * @description Update a Cache Variable for a Global Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        put: operations["updateCacheVarOnGlobalOrch"];
        post?: never;
        /**
         * Delete a Cache Variable for a Global Event Orchestration
         * @description Delete a Cache Variable for a Global Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        delete: operations["deleteCacheVarOnGlobalOrch"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/cache_variables/{cache_variable_id}/data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Data for an External Data Cache Variable on a Global Event Orchestration
         * @description Get the data for an `external_data` type Cache Variable on a Global Orchestration.
         *
         *     Use External Data type Cache Variables to store string, number, or boolean values via a dedicated API endpoint. These stored values can then be used in conditions or actions in Event Orchestration rules.
         *
         *     For more information see the [Knowledge Base](https://support.pagerduty.com/main/docs/event-orchestration-cache-variables)
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["getExternalDataCacheVarDataOnGlobalOrch"];
        /**
         * Update Data for an External Data Cache Variable on a Global Event Orchestration
         * @description Update data for an `external_data` type Cache Variable on a Global Event Orchestration
         *
         *     Use External Data type Cache Variables to store string, number, or boolean values via a dedicated API endpoint. These stored values can then be used in conditions or actions in Event Orchestration rules.
         *
         *     For more information see the [Knowledge Base](https://support.pagerduty.com/main/docs/event-orchestration-cache-variables)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        put: operations["updateExternalDataCacheVarDataOnGlobalOrch"];
        post?: never;
        /**
         * Delete Data for an External Data Cache Variable on a Global Event Orchestration
         * @description Delete data for an `external_data` type Cache Variable on a Global Event Orchestration
         *
         *     Use External Data type Cache Variables to store string, number, or boolean values via a dedicated API endpoint. These stored values can then be used in conditions or actions in Event Orchestration rules.
         *
         *     For more information see the [Knowledge Base](https://support.pagerduty.com/main/docs/event-orchestration-cache-variables)
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        delete: operations["deleteExternalDataCacheVarDataOnGlobalOrch"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/services/{service_id}/cache_variables": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Cache Variables for a Service Event Orchestration
         * @description List Cache Variables for a Service Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["listCacheVarOnServiceOrch"];
        put?: never;
        /**
         * Create a Cache Variable for a Service Event Orchestration
         * @description Create a Cache Variable for a Service Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["createCacheVarOnServiceOrch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/services/{service_id}/cache_variables/{cache_variable_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Cache Variable for a Service Event Orchestration
         * @description Get a Cache Variable for a Service Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getCacheVarOnServiceOrch"];
        /**
         * Update a Cache Variable for a Service Event Orchestration
         * @description Update a Cache Variable for a Service Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateCacheVarOnServiceOrch"];
        post?: never;
        /**
         * Delete a Cache Variable for a Service Event Orchestration
         * @description Delete a Cache Variable for a Service Event Orchestration.
         *
         *     Cache Variables allow you to store event data on an Event Orchestration, which can then be used in Event Orchestration rules as part of conditions or actions.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#event-orchestrations)
         *
         *     Scoped OAuth requires: `services.write`
         */
        delete: operations["deleteCacheVarOnServiceOrch"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/services/{service_id}/cache_variables/{cache_variable_id}/data": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Data for an External Data Cache Variable on a Service Event Orchestration
         * @description Get the data for an `external_data` type Cache Variable for a Service Event Orchestration.
         *
         *     Use External Data type Cache Variables to store string, number, or boolean values via a dedicated API endpoint. These stored values can then be used in conditions or actions in Event Orchestration rules.
         *
         *     For more information see the [Knowledge Base](https://support.pagerduty.com/main/docs/event-orchestration-cache-variables)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getExternalDataCacheVarDataOnServiceOrch"];
        /**
         * Update Data for an External Data Cache Variable on a Service Event Orchestration
         * @description Update the data for an `external_data` type Cache Variable on a Service Event Orchestration.
         *
         *     Use External Data type Cache Variables to store string, number, or boolean values via a dedicated API endpoint. These stored values can then be used in conditions or actions in Event Orchestration rules.
         *
         *     For more information see the [Knowledge Base](https://support.pagerduty.com/main/docs/event-orchestration-cache-variables)
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateExternalDataCacheVarDataOnServiceOrch"];
        post?: never;
        /**
         * Delete Data for an External Data Cache Variable on a Service Event Orchestration
         * @description Delete Data for an `external_data` type Cache Variable on a Service Event Orchestration.
         *
         *     Use External Data type Cache Variables to store string, number, or boolean values via a dedicated API endpoint. These stored values can then be used in conditions or actions in Event Orchestration rules.
         *
         *     For more information see the [Knowledge Base](https://support.pagerduty.com/main/docs/event-orchestration-cache-variables)
         *
         *     Scoped OAuth requires: `services.write`
         */
        delete: operations["deleteExternalDataCacheVarDataOnServiceOrch"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/enablements": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Enablements for an Event Orchestration
         * @description <!-- theme: warning -->
         *     > ### Limited GA
         *     > This feature is in Limited General Availability for some customers with the PagerDuty AIOps add-on. Please contact your account team or Support to request access.
         *
         *     List all feature enablement settings for an Event Orchestration. Currently, only the `aiops` enablement is supported.
         *
         *     For any account with the AIOps product addon, every Event Orchestration will have AIOps features enabled by default.
         *
         *     **Warning conditions**:
         *     - If the account is not entitled to use AIOps features, a warning will be returned alongside the enablement data.
         *
         *     Scoped OAuth requires: `event_orchestrations.read`
         */
        get: operations["listEventOrchestrationFeatureEnablements"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/event_orchestrations/{id}/enablements/{feature_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update an Enablement for an Event Orchestration
         * @description <!-- theme: warning -->
         *     > ### Limited GA
         *     > This feature is in Limited General Availability for some customers with the PagerDuty AIOps add-on. Please contact your account team or Support to request access.
         *
         *     Update the feature enablement setting for a specific product addon on an Event Orchestration. This setting controls enabling or disabling the set of features contained within the addon.
         *     Currently, only `aiops` is supported as a valid feature enablement.
         *
         *     **Warning conditions**:
         *     - If the account is not entitled to use AIOps features, the setting will be updated, but a warning will be returned.
         *
         *     Scoped OAuth requires: `event_orchestrations.write`
         */
        put: operations["updateEventOrchestrationFeatureEnablements"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/extension_schemas": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List extension schemas
         * @description List all extension schemas.
         *
         *     A PagerDuty extension vendor represents a specific type of outbound extension such as Generic Webhook, Slack, ServiceNow.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#extension-schemas)
         *
         *     Scoped OAuth requires: `extension_schemas.read`
         */
        get: operations["listExtensionSchemas"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/extension_schemas/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an extension vendor
         * @description Get details about one specific extension vendor.
         *
         *     A PagerDuty extension vendor represents a specific type of outbound extension such as Generic Webhook, Slack, ServiceNow.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#extension-schemas)
         *
         *     Scoped OAuth requires: `extension_schemas.read`
         */
        get: operations["getExtensionSchema"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/extensions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List extensions
         * @description List existing extensions.
         *
         *     Extensions are representations of Extension Schema objects that are attached to Services.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#extensions)
         *
         *     Scoped OAuth requires: `extensions.read`
         */
        get: operations["listExtensions"];
        put?: never;
        /**
         * Create an extension
         * @description Create a new Extension.
         *
         *     Extensions are representations of Extension Schema objects that are attached to Services.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#extensions)
         *
         *     Scoped OAuth requires: `extensions.write`
         */
        post: operations["createExtension"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/extensions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an extension
         * @description Get details about an existing extension.
         *
         *     Extensions are representations of Extension Schema objects that are attached to Services.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#extensions)
         *
         *     Scoped OAuth requires: `extensions.read`
         */
        get: operations["getExtension"];
        /**
         * Update an extension
         * @description Update an existing extension.
         *
         *     Extensions are representations of Extension Schema objects that are attached to Services.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#extensions)
         *
         *     Scoped OAuth requires: `extensions.write`
         */
        put: operations["updateExtension"];
        post?: never;
        /**
         * Delete an extension
         * @description Delete an existing extension.
         *
         *     Once the extension is deleted, it will not be accessible from the web UI and new incidents won't be able to be created for this extension.
         *
         *     Extensions are representations of Extension Schema objects that are attached to Services.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#extensions)
         *
         *     Scoped OAuth requires: `extensions.write`
         */
        delete: operations["deleteExtension"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/extensions/{id}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable an extension
         * @description Enable an extension that is temporarily disabled. (This API does not require a request body.)
         *
         *     Extensions are representations of Extension Schema objects that are attached to Services.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#extensions)
         *
         *     Scoped OAuth requires: `extensions.write`
         */
        post: operations["enableExtension"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incident_workflows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Incident Workflows
         * @description List existing Incident Workflows.
         *
         *     This is the best method to use to list all Incident Workflows in your account. If your use case requires listing Incident Workflows associated with a particular Service, you can use the "List Triggers" method to find Incident Workflows configured to start for Incidents in a given Service.
         *
         *     An Incident Workflow is a sequence of configurable Steps and associated Triggers that can execute automated Actions for a given Incident.
         *
         *     Scoped OAuth requires: `incident_workflows.read`
         */
        get: operations["listIncidentWorkflows"];
        put?: never;
        /**
         * Create an Incident Workflow
         * @description Create a new Incident Workflow
         *
         *     An Incident Workflow is a sequence of configurable Steps and associated Triggers that can execute automated Actions for a given Incident.
         *
         *     Scoped OAuth requires: `incident_workflows.write`
         */
        post: operations["postIncidentWorkflow"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incident_workflows/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Incident Workflow
         * @description Get an existing Incident Workflow
         *
         *     An Incident Workflow is a sequence of configurable Steps and associated Triggers that can execute automated Actions for a given Incident.
         *
         *     Scoped OAuth requires: `incident_workflows.read`
         */
        get: operations["getIncidentWorkflow"];
        /**
         * Update an Incident Workflow
         * @description Update an Incident Workflow
         *
         *     An Incident Workflow is a sequence of configurable Steps and associated Triggers that can execute automated Actions for a given Incident.
         *
         *     Scoped OAuth requires: `incident_workflows.write`
         */
        put: operations["putIncidentWorkflow"];
        post?: never;
        /**
         * Delete an Incident Workflow
         * @description Delete an existing Incident Workflow
         *
         *     An Incident Workflow is a sequence of configurable Steps and associated Triggers that can execute automated Actions for a given Incident.
         *
         *     Scoped OAuth requires: `incident_workflows.write`
         */
        delete: operations["deleteIncidentWorkflow"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incident_workflows/{id}/instances": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start an Incident Workflow Instance
         * @description Start an Instance of an Incident Workflow. Sometimes referred to as "triggering a workflow on an incident."
         *
         *     An Incident Workflow is a sequence of configurable Steps and associated Triggers that can execute automated Actions for a given Incident.
         *
         *     Scoped OAuth requires: `incident_workflows:instances.write`
         */
        post: operations["createIncidentWorkflowInstance"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incident_workflows/actions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Actions
         * @description List Incident Workflow Actions
         *
         *     Scoped OAuth requires: `incident_workflows.read`
         */
        get: operations["listIncidentWorkflowActions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incident_workflows/actions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Action
         * @description Get an Incident Workflow Action
         *
         *     Scoped OAuth requires: `incident_workflows.read`
         */
        get: operations["getIncidentWorkflowAction"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incident_workflows/triggers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Triggers
         * @description List existing Incident Workflow Triggers
         *
         *     Scoped OAuth requires: `incident_workflows.read`
         */
        get: operations["listIncidentWorkflowTriggers"];
        put?: never;
        /**
         * Create a Trigger
         * @description Create new Incident Workflow Trigger
         *
         *     Scoped OAuth requires: `incident_workflows.write`
         */
        post: operations["createIncidentWorkflowTrigger"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incident_workflows/triggers/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Trigger
         * @description Retrieve an existing Incident Workflows Trigger
         *
         *     Scoped OAuth requires: `incident_workflows.read`
         */
        get: operations["getIncidentWorkflowTrigger"];
        /**
         * Update a Trigger
         * @description Update an existing Incident Workflow Trigger
         *
         *     Scoped OAuth requires: `incident_workflows.write`
         */
        put: operations["updateIncidentWorkflowTrigger"];
        post?: never;
        /**
         * Delete a Trigger
         * @description Delete an existing Incident Workflow Trigger
         *
         *     Scoped OAuth requires: `incident_workflows.write`
         */
        delete: operations["deleteIncidentWorkflowTrigger"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incident_workflows/triggers/{id}/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Associate a Trigger and Service
         * @description Associate a Service with an existing Incident Workflow Trigger
         *
         *     Scoped OAuth requires: `incident_workflows.write`
         */
        post: operations["associateServiceToIncidentWorkflowTrigger"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incident_workflows/triggers/{trigger_id}/services/{service_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Dissociate a Trigger and Service
         * @description Remove a an existing Service from an Incident Workflow Trigger
         *
         *     Scoped OAuth requires: `incident_workflows.write`
         */
        delete: operations["deleteServiceFromIncidentWorkflowTrigger"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List incidents
         * @description List existing incidents.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["listIncidents"];
        /**
         * Manage incidents
         * @description Acknowledge, resolve, escalate or reassign one or more incidents.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     A maximum of 250 incidents may be updated at a time. If more than this number of incidents are given, the API will respond with status 413 (Request Entity Too Large).
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         *
         *     This API operation has operation specific rate limits. See the [Rate Limits](https://developer.pagerduty.com/docs/72d3b724589e3-rest-api-rate-limits) page for more information.
         */
        put: operations["updateIncidents"];
        /**
         * Create an Incident
         * @description Create an incident synchronously without a corresponding event from a monitoring service.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         *
         *     This API operation has operation specific rate limits. See the [Rate Limits](https://developer.pagerduty.com/docs/72d3b724589e3-rest-api-rate-limits) page for more information.
         */
        post: operations["createIncident"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an incident
         * @description Show detailed information about an incident. Accepts either an incident id, or an incident number.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getIncident"];
        /**
         * Update an incident
         * @description Acknowledge, resolve, escalate or reassign an incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        put: operations["updateIncident"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/alerts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List alerts for an incident
         * @description List alerts for the specified incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["listIncidentAlerts"];
        /**
         * Manage alerts
         * @description Resolve multiple alerts or associate them with different incidents.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved. An alert represents a digital signal that was emitted to PagerDuty by the monitoring systems that detected or identified the issue.
         *
         *     A maximum of 250 alerts may be updated at a time. If more than this number of alerts are given, the API will respond with status 413 (Request Entity Too Large).
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        put: operations["updateIncidentAlerts"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/alerts/{alert_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an alert
         * @description Show detailed information about an alert. Accepts an alert id.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     When a service sends an event to PagerDuty, an alert and corresponding incident is triggered in PagerDuty.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getIncidentAlert"];
        /**
         * Update an alert
         * @description Resolve an alert or associate an alert with a new parent incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     When a service sends an event to PagerDuty, an alert and corresponding incident is triggered in PagerDuty.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        put: operations["updateIncidentAlert"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/business_services/{business_service_id}/impacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Manually change an Incident's Impact on a Business Service.
         * @description Change Impact of an Incident on a Business Service.
         *     Scoped OAuth requires: `incidents.write`
         */
        put: operations["putIncidentManualBusinessServiceAssociation"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/business_services/impacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Business Services impacted by the given Incident
         * @description Retrieve a list of Business Services that are being impacted by the given Incident.
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getIncidentImpactedBusinessServices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/custom_fields/values": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Custom Field Values
         * @description Get custom field values for an incident.
         *
         *     <!-- theme: warning -->
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getIncidentFieldValues"];
        /**
         * Update Custom Field Values
         * @description Set custom field values for an incident.
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        put: operations["setIncidentFieldValues"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/log_entries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List log entries for an incident
         * @description List log entries for the specified incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     A Log Entry are a record of all events on your account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["listIncidentLogEntries"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/merge": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Merge incidents
         * @description Merge a list of source incidents into the target [incident](https://developer.pagerduty.com/api-reference/a47605517c19a-api-concepts#incidents).
         *
         *     After the merge is performed the target incident will contain the source incidents' [alerts](https://developer.pagerduty.com/api-reference/a47605517c19a-api-concepts#alerts),
         *     and the source incidents will be resolved.
         *
         *     Only incidents that have alerts or incidents that were created manually in the UI can be merged.
         *
         *     Open incidents cannot be merged into a resolved incident.
         *
         *     An incident cannot have more than 1000 alerts. The server will return an error if merging the source incidents
         *     will result in the target incident having more than 1000 alerts.
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        put: operations["mergeIncidents"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/notes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List notes for an incident
         * @description List existing notes for the specified incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["listIncidentNotes"];
        put?: never;
        /**
         * Create a note on an incident
         * @description Create a new note for the specified incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     A maximum of 2000 notes can be added to an incident.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        post: operations["createIncidentNote"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/notes/{note_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update a note on an incident
         * @description Update an existing note for the specified incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        put: operations["updateIncidentNote"];
        post?: never;
        /**
         * Delete a note on an incident
         * @description Delete an existing note for the specified incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        delete: operations["deleteIncidentNote"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/outlier_incident": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Outlier Incident
         * @description Gets Outlier Incident information for a given Incident on its Service.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#outlier-incident)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getOutlierIncident"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/past_incidents": {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /**
         * Get Past Incidents
         * @description Past Incidents returns Incidents within the past 6 months that have similar metadata and were generated on the same Service as the parent Incident. By default, 5 Past Incidents are returned. Note: This feature is currently available as part of the Event Intelligence package or Digital Operations plan only.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#past_incidents)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getPastIncidents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/related_change_events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List related Change Events for an Incident
         * @description List related Change Events for an Incident, as well as the reason these changes are correlated with the incident.
         *
         *     Change events represent service changes such as deploys, build completion, and configuration changes, providing information that is critical during incident triage or hypercare. For more information on change events, see [Change Events](https://support.pagerduty.com/docs/change-events).
         *
         *     The Change Correlation feature provides incident responders with recent change events that are most relevant to that incident. Change Correlation informs the responder why a particular change event was surfaced and correlated to an incident based on three key factors which include time, related service, or intelligence (machine learning).
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["listIncidentRelatedChangeEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/related_incidents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Related Incidents
         * @description Returns the 20 most recent Related Incidents that are impacting other Responders and Services. Note: This feature is currently available as part of the Event Intelligence package or Digital Operations plan only.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#related_incidents)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getRelatedIncidents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/responder_requests": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a responder request for an incident
         * @description Send a new responder request for the specified incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        post: operations["createIncidentResponderRequest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/snooze": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Snooze an incident
         * @description Snooze an incident.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        post: operations["createIncidentSnooze"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/status_updates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a status update on an incident
         * @description Create a new status update for the specified incident. Optionally pass `subject` and `html_message` properties in the request body to override the email notification that gets sent.
         *
         *     An incident represents a problem or an issue that needs to be addressed and resolved.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidents)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        post: operations["createIncidentStatusUpdate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/status_updates/subscribers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Notification Subscribers
         * @description Retrieve a list of Notification Subscribers on the Incident.
         *
         *     <!-- theme: warning -->
         *     > Users must be added through `POST /incident/{id}/status_updates/subscribers` to be returned from this endpoint.
         *     Scoped OAuth requires: `subscribers.read`
         */
        get: operations["getIncidentNotificationSubscribers"];
        put?: never;
        /**
         * Add Notification Subscribers
         * @description Subscribe the given entities to Incident Status Update Notifications.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        post: operations["createIncidentNotificationSubscribers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/{id}/status_updates/unsubscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Remove Notification Subscriber
         * @description Unsubscribes the matching Subscribers from Incident Status Update Notifications.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        post: operations["removeIncidentNotificationSubscribers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List incident types
         * @description List the available incident types
         *
         *     Incident Types are a feature which will allow customers to categorize incidents, such as a security incident, a major incident, or a fraud incident.
         *     These can be filtered by enabled or disabled types.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidentType)
         *
         *     Scoped OAuth requires: `incident_types.read`
         */
        get: operations["listIncidentTypes"];
        put?: never;
        /**
         * Create an Incident Type
         * @description Create a new incident type.
         *
         *     Incident Types are a feature which will allow customers to categorize incidents, such as a security incident, a major incident, or a fraud incident.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incidentType)
         *
         *     Scoped OAuth requires: `incident_types.write`
         */
        post: operations["createIncidentType"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/types/{type_id_or_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Incident Type
         * @description Get detailed information about a single incident type. Accepts either an incident type id, or an incident type name.
         *
         *     Incident Types are a feature which will allow customers to categorize incidents, such as a security incident, a major incident, or a fraud incident.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incident)
         *
         *     Scoped OAuth requires: `incident_types.read`
         */
        get: operations["getIncidentType"];
        /**
         * Update an Incident Type
         * @description Update an Incident Type.
         *
         *     Incident Types are a feature which will allow customers to categorize incidents, such as a security incident, a major incident, or a fraud incident.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#incident)
         *
         *     Scoped OAuth requires: `incident_types.write`
         */
        put: operations["updateIncidentType"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/types/{type_id_or_name}/custom_fields": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Incident Type Custom Fields
         * @description List the custom fields for an incident type.
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["listIncidentTypeCustomFields"];
        put?: never;
        /**
         * Create a Custom Field for an Incident Type
         * @description Create a Custom Field for an Incident Type
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        post: operations["createIncidentTypeCustomField"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/types/{type_id_or_name}/custom_fields/{field_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Incident Type Custom Field
         * @description Get a custom field for an incident type.
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["getIncidentTypeCustomField"];
        /**
         * Update a Custom Field for an Incident Type
         * @description Update a custom field for an incident type. Field Options can also be updated within the same call.
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        put: operations["updateIncidentTypeCustomField"];
        post?: never;
        /**
         * Delete a Custom Field for an Incident Type
         * @description Delete a custom field for an incident type.
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        delete: operations["deleteIncidentTypeCustomField"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/types/{type_id_or_name}/custom_fields/{field_id}/field_options": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Field Options on a Custom Field
         * @description List field options for a custom field.
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["listIncidentTypeCustomField"];
        put?: never;
        /**
         * Create a Field Option for a Custom Field
         * @description Create a field option for a custom field.
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        post: operations["createIncidentTypeCustomFieldFieldOptions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/types/{type_id_or_name}/custom_fields/{field_id}/field_options/{field_option_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Field Option on a Custom Field
         * @description Get a field option on a custom field
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["getIncidentTypeCustomFieldFieldOptions"];
        /**
         * Update a Field Option for a Custom Field
         * @description Update a field option for a custom field.
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        put: operations["updateIncidentTypeCustomFieldFieldOption"];
        post?: never;
        /**
         * Delete a Field Option for a Custom Field
         * @description Delete a field option for a custom field.
         *
         *     Custom Fields (CF) are a feature which will allow customers to extend Incidents with their own custom data,
         *     to provide additional context and support features such as customized filtering, search and analytics.
         *     Custom Fields can be applied to different incident types.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        delete: operations["deleteIncidentTypeCustomFieldFieldOption"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/custom_fields": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Fields
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated and only works for fields on the Base Incident Type. \
         *     > For more flexibility, we recommend using the Incident Types endpoint: \
         *     > [/incidents/types/{type_id_or_name}/custom_fields](openapiv3.json/paths/~1incidents~1types~1{type_id_or_name}~1custom_fields/get)
         *
         *     List Custom Fields on the Base Incident Type.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["listCustomFieldsFields"];
        put?: never;
        /**
         * Create a Field
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated and only works for fields on the Base Incident Type. \
         *     > For more flexibility, we recommend using the Incident Types endpoint: \
         *     > [/incidents/types/{type_id_or_name}/custom_fields](openapiv3.json/paths/~1incidents~1types~1{type_id_or_name}~1custom_fields/post)
         *
         *     Creates a new Custom Field on the Base Incident Type, along with the Field Options if provided. \
         *     An account may have up to 10 Fields.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        post: operations["createCustomFieldsField"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/custom_fields/{field_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Field
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated and only works for fields on the Base Incident Type. \
         *     > For more flexibility, we recommend using the Incident Types endpoint: \
         *     > [/incidents/types/{type_id_or_name}/custom_fields/{field_id}](openapiv3.json/paths/~1incidents~1types~1{type_id_or_name}~1custom_fields~1{field_id}/get)
         *
         *     Show detailed information about a Custom Field on the Base Incident Type.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["getCustomFieldsField"];
        /**
         * Update a Field
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated and only works for fields on the Base Incident Type. \
         *     > For more flexibility, we recommend using the Incident Types endpoint: \
         *     > [/incidents/types/{type_id_or_name}/custom_fields/{field_id}](openapiv3.json/paths/~1incidents~1types~1{type_id_or_name}~1custom_fields~1{field_id}/put)
         *
         *     Update a Custom Field on the Base Incident Type.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        put: operations["updateCustomFieldsField"];
        post?: never;
        /**
         * Delete a Field
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated and only works for fields on the Base Incident Type. \
         *     > For more flexibility, we recommend using the Incident Types endpoint: \
         *     > [/incidents/types/{type_id_or_name}/custom_fields/{field_id}](openapiv3.json/paths/~1incidents~1types~1{type_id_or_name}~1custom_fields~1{field_id}/delete)
         *
         *     Delete a Custom Field from the Base Incident Type.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        delete: operations["deleteCustomFieldsField"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/custom_fields/{field_id}/field_options": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Field Options
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated and only works for fields on the Base Incident Type. \
         *     > For more flexibility, we recommend using the Incident Types endpoint: \
         *     > [/incidents/types/{type_id_or_name}/custom_fields/{field_id}/field_options](openapiv3.json/paths/~1incidents~1types~1{type_id_or_name}~1custom_fields~1{field_id}~1field_options/get)
         *
         *     List all enabled Field Options for a Custom Field on the Base Incident Type.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["listCustomFieldsFieldOptions"];
        put?: never;
        /**
         * Create a Field Option
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated and only works for fields on the Base Incident Type. \
         *     > For more flexibility, we recommend using the Incident Types endpoint: \
         *     > [/incidents/types/{type_id_or_name}/custom_fields/{field_id}/field_options](openapiv3.json/paths/~1incidents~1types~1{type_id_or_name}~1custom_fields~1{field_id}~1field_options/post)
         *
         *     Create a new Field Option for a Custom Field on the Base Incident Type. Field Options may only be created for Fields that have `field_options`. A Field may have no more than 10 enabled options.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        post: operations["createCustomFieldsFieldOption"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/incidents/custom_fields/{field_id}/field_options/{field_option_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update a Field Option
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated and only works for fields on the Base Incident Type. \
         *     > For more flexibility, we recommend using the Incident Types endpoint: \
         *     > [/incidents/types/{type_id_or_name}/custom_fields/{field_id}/field_options/{field_option_id}](openapiv3.json/paths/~1incidents~1types~1{type_id_or_name}~1custom_fields~1{field_id}~1field_options~1{field_option_id}/put)
         *
         *     Update a Field Option for a Custom Field on the Base Incident Type.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        put: operations["updateCustomFieldsFieldOption"];
        post?: never;
        /**
         * Delete a Field Option
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated and only works for fields on the Base Incident Type. \
         *     > For more flexibility, we recommend using the Incident Types endpoint: \
         *     > [/incidents/types/{type_id_or_name}/custom_fields/{field_id}/field_options/{field_option_id}](openapiv3.json/paths/~1incidents~1types~1{type_id_or_name}~1custom_fields~1{field_id}~1field_options~1{field_option_id}/delete)
         *
         *     Delete a Field Option for a Custom Field on the Base Incident Type.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        delete: operations["deleteCustomFieldsFieldOption"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/license_allocations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List License Allocations
         * @description List the Licenses allocated to Users within your Account
         *
         *     Scoped OAuth requires: `licenses.read`
         */
        get: operations["listLicenseAllocations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/licenses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Licenses
         * @description List the Licenses associated with your Account
         *
         *     Scoped OAuth requires: `licenses.read`
         */
        get: operations["listLicenses"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/log_entries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List log entries
         * @description List all of the incident log entries across the entire account.
         *
         *     A log of all the events that happen to an Incident, and these are exposed as Log Entries.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#log-entries)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["listLogEntries"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/log_entries/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a log entry
         * @description Get details for a specific incident log entry. This method provides additional information you can use to get at raw event data.
         *
         *     A log of all the events that happen to an Incident, and these are exposed as Log Entries.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#log-entries)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getLogEntry"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/log_entries/{id}/channel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update log entry channel information.
         * @description Update an existing incident log entry channel.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#log-entries)
         *
         *     Scoped OAuth requires: `incidents.write`
         */
        put: operations["updateLogEntryChannel"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/maintenance_windows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List maintenance windows
         * @description List existing maintenance windows, optionally filtered by service and/or team, or whether they are from the past, present or future.
         *
         *     A Maintenance Window is used to temporarily disable one or more Services for a set period of time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#maintenance-windows)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["listMaintenanceWindows"];
        put?: never;
        /**
         * Create a maintenance window
         * @description Create a new maintenance window for the specified services. No new incidents will be created for a service that is in maintenance.
         *
         *     A Maintenance Window is used to temporarily disable one or more Services for a set period of time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#maintenance-windows)
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["createMaintenanceWindow"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/maintenance_windows/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a maintenance window
         * @description Get an existing maintenance window.
         *
         *     A Maintenance Window is used to temporarily disable one or more Services for a set period of time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#maintenance-windows)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getMaintenanceWindow"];
        /**
         * Update a maintenance window
         * @description Update an existing maintenance window.
         *
         *     A Maintenance Window is used to temporarily disable one or more Services for a set period of time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#maintenance-windows)
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateMaintenanceWindow"];
        post?: never;
        /**
         * Delete or end a maintenance window
         * @description Delete an existing maintenance window if it's in the future, or end it if it's currently on-going. If the maintenance window has already ended it cannot be deleted.
         *
         *     A Maintenance Window is used to temporarily disable one or more Services for a set period of time.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#maintenance-windows)
         *
         *     Scoped OAuth requires: `services.write`
         */
        delete: operations["deleteMaintenanceWindow"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List notifications
         * @description List notifications for a given time range, optionally filtered by type (sms_notification, email_notification, phone_notification, or push_notification).
         *
         *     A Notification is created when an Incident is triggered or escalated.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#notifications)
         *
         *     Scoped OAuth requires: `users:notifications.read`
         */
        get: operations["listNotifications"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/oauth_delegations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete all OAuth delegations
         * @description Delete all OAuth delegations as per provided query parameters.
         *
         *     An OAuth delegation represents an instance of a user or account's authorization to an app (via OAuth) to access their PagerDuty account.
         *     Common apps include the PagerDuty mobile app, Slack, Microsoft Teams, and third-party apps. It also represents a user session in the PagerDuty web app.
         *
         *     Deleting an OAuth delegation will revoke that instance of an app's access to that user or account.
         *     To grant access again, reauthorization/reauthentication will be required.
         *
         *     This endpoint supports deleting mobile app OAuth delegations for a given user, which is equivalent to signing users out of the mobile app. It also supports deleting delegations of type web, which is equivalent to signing users out of the web app.
         *
         *     This is a synchronous API.
         *
         *     Scoped OAuth requires: `oauth_delegations.write`
         */
        delete: operations["deleteOauthDelegations"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/oauth_delegations/revocation_requests/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get OAuth delegations revocation requests status
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated as OAuth token revocation is now synchronous. Please use the [DELETE /oauth_delegations endpoint](https://developer.pagerduty.com/api-reference/ad1161db75db1-delete-all-o-auth-delegations) instead.
         *
         *     Get the status of all OAuth delegations revocation requests for this account, specifically how many requests are still pending. As all requests are now synchronous, no pending requests will be found.
         *
         *     This endpoint is limited to account owners and admins.
         *
         *     Scoped OAuth requires: `oauth_delegations.read`
         */
        get: operations["getOauthDelegationsRevocationRequestsStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/oncalls": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all of the on-calls
         * @description List the on-call entries during a given time range.
         *
         *     An on-call represents a contiguous unit of time for which a User will be on call for a given Escalation Policy and Escalation Rules.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#on-calls)
         *
         *     Scoped OAuth requires: `oncalls.read`
         *
         *     This API operation has operation specific rate limits. See the [Rate Limits](https://developer.pagerduty.com/docs/72d3b724589e3-rest-api-rate-limits) page for more information.
         */
        get: operations["listOnCalls"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/paused_incident_reports/alerts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Paused Incident Reporting on Alerts
         * @description Returns the 5 most recent alerts that were triggered after being paused and the 5 most recent alerts that were resolved after being paused for a given reporting period (maximum 6 months lookback period).  Note: This feature is currently available as part of the Event Intelligence package or Digital Operations plan only.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#paused-incident-reports)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getPausedIncidentReportAlerts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/paused_incident_reports/counts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Paused Incident Reporting counts
         * @description Returns reporting counts for paused Incident usage for a given reporting period (maximum 6 months lookback period).  Note: This feature is currently available as part of the Event Intelligence package or Digital Operations plan only.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#paused-incident-reports)
         *
         *     Scoped OAuth requires: `incidents.read`
         */
        get: operations["getPausedIncidentReportCounts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/priorities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List priorities
         * @description List existing priorities, in order (most to least severe).
         *
         *     A priority is a label representing the importance and impact of an incident.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#priorities)
         *
         *     Scoped OAuth requires: `priorities.read`
         */
        get: operations["listPriorities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/rulesets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Rulesets
         * @description List all Rulesets
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Scoped OAuth requires: `event_rules.read`
         */
        get: operations["listRulesets"];
        put?: never;
        /**
         * Create a Ruleset
         * @description Create a new Ruleset.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Scoped OAuth requires: `event_rules.write`
         */
        post: operations["createRuleset"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/rulesets/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Ruleset
         * @description Get a Ruleset.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Scoped OAuth requires: `event_rules.read`
         */
        get: operations["getRuleset"];
        /**
         * Update a Ruleset
         * @description Update a Ruleset.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Scoped OAuth requires: `event_rules.write`
         */
        put: operations["updateRuleset"];
        post?: never;
        /**
         * Delete a Ruleset
         * @description Delete a Ruleset.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Scoped OAuth requires: `event_rules.write`
         */
        delete: operations["deleteRuleset"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/rulesets/{id}/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Event Rules
         * @description List all Event Rules on a Ruleset.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Note: Create and Update on rules will accept 'description' or 'summary' interchangeably as an extraction action target. Get and List on rules will always return 'summary' as the target. If you are expecting 'description' please change your automation code to expect 'summary' instead.
         *
         *     Scoped OAuth requires: `event_rules.read`
         */
        get: operations["listRulesetEventRules"];
        put?: never;
        /**
         * Create an Event Rule
         * @description Create a new Event Rule.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Note: Create and Update on rules will accept 'description' or 'summary' interchangeably as an extraction action target. Get and List on rules will always return 'summary' as the target. If you are expecting 'description' please change your automation code to expect 'summary' instead.
         *
         *     Scoped OAuth requires: `event_rules.write`
         */
        post: operations["createRulesetEventRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/rulesets/{id}/rules/{rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Event Rule
         * @description Get an Event Rule.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Note: Create and Update on rules will accept 'description' or 'summary' interchangeably as an extraction action target. Get and List on rules will always return 'summary' as the target. If you are expecting 'description' please change your automation code to expect 'summary' instead.
         *
         *     Scoped OAuth requires: `event_rules.read`
         */
        get: operations["getRulesetEventRule"];
        /**
         * Update an Event Rule
         * @description Update an Event Rule. Note that the endpoint supports partial updates, so any number of the writable fields can be provided.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Note: Create and Update on rules will accept 'description' or 'summary' interchangeably as an extraction action target. Get and List on rules will always return 'summary' as the target. If you are expecting 'description' please change your automation code to expect 'summary' instead.
         *
         *     Scoped OAuth requires: `event_rules.write`
         */
        put: operations["updateRulesetEventRule"];
        post?: never;
        /**
         * Delete an Event Rule
         * @description Delete an Event Rule.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Rulesets allow you to route events to an endpoint and create collections of Event Rules, which define sets of actions to take based on event content.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#rulesets)
         *
         *     Scoped OAuth requires: `event_rules.write`
         */
        delete: operations["deleteRulesetEventRule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schedules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List schedules
         * @description List the on-call schedules.
         *
         *     A Schedule determines the time periods that users are On-Call.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#schedules)
         *
         *     Scoped OAuth requires: `schedules.read`
         */
        get: operations["listSchedules"];
        put?: never;
        /**
         * Create a schedule
         * @description Create a new on-call schedule.
         *
         *     A Schedule determines the time periods that users are On-Call.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#schedules)
         *
         *     Scoped OAuth requires: `schedules.write`
         */
        post: operations["createSchedule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schedules/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a schedule
         * @description Show detailed information about a schedule, including entries for each layer.
         *     Scoped OAuth requires: `schedules.read`
         */
        get: operations["getSchedule"];
        /**
         * Update a schedule
         * @description Update an existing on-call schedule.
         *
         *     A Schedule determines the time periods that users are On-Call.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#schedules)
         *
         *     Scoped OAuth requires: `schedules.write`
         */
        put: operations["updateSchedule"];
        post?: never;
        /**
         * Delete a schedule
         * @description Delete an on-call schedule.
         *
         *     A Schedule determines the time periods that users are On-Call.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#schedules)
         *
         *     Scoped OAuth requires: `schedules.write`
         */
        delete: operations["deleteSchedule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schedules/{id}/audit/records": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List audit records for a schedule
         * @description The returned records are sorted by the `execution_time` from newest to oldest.
         *
         *     See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
         *
         *     For more information see the [Audit API Document](https://developer.pagerduty.com/docs/rest-api-v2/audit-records-api/).
         *
         *     Scoped OAuth requires: `audit_records.read`
         */
        get: operations["listSchedulesAuditRecords"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schedules/{id}/overrides": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List overrides
         * @description List overrides for a given time range.
         *
         *     A Schedule determines the time periods that users are On-Call.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#schedules)
         *
         *     Scoped OAuth requires: `schedules.read`
         */
        get: operations["listScheduleOverrides"];
        put?: never;
        /**
         * Create one or more overrides
         * @description Create one or more overrides, each for a specific user covering a specified time range. If you create an override on top of an existing override, the last created override will have priority.
         *
         *     A Schedule determines the time periods that users are On-Call.
         *
         *     Note: An older implementation of this endpoint only supported creating a single ocverride per request. That functionality is still supported, but deprecated and may be removed in the future.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#schedules)
         *
         *     Scoped OAuth requires: `schedules.write`
         */
        post: operations["createScheduleOverride"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schedules/{id}/overrides/{override_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete an override
         * @description Remove an override.
         *
         *     You cannot remove a past override.
         *
         *     If the override start time is before the current time, but the end time is after the current time, the override will be truncated to the current time.
         *
         *     If the override is truncated, the status code will be 200 OK, as opposed to a 204 No Content for a successful delete.
         *
         *     A Schedule determines the time periods that users are On-Call.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#schedules)
         *
         *     Scoped OAuth requires: `schedules.write`
         */
        delete: operations["deleteScheduleOverride"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schedules/{id}/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List users on call.
         * @description List all of the users on call in a given schedule for a given time range.
         *
         *     A Schedule determines the time periods that users are On-Call.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#schedules)
         *
         *     Scoped OAuth requires: `users.read`
         */
        get: operations["listScheduleUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/schedules/preview": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Preview a schedule
         * @description Preview what an on-call schedule would look like without saving it.
         *
         *     A Schedule determines the time periods that users are On-Call.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#schedules)
         *
         *     Scoped OAuth requires: `schedules.write`
         */
        post: operations["createSchedulePreview"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/service_dependencies/associate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Associate service dependencies
         * @description Create new dependencies between two services.
         *
         *     Business services model capabilities that span multiple technical services and that may be owned by several different teams.
         *
         *     A service can have a maximum of 2,000 dependencies with a depth limit of 100. If the limit is reached, the API will respond with an error.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#business-services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["createServiceDependency"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/service_dependencies/business_services/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Business Service dependencies
         * @description Get all immediate dependencies of any Business Service.
         *
         *     Business Services model capabilities that span multiple technical services and that may be owned by several different teams.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#business-services)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getBusinessServiceServiceDependencies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/service_dependencies/disassociate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Disassociate service dependencies
         * @description Disassociate dependencies between two services.
         *
         *     Business services model capabilities that span multiple technical services and that may be owned by several different teams.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#business-services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["deleteServiceDependency"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/service_dependencies/technical_services/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get technical service dependencies
         * @description Get all immediate dependencies of any technical service.
         *     Technical services are also known as `services`.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#services)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getTechnicalServiceServiceDependencies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List services
         * @description List existing Services.
         *
         *     A service may represent an application, component, or team you wish to open incidents against.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#services)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["listServices"];
        put?: never;
        /**
         * Create a service
         * @description Create a new service.
         *
         *     If `status` is included in the request, it must have a value of `active` when creating a new service. If a different status is required, make a second request to update the service.
         *
         *     A service may represent an application, component, or team you wish to open incidents against.
         *
         *     There is a limit of 25,000 services per account. If the limit is reached, the API will respond with an error. There is also a limit of 100,000 open Incidents per Service. If the limit is reached and `auto_resolve_timeout` is disabled (set to 0 or null), the `auto_resolve_timeout` property will automatically be set to  84600 (1 day).
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["createService"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a service
         * @description Get details about an existing service.
         *
         *     A service may represent an application, component, or team you wish to open incidents against.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#services)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getService"];
        /**
         * Update a service
         * @description Update an existing service.
         *
         *     A service may represent an application, component, or team you wish to open incidents against.
         *
         *     There is a limit of 100,000 open Incidents per Service. If the limit is reached and you disable `auto_resolve_timeout` (set to 0 or null), the API will respond with an error.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateService"];
        post?: never;
        /**
         * Delete a service
         * @description Delete an existing service.
         *
         *     Once the service is deleted, it will not be accessible from the web UI and new incidents won't be able to be created for this service.
         *
         *     A service may represent an application, component, or team you wish to open incidents against.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        delete: operations["deleteService"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/audit/records": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List audit records for a service
         * @description The returned records are sorted by the `execution_time` from newest to oldest.
         *
         *     See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
         *
         *     For more information see the [Audit API Document](https://developer.pagerduty.com/docs/rest-api-v2/audit-records-api/).
         *
         *     Scoped OAuth requires: `audit_records.read`
         */
        get: operations["listServiceAuditRecords"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/change_events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Change Events for a service
         * @description List all of the existing Change Events for a service.
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["listServiceChangeEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/integrations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a new integration
         * @description Create a new integration belonging to a Service.
         *
         *     A service may represent an application, component, or team you wish to open incidents against.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["createServiceIntegration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/integrations/{integration_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * View an integration
         * @description Get details about an integration belonging to a service.
         *
         *     A service may represent an application, component, or team you wish to open incidents against.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#services)
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getServiceIntegration"];
        /**
         * Update an existing integration
         * @description Update an integration belonging to a Service.
         *
         *     A service may represent an application, component, or team you wish to open incidents against.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#services)
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateServiceIntegration"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Service's Event Rules
         * @description List Event Rules on a Service.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["listServiceEventRules"];
        put?: never;
        /**
         * Create an Event Rule on a Service
         * @description Create a new Event Rule on a Service.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["createServiceEventRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/rules/convert": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Convert a Service's Event Rules into Event Orchestration Rules
         * @description Convert this Service's Event Rules into functionally equivalent Event Orchestration Rules.
         *
         *     Sending a request to this API endpoint has several effects:
         *
         *     1. Automatically creates Event Orchestration Rules for this Service that will behave identically as this Service's currently configured Event Rules.
         *     2. Makes all existing Event Rules for this Service read-only. All future updates need to be made via the newly created Event Orchestration rules.
         *
         *     Sending a request to this API endpoint will **not** change how future events will be processed. If past events for this Service have been evaluated via Event Rules then new events sent to this Service will also continue to be evaluated via the (now read-only) Event Rules. To change this Service so that new events start being evaluated via the newly created Event Orchestration Rules use the [Update the Service Orchestration active status for a Service API](https://developer.pagerduty.com/api-reference/855659be83d9e-update-the-service-orchestration-active-status-for-a-service).
         *
         *     > ### End-of-life
         *     > Event Rules will end-of-life soon. We highly recommend that you use this API to [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Scoped OAuth requires: `services.write`
         */
        post: operations["convertServiceEventRulesToEventOrchestration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/rules/{rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an Event Rule from a Service
         * @description Get an Event Rule from a Service.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getServiceEventRule"];
        /**
         * Update an Event Rule on a Service
         * @description Update an Event Rule on a Service. Note that the endpoint supports partial updates, so any number of the writable fields can be provided.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateServiceEventRule"];
        post?: never;
        /**
         * Delete an Event Rule from a Service
         * @description Delete an Event Rule from a Service.
         *     <!-- theme: warning -->
         *     > ### End-of-life
         *     > Rulesets and Event Rules will end-of-life soon. We highly recommend that you [migrate to Event Orchestration](https://support.pagerduty.com/docs/migrate-to-event-orchestration) as soon as possible so you can take advantage of the new functionality, such as improved UI, rule creation, APIs and Terraform support, advanced conditions, and rule nesting.
         *
         *     Scoped OAuth requires: `services.write`
         */
        delete: operations["deleteServiceEventRule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/custom_fields": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Fields
         * @description List Custom Fields available for Services.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["listServiceCustomFields"];
        put?: never;
        /**
         * Create a Field
         * @description Creates a new Custom Field for Services, along with the Field Options if provided.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        post: operations["createServiceCustomField"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/custom_fields/{field_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Field
         * @description Show detailed information about a Custom Field for Services.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["getServiceCustomField"];
        /**
         * Update a Field
         * @description Update a Custom Field for Services.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        put: operations["updateServiceCustomField"];
        post?: never;
        /**
         * Delete a Field
         * @description Delete a Custom Field from Services.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        delete: operations["deleteServiceCustomField"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/custom_fields/{field_id}/field_options": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Field Options
         * @description List all options for a given field.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["listServiceCustomFieldOptions"];
        put?: never;
        /**
         * Create a Field Option
         * @description Create a new option for the given field.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        post: operations["createServiceCustomFieldOption"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/custom_fields/{field_id}/field_options/{field_option_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Field Option
         * @description Get a field option for a given field.
         *
         *     Scoped OAuth requires: `custom_fields.read`
         */
        get: operations["getServiceCustomFieldOption"];
        /**
         * Update a Field Option
         * @description Update a field option for a given field.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        put: operations["updateServiceCustomFieldOption"];
        post?: never;
        /**
         * Delete a Field Option
         * @description Delete a field option.
         *
         *     Scoped OAuth requires: `custom_fields.write`
         */
        delete: operations["deleteServiceCustomFieldOption"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/custom_fields/values": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Custom Field Values
         * @description Get custom field values for a service.
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["getServiceCustomFieldValues"];
        /**
         * Update Custom Field Values
         * @description Set custom field values for a service.
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateServiceCustomFieldValues"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/enablements": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Enablements for a Service
         * @description <!-- theme: warning -->
         *     > ### Limited GA
         *     > This feature is in Limited General Availability for some customers with the PagerDuty AIOps add-on. Please contact your account team or Support to request access.
         *
         *     List all feature enablement settings for a service. Currently, only the `aiops` enablement is supported.
         *
         *     For any account with the AIOps product addon, every service will have AIOps features enabled by default.
         *
         *     **Warning conditions**:
         *     - If the account is not entitled to use AIOps features, a warning will be returned alongside the enablement data.
         *
         *     Scoped OAuth requires: `services.read`
         */
        get: operations["listServiceFeatureEnablements"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/services/{id}/enablements/{feature_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update an Enablement for a Service
         * @description <!-- theme: warning -->
         *     > ### Limited GA
         *     > This feature is in Limited General Availability for some customers with the PagerDuty AIOps add-on. Please contact your account team or Support to request access.
         *
         *     Update the feature enablement setting for a specific product addon on a service. This setting controls enabling or disabling the set of features contained within the addon.
         *     Currently, only `aiops` is supported as a valid feature enablement.
         *
         *     **Warning conditions**:
         *     - If the account is not entitled to use AIOps features, the setting will be updated, but a warning will be returned.
         *
         *     Scoped OAuth requires: `services.write`
         */
        put: operations["updateServiceFeatureEnablement"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/session_configurations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an account's session configurations
         * @description <!-- theme: warning -->
         *     > ### Early Access
         *
         *     > This endpoint is in Early Access and may change at any time. You must pass in the X-EARLY-ACCESS header with the value of `session-configurations-early-access` to access it.
         *
         *     Retrieves session configurations for a PagerDuty account. Returns an array containing
         *     the requested configurations. If a specific type is requested, the array contains one item.
         *     If no type is specified, the array contains all available configurations (mobile and web).
         *     If no configurations exist, a 404 Not Found error will be returned.
         *
         *     A Session Configuration needs to be created before it can be retrieved and used.
         *
         *     Scoped OAuth requires: `session_configurations.read`
         */
        get: operations["getSessionConfigurations"];
        /**
         * Configure an account's session configurations
         * @description <!-- theme: warning -->
         *     > ### Early Access
         *
         *     > This endpoint is in Early Access and may change at any time. You must pass in the X-EARLY-ACCESS header with the value of `session-configurations-early-access` to access it.
         *
         *     Creates or updates session configurations for a PagerDuty Account. The configurations will take effect immediately for new sessions, while existing sessions for the specified `types` are immediately revoked.
         *
         *     Scoped OAuth requires: `session_configurations.write`
         */
        put: operations["updateSessionConfigurations"];
        post?: never;
        /**
         * Delete an account's session configurations.
         * @description <!-- theme: warning -->
         *     > ### Early Access
         *
         *     > This endpoint is in Early Access and may change at any time. You must pass in the X-EARLY-ACCESS header with the value of `session-configurations-early-access` to access it.
         *
         *     Deletes the session configurations for a PagerDuty account that was previously set.
         *     The type parameter is required and specifies which configurations to delete.
         *     A single type ('mobile' or 'web') or comma-separated list may be passed in.
         *
         *     Scoped OAuth requires: `session_configurations.write`
         */
        delete: operations["deleteSessionConfigurations"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/standards": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Standards
         * @description Get all standards of an account.
         *
         *     Scoped OAuth requires: `standards.read`
         */
        get: operations["listStandards"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/standards/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update a standard
         * @description Updates a standard
         *
         *     Scoped OAuth requires: `standards.write`
         */
        put: operations["updateStandard"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/standards/scores/{resource_type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List resources' standards scores
         * @description List standards applied to a set of resources
         *
         *     Scoped OAuth requires: `standards.read`
         */
        get: operations["listResourceStandardsManyServices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/standards/scores/{resource_type}/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List a resource's standards scores
         * @description List standards applied to a specific resource
         *
         *     Scoped OAuth requires: `standards.read`
         */
        get: operations["listResourceStandards"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_dashboards": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Status Dashboards
         * @description Get all your account's custom Status Dashboard views.
         *
         *     Scoped OAuth requires: `status_dashboards.read`
         */
        get: operations["listStatusDashboards"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_dashboards/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single Status Dashboard by `id`
         * @description Get a Status Dashboard by its PagerDuty `id`.
         *
         *     Scoped OAuth requires: `status_dashboards.read`
         */
        get: operations["getStatusDashboardById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_dashboards/{id}/service_impacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get impacted Business Services for a Status Dashboard by `id`.
         * @description Get impacted Business Services for a Status Dashboard by `id`
         *
         *     This endpoint does not return an exhaustive list of Business Services but rather provides access to the most impacted on the specified Status Dashboard up to the limit of 200.
         *
         *     The returned Business Services are sorted first by Impact, secondarily by most recently impacted, and finally by name.
         *
         *     To get Impact information about a specific Business Service on the Status Dashboard that does not appear in the Impact-sorted response, use the `ids[]` parameter on the `/business_services/impacts` endpoint.
         *
         *     Scoped OAuth requires: `status_dashboards.read`
         */
        get: operations["getStatusDashboardServiceImpactsById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_dashboards/url_slugs/{url_slug}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a single Status Dashboard by `url_slug`
         * @description Get a Status Dashboard by its PagerDuty `url_slug`.  A `url_slug` is a human-readable reference
         *     for a custom Status Dashboard that may be created or changed in the UI. It will generally be a `dash-separated-string-like-this`.
         *
         *     Scoped OAuth requires: `status_dashboards.read`
         */
        get: operations["getStatusDashboardByUrlSlug"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_dashboards/url_slugs/{url_slug}/service_impacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get impacted Business Services for a  Status Dashboard by `url_slug`
         * @description Get Business Service Impacts for the Business Services on a Status Dashboard by its `url_slug`. A `url_slug` is a human-readable reference
         *     for a custom Status Dashboard that may be created or changed in the UI. It will generally be a `dash-separated-string-like-this`.
         *
         *     This endpoint does not return an exhaustive list of Business Services but rather provides access to the most impacted on the Status Dashboard up to the limit of 200.
         *
         *     The returned Business Services are sorted first by Impact, secondarily by most recently impacted, and finally by name.
         *
         *     To get impact information about a specific Business Service on the Status Dashboard that does not appear in the Impact-sored response, use the `ids[]` parameter on the `/business_services/impacts` endpoint.
         *
         *     Scoped OAuth requires: `status_dashboards.read`
         */
        get: operations["getStatusDashboardServiceImpactsByUrlSlug"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Status Pages
         * @description List Status Pages.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["listStatusPages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/impacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Status Page Impacts
         * @description List Impacts for a Status Page by Status Page ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["listStatusPageImpacts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/impacts/{impact_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Status Page Impact
         * @description Get an Impact for a Status Page by Status Page ID and Impact ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["getStatusPageImpact"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/services": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Status Page Services
         * @description List Services for a Status Page by Status Page ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["listStatusPageServices"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/services/{service_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Status Page Service
         * @description Get a Service for a Status Page by Status Page ID and Service ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["getStatusPageService"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/severities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Status Page Severities
         * @description List Severities for a Status Page by Status Page ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["listStatusPageSeverities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/severities/{severity_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Status Page Severity
         * @description Get a Severity for a Status Page by Status Page ID and Severity ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["getStatusPageSeverity"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/statuses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Status Page Statuses
         * @description List Statuses for a Status Page by Status Page ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["listStatusPageStatuses"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/statuses/{status_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Status Page Status
         * @description Get a Status for a Status Page by Status Page ID and Status ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["getStatusPageStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/posts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Status Page Posts
         * @description List Posts for a Status Page by Status Page ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["listStatusPagePosts"];
        put?: never;
        /**
         * Create a Status Page Post
         * @description Create a Post for a Status Page by Status Page ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        post: operations["createStatusPagePost"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/posts/{post_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Status Page Post
         * @description Get a Post for a Status Page by Status Page ID and Post ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["getStatusPagePost"];
        /**
         * Update a Status Page Post
         * @description Update a Post for a Status Page by Status Page ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        put: operations["updateStatusPagePost"];
        post?: never;
        /**
         * Delete a Status Page Post
         * @description Delete a Post for a Status Page by Status Page ID and Post ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        delete: operations["deleteStatusPagePost"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/posts/{post_id}/post_updates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Status Page Post Updates
         * @description List Post Updates for a Status Page by Status Page ID and Post ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["listStatusPagePostUpdates"];
        put?: never;
        /**
         * Create a Status Page Post Update
         * @description Create a Post Update for a Post by Post ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        post: operations["createStatusPagePostUpdate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/posts/{post_id}/post_updates/{post_update_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Status Page Post Update
         * @description Get a Post Update for a Post by Post ID and Post Update ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["getPostUpdate"];
        /**
         * Update a Status Page Post Update
         * @description Update a Post Update for a Post by Post ID and Post Update ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        put: operations["updateStatusPagePostUpdate"];
        post?: never;
        /**
         * Delete a Status Page Post Update
         * @description Delete a Post Update for a Post by Post ID and Post Update ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        delete: operations["deleteStatusPagePostUpdate"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/posts/{post_id}/postmortem": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Post Postmortem
         * @description Get a Postmortem for a Post by Post ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["getPostmortem"];
        /**
         * Update a Post Postmortem
         * @description Update a Postmortem for a Post by Post ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        put: operations["updateStatusPagePostmortem"];
        /**
         * Create a Post Postmortem
         * @description Create a Postmortem for a Post by Post ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        post: operations["createStatusPagePostmortem"];
        /**
         * Delete a Post Postmortem
         * @description Delete a Postmortem for a Post by Post ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        delete: operations["deleteStatusPagePostmortem"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Status Page Subscriptions
         * @description List Subscriptions for a Status Page by Status Page ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["listStatusPageSubscriptions"];
        put?: never;
        /**
         * Create a Status Page Subscription
         * @description Create a Subscription for a Status Page by Status Page ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        post: operations["createStatusPageSubscription"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status_pages/{id}/subscriptions/{subscription_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a Status Page Subscription
         * @description Get a Subscription for a Status Page by Status Page ID and Subscription ID.
         *
         *     Scoped OAuth requires: `status_pages.read`
         */
        get: operations["getStatusPageSubscription"];
        put?: never;
        post?: never;
        /**
         * Delete a Status Page Subscription
         * @description Delete a Subscription for a Status Page by Status Page ID and Subscription ID.
         *
         *     Scoped OAuth requires: `status_pages.write`
         */
        delete: operations["deleteStatusPageSubscription"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List tags
         * @description List all of your account's tags.
         *
         *     A Tag is applied to Escalation Policies, Teams or Users and can be used to filter them.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#tags)
         *
         *     Scoped OAuth requires: `tags.read`
         */
        get: operations["listTags"];
        put?: never;
        /**
         * Create a tag
         * @description Create a Tag.
         *
         *     A Tag is applied to Escalation Policies, Teams or Users and can be used to filter them.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#tags)
         *
         *     Scoped OAuth requires: `tags.write`
         */
        post: operations["createTags"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tags/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a tag
         * @description Get details about an existing Tag.
         *
         *     A Tag is applied to Escalation Policies, Teams or Users and can be used to filter them.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#tags)
         *
         *     Scoped OAuth requires: `tags.read`
         */
        get: operations["getTag"];
        put?: never;
        post?: never;
        /**
         * Delete a tag
         * @description Remove an existing Tag.
         *
         *     A Tag is applied to Escalation Policies, Teams or Users and can be used to filter them.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#tags)
         *
         *     Scoped OAuth requires: `tags.write`
         */
        delete: operations["deleteTag"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tags/{id}/{entity_type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get connected entities
         * @description Get related Users, Teams or Escalation Policies for the Tag.
         *
         *     A Tag is applied to Escalation Policies, Teams or Users and can be used to filter them.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#tags)
         *
         *     Scoped OAuth requires: `tags.read`
         */
        get: operations["getTagsByEntityType"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List teams
         * @description List teams of your PagerDuty account, optionally filtered by a search query.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.read`
         */
        get: operations["listTeams"];
        put?: never;
        /**
         * Create a team
         * @description Create a new Team.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.write`
         */
        post: operations["createTeam"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a team
         * @description Get details about an existing team.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.read`
         */
        get: operations["getTeam"];
        /**
         * Update a team
         * @description Update an existing team.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.write`
         */
        put: operations["updateTeam"];
        post?: never;
        /**
         * Delete a team
         * @description Remove an existing team.
         *
         *     Succeeds only if the team has no associated Escalation Policies, Services, Schedules and Subteams.
         *
         *     All associated unresovled incidents will be reassigned to another team (if specified) or will loose team association, thus becoming account-level (with visibility implications).
         *
         *     Note that the incidents reassignment process is asynchronous and has no guarantee to complete before the API call return.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.write`
         */
        delete: operations["deleteTeam"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/audit/records": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List audit records for a team
         * @description The returned records are sorted by the `execution_time` from newest to oldest.
         *
         *     See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
         *
         *     For more information see the [Audit API Document](https://developer.pagerduty.com/docs/rest-api-v2/audit-records-api/).
         *
         *     Scoped OAuth requires: `audit_records.read`
         */
        get: operations["listTeamsAuditRecords"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/escalation_policies/{escalation_policy_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Add an escalation policy to a team
         * @description Add an escalation policy to a team.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.write`
         */
        put: operations["updateTeamEscalationPolicy"];
        post?: never;
        /**
         * Remove an escalation policy from a team
         * @description Remove an escalation policy from a team.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.write`
         */
        delete: operations["deleteTeamEscalationPolicy"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/members": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List members of a team
         * @description Get information about members on a team.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.read`
         */
        get: operations["listTeamUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/notification_subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Team Notification Subscriptions
         * @description Retrieve a list of Notification Subscriptions the given Team has.
         *
         *     <!-- theme: warning -->
         *     > Teams must be added through `POST /teams/{id}/notification_subscriptions` to be returned from this endpoint.
         *
         *     Scoped OAuth requires: `subscribers.read`
         */
        get: operations["getTeamNotificationSubscriptions"];
        put?: never;
        /**
         * Create Team Notification Subscriptions
         * @description Create new Notification Subscriptions for the given Team.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        post: operations["createTeamNotificationSubscriptions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/notification_subscriptions/unsubscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Unsubscribe the given Team from Notifications on the matching Subscribable entities.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        post: operations["removeTeamNotificationSubscriptions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/teams/{id}/users/{user_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Add a user to a team
         * @description Add a user to a team. Attempting to add a user with the `read_only_user` role will return a 400 error.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.write`
         */
        put: operations["updateTeamUser"];
        post?: never;
        /**
         * Remove a user from a team
         * @description Remove a user from a team.
         *
         *     A team is a collection of Users and Escalation Policies that represent a group of people within an organization.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#teams)
         *
         *     Scoped OAuth requires: `teams.write`
         */
        delete: operations["deleteTeamUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List templates
         * @description Get a list of all the template on an account
         *
         *     Scoped OAuth requires: `templates.read`
         */
        get: operations["getTemplates"];
        put?: never;
        /**
         * Create a template
         * @description Create a new template
         *
         *     Scoped OAuth requires: `templates.write`
         */
        post: operations["createTemplate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a template
         * @description Get a single template on the account
         *
         *     Scoped OAuth requires: `templates.read`
         */
        get: operations["getTemplate"];
        /**
         * Update a template
         * @description Update an existing template
         *
         *     Scoped OAuth requires: `templates.write`
         */
        put: operations["updateTemplate"];
        post?: never;
        /**
         * Delete a template
         * @description Delete a specific of templates on the account
         *
         *     Scoped OAuth requires: `templates.write`
         */
        delete: operations["deleteTemplate"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/{id}/render": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Render a template
         * @description Render a template. This endpoint has a variable request body depending on the template type. For the `status_update` template type, the caller will provide the incident id, and a status update message.
         *
         *     Scoped OAuth requires: `templates.read`
         */
        post: operations["renderTemplate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/fields": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List template fields
         * @description Get a list of fields that can be used on the account templates.
         *
         *     Scoped OAuth requires: `templates.read`
         */
        get: operations["getTemplateFields"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List users
         * @description List users of your PagerDuty account, optionally filtered by a search query.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.read`
         */
        get: operations["listUsers"];
        put?: never;
        /**
         * Create a user
         * @description Create a new user.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.write`
         */
        post: operations["createUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a user
         * @description Get details about an existing user.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.read`
         */
        get: operations["getUser"];
        /**
         * Update a user
         * @description Update an existing user.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.write`
         */
        put: operations["updateUser"];
        post?: never;
        /**
         * Delete a user
         * @description Remove an existing user.
         *
         *     Returns 400 if the user has assigned incidents unless your [pricing plan](https://www.pagerduty.com/pricing) has the `offboarding` feature and the account is [configured](https://support.pagerduty.com/docs/offboarding#section-additional-configurations) appropriately.
         *
         *     Note that the incidents reassignment process is asynchronous and has no guarantee to complete before the api call return.
         *
         *     [*Learn more about `offboarding` feature*](https://support.pagerduty.com/docs/offboarding).
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.write`
         */
        delete: operations["deleteUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/audit/records": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List audit records for a user
         * @description The response will include audit records with changes that are made to the identified user not changes made by the identified user.
         *
         *
         *     The returned records are sorted by the `execution_time` from newest to oldest.
         *
         *     See [`Cursor-based pagination`](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for instructions on how to paginate through the result set.
         *
         *     For more information see the [Audit API Document](https://developer.pagerduty.com/docs/rest-api-v2/audit-records-api/).
         *
         *     Scoped OAuth requires: `audit_records.read`
         */
        get: operations["listUsersAuditRecords"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/contact_methods": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List a user's contact methods
         * @description List contact methods of your PagerDuty user.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.read`
         */
        get: operations["getUserContactMethods"];
        put?: never;
        /**
         * Create a user contact method
         * @description Create a new contact method for the User.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.write`
         */
        post: operations["createUserContactMethod"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/contact_methods/{contact_method_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a user's contact method
         * @description Get details about a User's contact method.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.read`
         */
        get: operations["getUserContactMethod"];
        /**
         * Update a user's contact method
         * @description Update a User's contact method.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.write`
         */
        put: operations["updateUserContactMethod"];
        post?: never;
        /**
         * Delete a user's contact method
         * @description Remove a user's contact method.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.write`
         */
        delete: operations["deleteUserContactMethod"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/license": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the License allocated to a User
         * @description Get the License allocated to a User
         *
         *     Scoped OAuth requires: `licenses.read`
         */
        get: operations["getUserLicense"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/notification_rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List a user's notification rules
         * @description List notification rules of your PagerDuty user.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.read`
         */
        get: operations["getUserNotificationRules"];
        put?: never;
        /**
         * Create a user notification rule
         * @description Create a new notification rule.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.write`
         */
        post: operations["createUserNotificationRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/notification_rules/{notification_rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a user's notification rule
         * @description Get details about a user's notification rule.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.read`
         */
        get: operations["getUserNotificationRule"];
        /**
         * Update a user's notification rule
         * @description Update a user's notification rule.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.write`
         */
        put: operations["updateUserNotificationRule"];
        post?: never;
        /**
         * Delete a user's notification rule
         * @description Remove a user's notification rule.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:contact_methods.write`
         */
        delete: operations["deleteUserNotificationRule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/notification_subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Notification Subscriptions
         * @description Retrieve a list of Notification Subscriptions the given User has.
         *
         *     <!-- theme: warning -->
         *     > Users must be added through `POST /users/{id}/notification_subscriptions` to be returned from this endpoint.
         *
         *     Scoped OAuth requires: `subscribers.read`
         */
        get: operations["getUserNotificationSubscriptions"];
        put?: never;
        /**
         * Create Notification Subcriptions
         * @description Create new Notification Subscriptions for the given User.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        post: operations["createUserNotificationSubscriptions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/notification_subscriptions/unsubscribe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Remove Notification Subscriptions
         * @description Unsubscribe the given User from Notifications on the matching Subscribable entities.
         *
         *     Scoped OAuth requires: `subscribers.write`
         */
        post: operations["unsubscribeUserNotificationSubscriptions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/oncall_handoff_notification_rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List a User's Handoff Notification Rules
         * @description List Handoff Notification Rules of your PagerDuty User.
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.read`
         */
        get: operations["getUserHandoffNotificationRules"];
        put?: never;
        /**
         * Create a User Handoff Notification Rule
         * @description Create a new Handoff Notification Rule.
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.write`
         */
        post: operations["createUserHandoffNotificationRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/oncall_handoff_notification_rules/{oncall_handoff_notification_rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a user's handoff notification rule
         * @description Get details about a User's Handoff Notification Rule.
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.read`
         */
        get: operations["getUserHandoffNotifiactionRule"];
        /**
         * Update a User's Handoff Notification Rule
         * @description Update a User's Handoff Notification Rule.
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.write`
         */
        put: operations["updateUserHandoffNotification"];
        post?: never;
        /**
         * Delete a User's Handoff Notification rule
         * @description Remove a User's Handoff Notification Rule.
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.write`
         */
        delete: operations["deleteUserHandoffNotificationRule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/sessions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List a user's active sessions
         * @description List active sessions of a PagerDuty user.
         *
         *     Beginning November 2021, active sessions no longer includes newly issued OAuth tokens.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:sessions.read`
         */
        get: operations["getUserSessions"];
        put?: never;
        post?: never;
        /**
         * Delete all user sessions
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated as OAuth token revocation is now synchronous. Please use the [DELETE /oauth_delegations endpoint](https://developer.pagerduty.com/api-reference/ad1161db75db1-delete-all-o-auth-delegations) instead.
         *
         *     Delete all user sessions.
         *
         *     Beginning November 2021, user sessions no longer includes newly issued OAuth tokens.
         *
         *     If you are interested in deleting mobile app sessions, refer to the Delete OAuth Delegations endpoint.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:sessions.write`
         */
        delete: operations["deleteUserSessions"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/sessions/{type}/{session_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a user's session
         * @description Get details about a user's session.
         *
         *     Beginning November 2021, user sessions no longer includes newly issued OAuth tokens.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:sessions.read`
         */
        get: operations["getUserSession"];
        put?: never;
        post?: never;
        /**
         * Delete a user's session
         * @deprecated
         * @description <!-- theme: warning -->
         *     > ### Deprecated
         *     > This endpoint is deprecated as OAuth token revocation is now synchronous. Please use the [DELETE /oauth_delegations endpoint](https://developer.pagerduty.com/api-reference/ad1161db75db1-delete-all-o-auth-delegations) instead.
         *
         *     Delete a user's session.
         *
         *     Beginning November 2021, user sessions no longer includes newly issued OAuth tokens.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users:sessions.write`
         */
        delete: operations["deleteUserSession"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/status_update_notification_rules": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List a user's status update notification rules
         * @description List status update notification rules of your PagerDuty user.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.read`
         */
        get: operations["getUserStatusUpdateNotificationRules"];
        put?: never;
        /**
         * Create a user status update notification rule
         * @description Create a new status update notification rule.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.write`
         */
        post: operations["createUserStatusUpdateNotificationRule"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/{id}/status_update_notification_rules/{status_update_notification_rule_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a user's status update notification rule
         * @description Get details about a user's status update notification rule.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.read`
         */
        get: operations["getUserStatusUpdateNotificationRule"];
        /**
         * Update a user's status update notification rule
         * @description Update a user's status update notification rule.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.write`
         */
        put: operations["updateUserStatusUpdateNotificationRule"];
        post?: never;
        /**
         * Delete a user's status update notification rule
         * @description Remove a user's status update notification rule.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         *
         *     Scoped OAuth requires: `users.write`
         */
        delete: operations["deleteUserStatusUpdateNotificationRule"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the current user
         * @description Get details about the current user.
         *
         *     This endpoint can only be used with a [user-level API key](https://support.pagerduty.com/docs/using-the-api#section-generating-a-personal-rest-api-key) or a key generated through an OAuth flow. This will not work if the request is made with an account-level access token.
         *
         *     Users are members of a PagerDuty account that have the ability to interact with Incidents and other data on the account.
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#users)
         */
        get: operations["getCurrentUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vendors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List vendors
         * @description List all vendors.
         *
         *     A PagerDuty Vendor represents a specific type of integration. AWS Cloudwatch, Splunk, Datadog are all examples of vendors
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#vendors)
         *
         *     Scoped OAuth requires: `vendors.read`
         */
        get: operations["listVendors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/vendors/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a vendor
         * @description Get details about one specific vendor.
         *
         *     A PagerDuty Vendor represents a specific type of integration. AWS Cloudwatch, Splunk, Datadog are all examples of vendors
         *
         *     For more information see the [API Concepts Document](../../api-reference/a47605517c19a-api-concepts#vendors)
         *
         *     Scoped OAuth requires: `vendors.read`
         */
        get: operations["getVendor"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhook_subscriptions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List webhook subscriptions
         * @description List existing webhook subscriptions.
         *
         *     The `filter_type` and `filter_id` query parameters may be used to only show subscriptions
         *     for a particular _service_ or _team_.
         *
         *     For more information on webhook subscriptions and how they are used to configure v3 webhooks
         *     see the [Webhooks v3 Developer Documentation](https://developer.pagerduty.com/docs/webhooks/v3-overview/).
         *
         *     Scoped OAuth requires: `webhook_subscriptions.read`
         */
        get: operations["listWebhookSubscriptions"];
        put?: never;
        /**
         * Create a webhook subscription
         * @description Creates a new webhook subscription.
         *
         *     For more information on webhook subscriptions and how they are used to configure v3 webhooks
         *     see the [Webhooks v3 Developer Documentation](https://developer.pagerduty.com/docs/webhooks/v3-overview/).
         *
         *     Scoped OAuth requires: `webhook_subscriptions.write`
         */
        post: operations["createWebhookSubscription"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhook_subscriptions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a webhook subscription
         * @description Gets details about an existing webhook subscription.
         *
         *     Scoped OAuth requires: `webhook_subscriptions.read`
         */
        get: operations["getWebhookSubscription"];
        /**
         * Update a webhook subscription
         * @description Updates an existing webhook subscription.
         *
         *     Only the fields being updated need to be included on the request.  This operation does not
         *     support updating the `delivery_method` of the webhook subscription.
         *
         *     Scoped OAuth requires: `webhook_subscriptions.write`
         */
        put: operations["updateWebhookSubscription"];
        post?: never;
        /**
         * Delete a webhook subscription
         * @description Deletes a webhook subscription.
         *
         *     Scoped OAuth requires: `webhook_subscriptions.write`
         */
        delete: operations["deleteWebhookSubscription"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhook_subscriptions/{id}/enable": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Enable a webhook subscription
         * @description Enable a webhook subscription that is temporarily disabled. (This API does not require a request body.)
         *
         *     Webhook subscriptions can become temporarily disabled when the subscription's delivery method is repeatedly rejected by the server.
         *
         *     Scoped OAuth requires: `webhook_subscriptions.write`
         */
        post: operations["enableWebhookSubscription"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhook_subscriptions/{id}/ping": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test a webhook subscription
         * @description Test a webhook subscription.
         *
         *     Fires a test event against the webhook subscription.  If properly configured,
         *     this will deliver the `pagey.ping` webhook event to the destination.
         *
         *     Scoped OAuth requires: `webhook_subscriptions.write`
         */
        post: operations["testWebhookSubscription"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhook_subscriptions/oauth_clients": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List OAuth clients
         * @description List all OAuth clients for webhook subscriptions. Maximum of 10 clients per account.
         *
         *     Requires admin or owner role permissions.
         */
        get: operations["listOauthClients"];
        put?: never;
        /**
         * Create an OAuth client
         * @description Create a new OAuth client for webhook subscriptions. The client credentials will be validated by attempting to obtain an access token before creation.
         *
         *     Requires admin or owner role permissions.
         *
         *     Maximum of 10 OAuth clients per account.
         */
        post: operations["createOauthClient"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhook_subscriptions/oauth_clients/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get an OAuth client
         * @description Get details of a specific OAuth client by ID.
         *
         *     Requires admin or owner role permissions.
         */
        get: operations["getOauthClient"];
        /**
         * Update an OAuth client
         * @description Update an existing OAuth client. Any change will trigger token validation with the OAuth server.
         *
         *     Requires admin or owner role permissions.
         */
        put: operations["updateOauthClient"];
        post?: never;
        /**
         * Delete an OAuth client
         * @description Delete an OAuth client. This will also remove the OAuth client association from any webhook subscriptions using it.
         *
         *     Requires admin or owner role permissions.
         */
        delete: operations["deleteOauthClient"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflows/integrations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Workflow Integrations
         * @description List available Workflow Integrations.
         *
         *     Scoped OAuth requires: `workflow_integrations.read`
         */
        get: operations["listWorkflowIntegrations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflows/integrations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Workflow Integration
         * @description Get details about a Workflow Integration.
         *
         *     Scoped OAuth requires: `workflow_integrations.read`
         */
        get: operations["getWorkflowIntegration"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflows/integrations/connections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all Workflow Integration Connections
         * @description List all Workflow Integration Connections.
         *
         *     Scoped OAuth requires: `workflow_integrations:connections.read`
         */
        get: operations["listWorkflowIntegrationConnections"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflows/integrations/{integration_id}/connections": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the Workflow Integration */
                integration_id: components["parameters"]["workflow_integrations_integration_id"];
            };
            cookie?: never;
        };
        /**
         * List Workflow Integration Connections
         * @description List all Workflow Integration Connections for a specific Workflow Integration.
         *
         *     Scoped OAuth requires: `workflow_integrations:connections.read`
         */
        get: operations["listWorkflowIntegrationConnectionsByIntegration"];
        put?: never;
        /**
         * Create Workflow Integration Connection
         * @description Create a new Workflow Integration Connection.
         *
         *     Scoped OAuth requires: `workflow_integrations:connections.write`
         */
        post: operations["createWorkflowIntegrationConnection"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflows/integrations/{integration_id}/connections/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the Workflow Integration */
                integration_id: components["parameters"]["workflow_integrations_integration_id"];
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /**
         * Get Workflow Integration Connection
         * @description Get details about a Workflow Integration Connection.
         *
         *     Scoped OAuth requires: `workflow_integrations:connections.read`
         */
        get: operations["getWorkflowIntegrationConnection"];
        put?: never;
        post?: never;
        /**
         * Delete Workflow Integration Connection
         * @description Delete a Workflow Integration Connection.
         *
         *     Scoped OAuth requires: `workflow_integrations:connections.write`
         */
        delete: operations["deleteWorkflowIntegrationConnection"];
        options?: never;
        head?: never;
        /**
         * Update Workflow Integration Connection
         * @description Update an existing Workflow Integration Connection.
         *
         *     Scoped OAuth requires: `workflow_integrations:connections.write`
         */
        patch: operations["updateWorkflowIntegrationConnection"];
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        0: {
            /**
             * @description The kind of data represented by this option. Must match the Field's `data_type`. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            data_type: "string";
            value: string;
        };
        /**
         * @description A rule for contacting the user for Incident Status Updates.
         * @example {
         *       "contact_method": {
         *         "id": "PXPGF42",
         *         "type": "email_contact_method_reference"
         *       }
         *     }
         */
        StatusUpdateNotificationRule: {
            contact_method: components["schemas"]["ContactMethodReference"];
        };
        AnalyticsModel: {
            /** @description Accepts a set of filters to apply to the Incidents before aggregating.  Any incidents that do not match the included filters will be omitted from the results. */
            filters?: {
                /**
                 * @description Accepts an ISO8601 DateTime string. Any incidents with a created_at less than this value will be omitted from the results. The maximum supported time range in conjunction with created_at_end is one year.
                 * @example 2024-01-01T00:00:00+05:00
                 */
                created_at_start?: string;
                /**
                 * @description Accepts an ISO8601 DateTime string. Any incidents with a created_at greater than or equal to this value will be omitted from the results. The maximum supported time range in conjunction with created_at_start is one year.
                 * @example 2024-02-01T00:00:00Z
                 */
                created_at_end?: string;
                /**
                 * @description Any incidents whose urgency does not match the provided string will be omitted from the results.
                 * @example high
                 * @enum {string}
                 */
                urgency?: "high" | "low";
                /**
                 * @description A boolean flag including whether results should contain *only* [major incidents](https://support.pagerduty.com/docs/operational-reviews#major-incidents), or exclude major incidents. If no value is provided all incidents will be included.
                 * @example true
                 */
                major?: boolean;
                /**
                 * @description An integer that sets the requirement for the minimum number of acknowledgements to occur on an incident. For example, setting this to 1 will return only incidents that have at least 1 acknowledgement. If no value is provided, all incidents will be included.
                 * @example 1
                 */
                min_ackowledgements?: number;
                /**
                 * @description An integer that sets the requirement for the minimum number of timeout escalations to occur on an incident. For example, setting this to 1 will return only incidents that have at least 1 timeout escalation. If no value is provided, all incidents will be included.
                 * @example 1
                 */
                min_timeout_escalations?: number;
                /**
                 * @description An integer that sets the requirement for the minimum number of manual escalations to occur on an incident. For example, setting this to 1 will return only incidents that have at least 1 manual escalation. If no value is provided, all incidents will be included.
                 * @example 1
                 */
                min_manual_escalations?: number;
                /**
                 * @description An array of team IDs. Only incidents related to these teams will be included in the results. If omitted, all teams the requestor has access to will be included in the results.
                 * @example [
                 *       "P373JQQ",
                 *       "PAECHJV",
                 *       "P7SYGW6"
                 *     ]
                 */
                team_ids?: string[];
                /**
                 * @description An array of service IDs. Only incidents related to these services will be included in the results. If omitted, all services the requestor has access to will be included in the results.
                 * @example [
                 *       "PSEJLIN",
                 *       "PSLWBL8",
                 *       "PT4KHLX"
                 *     ]
                 */
                service_ids?: string[];
                /**
                 * @description An array of escalation policy IDs. Only incidents related to these escalation policies will be included in the results. If omitted, all escalation policies the requestor has access to will be included in the results.
                 * @example [
                 *       "PDJXDF3",
                 *       "PG4EHNS"
                 *     ]
                 */
                escalation_policy_ids?: string[];
                /**
                 * @description An array of priority IDs. Only incidents with these priorities will be included in the results. If omitted, all priorities will be included in the results.
                 * @example [
                 *       "PC8O0L3",
                 *       "PX01HJD",
                 *       "P5FK83M"
                 *     ]
                 */
                priority_ids?: string[];
                /**
                 * @description An array of user-defined priority names. Only incidents with these priorities will be included in the results. If omitted, all priorities will be included in the results.
                 * @example [
                 *       "P1",
                 *       "P2",
                 *       "P3"
                 *     ]
                 */
                priority_names?: string[];
                /**
                 * @description If true, only incidents where PD Advance was used will be included in the results, and vice versa. If omitted, all incidents will be included.
                 * @example true
                 */
                pd_advance_used?: boolean;
            };
            /**
             * @description The time zone to use for the results and grouping. Must be in tzdata format. See list of accepted values [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
             * @example Etc/UTC
             */
            time_zone?: string;
            /**
             * @description The order in which the results were sorted; asc for ascending, desc for descending.
             * @enum {string}
             */
            order?: "asc" | "desc";
            /**
             * @description The column that was used for ordering the results.
             * @example created_at
             */
            order_by?: string;
            /**
             * @description The time unit to aggregate metrics by.  If no value is provided, the metrics will be aggregated for the entire period.
             * @example day
             * @enum {string|null}
             */
            aggregate_unit?: "day" | "week" | "month" | null;
        };
        /** Analytics Incident Metrics */
        AnalyticsIncidentMetrics: {
            /** @description Mean count of instances where responders were assigned an incident (including through reassignment or escalation) or accepted a responder request. */
            mean_assignment_count?: number;
            /**
             * @description Mean engaged time across all responders.
             *     Engaged time is measured from the time a user engages with an incident (by
             *     acknowledging or accepting a responder request) until the incident is resolved.
             *     This may include periods in which the incidents were snoozed.
             */
            mean_engaged_seconds?: number;
            /**
             * @description Mean number of users who engaged with an incident. *Engaged* is defined as
             *     acknowledging an incident or accepting a responder request in it.
             */
            mean_engaged_user_count?: number;
            /**
             * @description A measure of *people response time*. This metric measures the time from
             *     the first user engagement (acknowledge or responder accept) to the last.
             *     This metric is only used for incidents with **multiple responders**;
             *     for incidents with one or no engaged users, this value is null.
             */
            mean_seconds_to_engage?: number;
            /** @description Mean time between the start of an incident, and the first responder to acknowledge. */
            mean_seconds_to_first_ack?: number;
            /**
             * @description Mean time between the start of an incident, and the last additional responder
             *     to acknowledge. For incidents with one or no engaged users, this value is null.
             */
            mean_seconds_to_mobilize?: number;
            /** @description Mean time from when an incident was triggered until it was resolved. */
            mean_seconds_to_resolve?: number;
            /**
             * @description Mean engaged time across all responders. Engaged time is measured from the time
             *     a user engages with an incident (by acknowledging or accepting a responder request)
             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
             *     This metric uses the incident response effort values that
             *     [users have defined](https://support.pagerduty.com/docs/edit-incidents#edit-incident-duration),
             *     if they exist.
             */
            mean_user_defined_engaged_seconds?: number;
            /** @description Start of the date range for which the metrics were calculated. Only included when an aggregate unit is specified in the request. */
            range_start?: string;
            /** @description ID of the service. Only included when aggregating by service. Not included when aggregating by all. */
            service_id?: string;
            /** @description Name of the service. Only included when aggregating by service. Not included when aggregating by all. */
            service_name?: string;
            /** @description ID of the team to which the incident was assigned. Not included when aggregating by all. */
            team_id?: string;
            /** @description Name of the team to which the incident was assigned. Not included when aggregating by all. */
            team_name?: string;
            /** @description Total number of unique interruptions during business hours; 8am-6pm Mon-Fri, based on the users time zone. */
            total_business_hour_interruptions?: number;
            /**
             * @description Total engaged time across all responders. Engaged time is measured from
             *     the time a user engages with an incident (by acknowledging or accepting a responder request)
             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
             */
            total_engaged_seconds?: number;
            /**
             * @description Total count of instances where an incident is escalated between responders
             *     assigned to an escalation policy.
             */
            total_escalation_count?: number;
            /** @description The total number of incidents that were created. */
            total_incident_count?: number;
            /**
             * @description The total count of assigned incidents acknowledged.
             *     Only explicit incident acknowledgment counts; reassign, resolve, and escalation actions do not imply acknowledgement.
             */
            total_incidents_acknowledged?: number;
            /**
             * @description The total count of incidents that were resolved automatically.
             *     This count includes incidents resolved via an integration and those that were [auto-resolved in PagerDuty](https://support.pagerduty.com/docs/configurable-service-settings#auto-resolution).
             */
            total_incidents_auto_resolved?: unknown;
            /** @description The total count of incidents that were manually escalated. */
            total_incidents_manual_escalated?: number;
            /** @description The total count of incidents that were reassigned. */
            total_incidents_reassigned?: number;
            /** @description The total count of incidents that were escalated due to timeouts. */
            total_incidents_timeout_escalated?: number;
            /** @description Total number of unique interruptions. */
            total_interruptions?: number;
            /** @description The total count of incident notifications sent via email, SMS, phone call and push. */
            total_notifications?: number;
            /** @description Total number of unique interruptions during off hours; 6pm-10pm Mon-Fri and all day Sat-Sun, based on the users time zone. */
            total_off_hour_interruptions?: number;
            /**
             * @description Total number of unique interruptions during sleep hours.
             *     Sleep hours: 10pm-8am every day, based on the users time zone.
             */
            total_sleep_hour_interruptions?: number;
            /** @description Total number of seconds incidents were snoozed. */
            total_snoozed_seconds?: number;
            /**
             * @description Total engaged time across all responders. Engaged time is measured from
             *     the time a user engages with an incident (by acknowledging or accepting a responder request)
             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
             *     This metric uses the edited incident response effort values that
             *     [users have defined](https://support.pagerduty.com/docs/edit-incidents#edit-incident-duration),
             *     if they exist.
             */
            total_user_defined_engaged_seconds?: number;
            /**
             * @description The percentage of time in the defined date range that the service was not interrupted
             *     by a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents).
             *     Only included when aggregating by team, escalation policy, service, or all services.
             */
            up_time_pct?: number;
        };
        /** Analytics Incident Metrics Escalation Policy */
        AnalyticsIncidentMetricsEscalationPolicy: {
            /** @description Distinct count of responders who engaged in incidents on the escalation policy */
            distinct_responder_count?: number;
            /** @description ID of the escalation policy the incident was last assigned to. Not included when aggregating by all. */
            escalation_policy_id?: string;
            /** @description Name of the escalation policy the incident was last assigned to. Not included when aggregating by all. */
            escalation_policy_name?: string;
            /** @description Mean count of instances where responders were assigned an incident (including through reassignment or escalation) or accepted a responder request. */
            mean_assignment_count?: number;
            /**
             * @description Mean engaged time across all responders.
             *     Engaged time is measured from the time a user engages with an incident (by
             *     acknowledging or accepting a responder request) until the incident is resolved.
             *     This may include periods in which the incidents were snoozed.
             */
            mean_engaged_seconds?: number;
            /**
             * @description Mean number of users who engaged with an incident. *Engaged* is defined as
             *     acknowledging an incident or accepting a responder request in it.
             */
            mean_engaged_user_count?: number;
            /**
             * @description A measure of *people response time*. This metric measures the time from
             *     the first user engagement (acknowledge or responder accept) to the last.
             *     This metric is only used for incidents with **multiple responders**;
             *     for incidents with one or no engaged users, this value is null.
             */
            mean_seconds_to_engage?: number;
            /** @description Mean time between the start of an incident, and the first responder to acknowledge. */
            mean_seconds_to_first_ack?: number;
            /**
             * @description Mean time between the start of an incident, and the last additional responder
             *     to acknowledge. For incidents with one or no engaged users, this value is null.
             */
            mean_seconds_to_mobilize?: number;
            /** @description Mean time from when an incident was triggered until it was resolved. */
            mean_seconds_to_resolve?: number;
            /**
             * @description Mean engaged time across all responders. Engaged time is measured from the time
             *     a user engages with an incident (by acknowledging or accepting a responder request)
             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
             *     This metric uses the incident response effort values that
             *     [users have defined](https://support.pagerduty.com/docs/edit-incidents#edit-incident-duration),
             *     if they exist.
             */
            mean_user_defined_engaged_seconds?: number;
            /** @description Start of the date range that the metrics were calculated for. Only included when an aggregate unit is specified in the request. */
            range_start?: string;
            /** @description ID of the team the incident was assigned to. Not included when aggregating by all. */
            team_id?: string;
            /** @description Name of the team the incident was assigned to. Not included when aggregating by all. */
            team_name?: string;
            /** @description Total number of unique interruptions during business hours; 8am-6pm Mon-Fri, based on the users time zone. */
            total_business_hour_interruptions?: number;
            /**
             * @description Total engaged time across all responders. Engaged time is measured from
             *     the time a user engages with an incident (by acknowledging or accepting a responder request)
             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
             */
            total_engaged_seconds?: number;
            /**
             * @description Total count of instances where an incident is escalated between responders
             *     assigned to an escalation policy.
             */
            total_escalation_count?: number;
            /** @description The total number of incidents that were created. */
            total_incident_count?: number;
            /**
             * @description The total count of assigned incidents acknowledged.
             *     Only explicit incident acknowledgment counts; reassign, resolve, and escalation actions do not imply acknowledgement.
             */
            total_incidents_acknowledged?: number;
            /**
             * @description The total count of incidents that were resolved automatically.
             *     This count includes incidents resolved via an integration and those that were [auto-resolved in PagerDuty](https://support.pagerduty.com/docs/configurable-service-settings#auto-resolution).
             */
            total_incidents_auto_resolved?: unknown;
            /** @description The total count of incidents that were manually escalated. */
            total_incidents_manual_escalated?: number;
            /** @description The total count of incidents that were reassigned. */
            total_incidents_reassigned?: number;
            /** @description The total count of incidents that were escalated due to timeouts. */
            total_incidents_timeout_escalated?: number;
            /** @description Total number of unique interruptions. */
            total_interruptions?: number;
            /** @description The total count of incident notifications sent via email, SMS, phone call and push. */
            total_notifications?: number;
            /** @description Total number of unique interruptions during off hours; 6pm-10pm Mon-Fri and all day Sat-Sun, based on the users time zone. */
            total_off_hour_interruptions?: number;
            /** @description Total number of unique interruptions during sleep hours; 10pm-8am every day, based on the users time zone. */
            total_sleep_hour_interruptions?: number;
            /** @description Total number of seconds incidents were snoozed. */
            total_snoozed_seconds?: number;
            /**
             * @description Total engaged time across all responders. Engaged time is measured from
             *     the time a user engages with an incident (by acknowledging or accepting a responder request)
             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
             *     This metric uses the edited incident response effort values that
             *     [users have defined](https://support.pagerduty.com/docs/edit-incidents#edit-incident-duration),
             *     if they exist.
             */
            total_user_defined_engaged_seconds?: number;
            /**
             * @description The percentage of time in the defined date range that the service was not interrupted
             *     by a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents). Not included when aggregating by all.
             */
            up_time_pct?: number;
        };
        AnalyticsPdAdvanceUsageFilter: {
            /** @description Accepts a set of filters to apply to the Incidents before aggregating.  Any incidents that do not match the included filters will be omitted from the results. */
            filters?: {
                /**
                 * @description Accepts an ISO8601 DateTime string. Any PD Advance usage with a created_at less than this value will be omitted from the results. The maximum supported time range in conjunction with created_at_end is one year.
                 * @example 2024-01-01T00:00:00+05:00
                 */
                created_at_start?: string;
                /**
                 * @description Accepts an ISO8601 DateTime string. Any PD Advance usage with a created_at greater than or equal to this value will be omitted from the results. The maximum supported time range in conjunction with created_at_start is one year.
                 * @example 2024-02-01T00:00:00Z
                 */
                created_at_end?: string;
                /**
                 * @description Accepts an ISO8601 DateTime string. Any incidents with a created_at less than this value will be omitted from the results. The maximum supported time range in conjunction with incident_created_at_end is one year.
                 * @example 2024-01-01T00:00:00+05:00
                 */
                incident_created_at_start?: string;
                /**
                 * @description Accepts an ISO8601 DateTime string. Any incidents with a created_at greater than or equal to this value will be omitted from the results. The maximum supported time range in conjunction with incident_created_at_start is one year.
                 * @example 2024-02-01T00:00:00Z
                 */
                incident_created_at_end?: string;
                /**
                 * @description Any incidents whose urgency does not match the provided string will be omitted from the results.
                 * @example high
                 * @enum {string}
                 */
                urgency?: "high" | "low";
                /**
                 * @description A boolean flag including whether results should contain *only* [major incidents](https://support.pagerduty.com/docs/operational-reviews#major-incidents), or exclude major incidents. If no value is provided all incidents will be included.
                 * @example true
                 */
                major?: boolean;
                /**
                 * @description An integer that sets the requirement for the minimum number of acknowledgements to occur on an incident. For example, setting this to 1 will return only incidents that have at least 1 acknowledgement. If no value is provided, all incidents will be included.
                 * @example 1
                 */
                min_ackowledgements?: number;
                /**
                 * @description An integer that sets the requirement for the minimum number of timeout escalations to occur on an incident. For example, setting this to 1 will return only incidents that have at least 1 timeout escalation. If no value is provided, all incidents will be included.
                 * @example 1
                 */
                min_timeout_escalations?: number;
                /**
                 * @description An integer that sets the requirement for the minimum number of manual escalations to occur on an incident. For example, setting this to 1 will return only incidents that have at least 1 manual escalation. If no value is provided, all incidents will be included.
                 * @example 1
                 */
                min_manual_escalations?: number;
                /**
                 * @description An array of team IDs. Only incidents related to these teams will be included in the results. If omitted, all teams the requestor has access to will be included in the results.
                 * @example [
                 *       "P373JQQ",
                 *       "PAECHJV",
                 *       "P7SYGW6"
                 *     ]
                 */
                team_ids?: string[];
                /**
                 * @description An array of service IDs. Only incidents related to these services will be included in the results. If omitted, all services the requestor has access to will be included in the results.
                 * @example [
                 *       "PSEJLIN",
                 *       "PSLWBL8",
                 *       "PT4KHLX"
                 *     ]
                 */
                service_ids?: string[];
                /**
                 * @description An array of escalation policy IDs. Only incidents related to these escalation policies will be included in the results. If omitted, all escalation policies the requestor has access to will be included in the results.
                 * @example [
                 *       "PDJXDF3",
                 *       "PG4EHNS"
                 *     ]
                 */
                escalation_policy_ids?: string[];
                /**
                 * @description An array of priority IDs. Only incidents with these priorities will be included in the results. If omitted, all priorities will be included in the results.
                 * @example [
                 *       "PC8O0L3",
                 *       "PX01HJD",
                 *       "P5FK83M"
                 *     ]
                 */
                priority_ids?: string[];
                /**
                 * @description An array of user-defined priority names. Only incidents with these priorities will be included in the results. If omitted, all priorities will be included in the results.
                 * @example [
                 *       "P1",
                 *       "P2",
                 *       "P3"
                 *     ]
                 */
                priority_names?: string[];
            };
            /**
             * @description The time zone to use for the results and grouping. Must be in tzdata format. See list of accepted values [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
             * @example Etc/UTC
             */
            time_zone?: string;
        };
        AnalyticsResponderFilter: {
            /** @description Accepts a set of filters to apply to the Incidents before aggregating.  Any incidents that do not match the included filters will be omitted from the results */
            filters?: {
                /**
                 * @description Accepts an ISO8601 DateTime string. Any incidents with a created_at less than this value will be omitted from the results. The maximum supported time range in conjunction with date_range_end is one year.
                 * @example 2023-10-01T00:00:00+05:00
                 */
                date_range_start?: string;
                /**
                 * @description Accepts an ISO8601 DateTime string. Any incidents with a created_at greater than or equal to this value will be omitted from the results. The maximum supported time range in conjunction with date_range_start is one year.
                 * @example 2023-10-01T00:00:00Z
                 */
                date_range_end?: string;
                /**
                 * @description Any incidents whose urgency does not match the provided string will be omitted from the results.
                 * @example high
                 * @enum {string}
                 */
                urgency?: "high" | "low";
                /**
                 * @description An array of team IDs. Only incidents related to these teams will be included in the results. If omitted, all teams the requestor has access to will be included in the results.
                 * @example [
                 *       "P373JQQ",
                 *       "PAECHJV",
                 *       "P7SYGW6"
                 *     ]
                 */
                team_ids?: string[];
                /**
                 * @description An array of responder IDs. Only incidents related to these responders will be included in the results. If omitted, all responders the requestor has access to will be included in the results.
                 * @example [
                 *       "PDJXDF3",
                 *       "PG4EHNS"
                 *     ]
                 */
                responder_ids?: string[];
                /**
                 * @description An array of priority IDs. Only incidents with these priorities will be included in the results. If omitted, all priorities will be included in the results.
                 * @example [
                 *       "PC8O0L3",
                 *       "PX01HJD",
                 *       "P5FK83M"
                 *     ]
                 */
                priority_ids?: string[];
                /**
                 * @description An array of user-defined priority names. Only incidents with these priorities will be included in the results. If omitted, all priorities will be included in the results.
                 * @example [
                 *       "P1",
                 *       "P2",
                 *       "P3"
                 *     ]
                 */
                priority_names?: string[];
            };
            /**
             * @description The time zone to use for the results and grouping.
             * @example Etc/UTC
             */
            time_zone?: string;
            /**
             * @description The order in which the results were sorted; asc for ascending, desc for descending.
             * @enum {string}
             */
            order?: "asc" | "desc";
            /**
             * @description The column that was used for ordering the results.
             * @example user_id
             */
            order_by?: string;
        };
        /** Analytics Responder Metrics */
        AnalyticsResponderMetrics: {
            /**
             * @description Mean engaged time across all responders for incidents that match the given filters.
             *     Engaged time is measured from the time a user engages with an incident (by
             *     acknowledging or accepting a responder request) until the incident is resolved.
             *     This may include periods in which the incidents were snoozed.
             */
            mean_engaged_seconds?: number;
            /**
             * @description The average time between when an incident is first assigned to a user and when the incident is first acknowledged by that user.
             *     Reassign, resolve, and escalation actions do not imply acknowledgement.
             */
            mean_time_to_acknowledge_seconds?: number;
            /** @description ID of the responder (user). Not included when aggregating by all responders. */
            responder_id?: number;
            /** @description Name of the responder (user). Not included when aggregating by all responders. */
            responder_name?: string;
            /** @description ID of the team associated with the responder. Not included when aggregating by all responders. */
            team_id?: string;
            /** @description Name of the team associated with the responder. Not included when aggregating by all responders. */
            team_name?: string;
            /** @description Total number of unique interruptions during business hours; 8am-6pm Mon-Fri, based on the users time zone. */
            total_business_hour_interruptions?: number;
            /**
             * @description Total engaged time across all responders for incidents. Engaged time is measured from
             *     the time a user engages with an incident (by acknowledging or accepting a responder request)
             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
             */
            total_engaged_seconds?: number;
            /** @description The total number of incidents that were created. */
            total_incident_count?: number;
            /**
             * @description The total count of assigned incidents acknowledged by the user.
             *     Only explicit incident acknowledgment counts; reassign, resolve, and escalation actions do not imply acknowledgement.
             */
            total_incidents_acknowledged?: number;
            /** @description The total count of the users assigned incidents that were manually escalated away from a user without acknowledgement. */
            total_incidents_manual_escalated_from?: number;
            /** @description The total count of incidents the user was manually escalated to. */
            total_incidents_manual_escalated_to?: number;
            /** @description The total count of a user's assigned incidents that were reassigned away from the user to another user or escalation policy. */
            total_incidents_reassigned_from?: number;
            /** @description The total count of incidents the user was reassigned to. */
            total_incidents_reassigned_to?: number;
            /** @description The total count of the users assigned incidents that were escalated due to timeouts. */
            total_incidents_timeout_escalated_from?: number;
            /** @description The total count of incidents the user was escalated to due to timeouts. */
            total_incidents_timeout_escalated_to?: number;
            /** @description Total number of unique interruptions. */
            total_interruptions?: number;
            /** @description The total count of incident notifications sent via email, SMS, phone call and push. */
            total_notifications?: number;
            /** @description Total number of unique interruptions during off hours; 6pm-10pm Mon-Fri and all day Sat-Sun, based on the users time zone. */
            total_off_hour_interruptions?: number;
            /** @description Total seconds the responder was on call. */
            total_seconds_on_call?: number;
            /** @description Total seconds the responder was on call at level 1 of their escalation policy. */
            total_seconds_on_call_level_1?: number;
            /** @description Total seconds the responder was on call at level 2 or higher of their escalation policy. */
            total_seconds_on_call_level_2_plus?: number;
            /** @description Total number of unique interruptions during sleep hours; 10pm-8am every day, based on the users time zone. */
            total_sleep_hour_interruptions?: number;
        };
        /** Analytics Raw Incident */
        AnalyticsRawIncident: {
            /** @description The IDs of the users who acknowledged the incident. */
            acknowledged_user_ids?: string[];
            /** @description The names of the users who acknowledged the incident. */
            acknowledged_user_names?: string[];
            /** @description Total count of acknowledgements in the incident. */
            acknowledgement_count?: number;
            /** @description Total number of responders who either acknowledged the incident or accepted a responder request. */
            active_user_count?: number;
            /** @description The IDs of the users who were assigned the incident. */
            assigned_user_ids?: string[];
            /** @description The names of the users who were assigned the incident. */
            assigned_user_names?: string[];
            /** @description Total count of instances where responders were assigned an incident (including through reassignment or escalation). */
            assignment_count?: number;
            /**
             * @description Whether or not the incident resolved automatically, either via an integration
             *     or [auto-resolved in PagerDuty](https://support.pagerduty.com/docs/configurable-service-settings#auto-resolution).
             */
            auto_resolved?: boolean;
            /** @description Total number of unique interruptions during business hours; 8am-6pm Mon-Fri, based on the users time zone. */
            business_hour_interruptions?: number;
            /** @description Timestamp of when the incident was created. */
            created_at?: string;
            /** @description Timestamp of when the incident was last updated by the analytics process.  Does not match the updated_at for an incident returned by the standard REST api incidents endpoint. */
            updated_at?: string;
            /** @description The incident description */
            description?: string;
            /** @description Total engaged time across all responders for this incident.  Engaged time is measured from the time a user engages with an incident (by acknowledging or accepting a responder request) until the incident is resolved.  This may include periods in which the incidents were snoozed. */
            engaged_seconds?: number;
            /** @description Total number of users who engaged (acknowledged, accepted responder request) in the incident. */
            engaged_user_count?: number;
            /** @description Total count of instances where an incident is escalated between responders assigned to an escalation policy. */
            escalation_count?: number;
            /** @description ID of the escalation policy the incident was assigned to. */
            escalation_policy_id?: string;
            /** @description Name of the escalation policy the incident was assigned to. */
            escalation_policy_name?: string;
            /** @description Incident ID */
            id?: string;
            /** @description The PagerDuty incident number. */
            incident_number?: number;
            /** @description ID of the Incident Type. */
            incident_type_id?: string;
            /** @description The name of the Incident Type. */
            incident_type_name?: string;
            /** @description The IDs of the users who either acknowledged the incident or accepted a responder request. */
            joined_user_ids?: string[];
            /** @description The names of the users who either acknowledged the incident or accepted a responder request. */
            joined_user_names?: string[];
            /** @description An incident is classified as a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents) if it has one of the two highest priorities, or if multiple responders are added and acknowledge the incident. */
            major?: boolean;
            /** @description Total count of manual escalations in the incident. */
            manual_escalation_count?: number;
            /** @description Total number of unique interruptions during off hours; 6pm-10pm Mon-Fri and all day Sat-Sun, based on the users time zone. */
            off_hour_interruptions?: number;
            /** @description ID of the incident's priority level. */
            priority_id?: string | null;
            /** @description The user-provided short name of the priority. */
            priority_name?: string | null;
            /** @description The numerical value used to sort priorities. Higher values are higher priority. */
            priority_order?: number | null;
            /** @description Total count of reassignments in the incident. */
            reassignment_count?: number;
            /** @description Timestamp of when the incident was resolved. */
            resolved_at?: string;
            /** @description ID of the user who resolved the incident. */
            resolved_by_user_id?: string;
            /** @description Name of the user who resolved the incident. */
            resolved_by_user_name?: string;
            /**
             * @description A measure of *people response time*. This metric measures the time from
             *     the first user engagement (acknowledge or responder accept) to the last.
             *     This metric is only used for incidents with **multiple responders**;
             *     for incidents with one or no engaged users, this value is null.
             */
            seconds_to_engage?: number;
            /** @description Time between the start of an incident, and the first responder to acknowledge. */
            seconds_to_first_ack?: number;
            /** @description Time between the start of an incident, and the last additional responder to acknowledge. If an incident has one or no responders, the value will be null. */
            seconds_to_mobilize?: number;
            /** @description Time from when an incident was triggered until it was resolved. */
            seconds_to_resolve?: number;
            /** @description ID of the service that the incident triggered on. */
            service_id?: string;
            /** @description Name of the service that the incident triggered on. */
            service_name?: string;
            /** @description Total number of unique interruptions during sleep hours; 10pm-8am every day, based on the users time zone. */
            sleep_hour_interruptions?: number;
            /** @description Total seconds the incident has been snoozed for. */
            snoozed_seconds?: number;
            /** @description The incident status. Can be one of `triggered`, `acknowledged`, or `resolved`. */
            status?: string;
            /** @description ID of the team the incident was assigned to. */
            team_id?: string | null;
            /** @description Name of the team the incident was assigned to. */
            team_name?: string | null;
            /** @description Total count of timeout escalations in the incident. */
            timeout_escalation_count?: number;
            /** @description Total number of unique interruptions in the incident. */
            total_interruptions?: number;
            /** @description Total number of notifications sent for the incident. */
            total_notifications?: number;
            /** @description Notification level */
            urgency?: string;
            /**
             * @description The total response effort in seconds,
             *     [as defined by the user](https://support.pagerduty.com/docs/editing-incidents#edit-incident-duration).
             */
            user_defined_effort_seconds?: number | null;
        };
        /** Analytics Raw Incident Responses */
        AnalyticsRawIncidentResponses: {
            /** @description Name of the user associated with the Incident Response. */
            responder_name?: string;
            /** @description ID of the user associated with the Incident Response. */
            responder_id?: string;
            /**
             * @description Status of the user's interaction with the Incident notification.
             * @enum {string}
             */
            response_status?: "joined" | "pending" | "declined";
            /**
             * @description Type of responder, where `assigned` means the user was added to the Incident via Assignment at Incident creation,
             *     `reassigned` means the user was added to the Incident via Reassignment, `escalated` means the user was added via Escalation,
             *     and `added_responder` means the user was added via Responder Reqeuest.
             * @enum {string}
             */
            responder_type?: "assigned" | "reassigned" | "escalated" | "added_responder";
            /** @description Timestamp of when the user was requested. */
            requested_at?: string;
            /** @description Timestamp of when the user responded to the request. */
            responded_at?: string;
            /** @description Measures the time it took for the user to respond to the Incident request. In other words, `responded_at - requested_at`. */
            time_to_respond_seconds?: number;
        };
        /** Analytics Raw Responder Incidents */
        AnalyticsRawResponderIncidents: {
            /** @description Timestamp of when the incident was created. */
            incident_created_at?: string;
            /** @description The incident description. */
            incident_description?: string;
            /** @description Incident ID */
            incident_id?: string;
            /** @description The PagerDuty incident number. */
            incident_number?: number;
            /** @description ID of the incident's priority level. */
            incident_priority_id?: string | null;
            /** @description The user-provided short name of the priority. */
            incident_priority_name?: string | null;
            /** @description The numerical value used to sort priorities. Higher values are higher priority. */
            incident_priority_order?: number | null;
            /** @description Notification level */
            incident_urgency?: string;
            /** @description Mean time from this user being assigned to an incident until this user acknowledges the incident. */
            mean_time_to_acknowledge_seconds?: number;
            /** @description ID of the responder. */
            responder_id?: string;
            /** @description Name of the responder. */
            responder_name?: string;
            /** @description ID of the service that the incident triggered on. */
            service_id?: string;
            /** @description Name of the service that the incident triggered on. */
            service_name?: string;
            /** @description ID of the team that owns the related service. */
            service_team_id?: string | null;
            /** @description Name of the team that owns the related service. */
            service_team_name?: string | null;
            /** @description Total acknowledgements from the responder on the incident. */
            total_acknowledgements?: number;
            /** @description Total number of unique interruptions during business hours; 8am-6pm Mon-Fri, based on the users time zone. */
            total_business_hour_interruptions?: number;
            /**
             * @description Total engaged time across all responders for incidents. Engaged time is measured from
             *     the time a user engages with an incident (by acknowledging or accepting a responder request)
             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
             */
            total_engaged_seconds?: number;
            /** @description Total number of unique interruptions for the responder during the incident. */
            total_interruptions?: number;
            /** @description Total times the responder was manually escalated away from the incident. */
            total_manual_escalations_from?: number;
            /** @description Total times the responder was manually escalated to the incident. */
            total_manual_escalations_to?: number;
            /** @description Total number of unique interruptions during off hours; 6pm-10pm Mon-Fri and all day Sat-Sun, based on the users time zone. */
            total_off_hour_interruptions?: string;
            /** @description Total times the responder was reassigned away from the incident. */
            total_reassignments_from?: number;
            /** @description Total times the responder was reassigned to the incident. */
            total_reassignments_to?: number;
            /** @description Total number of unique interruptions during sleep hours; 10pm-8am every day, based on the users time zone. */
            total_sleep_hour_interruptions?: number;
            /** @description Total times the responder was escalated away from the incident due to timeout. */
            total_timeout_escalations_from?: number;
            /** @description Total times the responder was escalated to the incident due to timeout. */
            total_timeout_escalations_to?: number;
        };
        /** Analytics Raw User */
        AnalyticsRawUser: {
            /** @description Obfuscated ID of the user. */
            id?: string;
            /** @description Name of the user. */
            user_name?: string;
            /** @description Email of the user. */
            email?: string;
            /** @description Account ID the user belongs to. */
            account_id?: number;
            /** @description User description, if available. */
            description?: string | null;
            /** @description User's configured time zone. */
            time_zone?: string | null;
            /** @description User's role in the account. */
            role?: string;
            /** @description ID of the team the user belongs to, if any. */
            team_id?: string | null;
            /** @description Name of the team the user belongs to, if any. */
            team_name?: string | null;
            /**
             * Format: date-time
             * @description Timestamp indicating when the user was created.
             */
            created_at?: string;
            /**
             * Format: date-time
             * @description Timestamp of the user's last sign-in, if available.
             */
            last_sign_in_at?: string | null;
            /** @description Number of notification channels configured for this user. */
            default_notification_channel_count?: number;
            /** @description Number of escalation policies this user is part of. */
            escalation_policies_count?: number;
            /** @description Number of schedules this user is part of. */
            schedules_count?: number;
            /** @description List of notification channel types configured for this user. */
            channel_types_configured?: string[];
            /** @description Number of teams this user belongs to. */
            team_count?: number;
            /** @description Whether the user has downloaded the mobile app. */
            downloaded_mobile_app?: boolean;
            /** @description Whether the user has notification methods configured. */
            notification_methods?: boolean;
            /** @description Whether the user is part of any escalation policy. */
            on_escalation_policy?: boolean;
            /** @description Whether the user is part of any schedule. */
            on_schedule?: boolean;
            /** @description Whether the user has signed up (based on last_sign_in_at not being null). */
            signed_up?: boolean;
        };
        /** Analytics User Filter */
        AnalyticsUserFilter: {
            filters?: components["schemas"]["AnalyticsUserFilterConditions"];
            /**
             * @description The time zone to use for the results and grouping. Must be in tzdata format. See list of accepted values [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
             * @example Etc/UTC
             */
            time_zone?: string;
            /**
             * @description The order in which the results were sorted; asc for ascending, desc for descending.
             * @default desc
             * @enum {string}
             */
            order: "asc" | "desc";
            /**
             * @description The column that was used for ordering the results.
             * @default user_id
             * @example user_id
             */
            order_by: string;
            /**
             * @description The time unit to aggregate metrics by. If no value is provided, the metrics will be aggregated for the entire period.
             * @example day
             * @enum {string|null}
             */
            aggregate_unit?: "day" | "week" | "month" | null;
            /**
             * @description The maximum number of results to return per page. The default (and maximum allowed value) is 1000.
             * @default 1000
             */
            limit: number;
            /** @description A cursor used for pagination. Starting after cursor provides the next set of results in forward pagination order. */
            starting_after?: string | null;
            /** @description A cursor used for pagination. Ending before cursor provides the previous set of results in reverse pagination order. */
            ending_before?: string | null;
        };
        /** Analytics User Filter Conditions */
        AnalyticsUserFilterConditions: {
            /**
             * Format: date-time
             * @description The start of the date range to search
             */
            created_at_start?: string;
            /**
             * Format: date-time
             * @description The end of the date range to search
             */
            created_at_end?: string;
            /** @description An array of team IDs. Only users belonging to these teams will be included in results. */
            team_ids?: string[];
            /** @description An array of user IDs. Only these users will be included in results. */
            user_ids?: string[];
            /** @description An array of role IDs. Only users with these roles will be included in results. */
            role_ids?: string[];
        };
        /** Analytics User Metrics */
        AnalyticsUserMetrics: {
            /** @description The number of users who have downloaded the mobile app. */
            total_downloaded_mobile_app_count?: number;
            /**
             * Format: float
             * @description The percentage of users who have downloaded the mobile app.
             */
            total_downloaded_mobile_app_percentage?: number;
            /** @description The number of users who are on at least one escalation policy. */
            total_on_escalation_policy_count?: number;
            /**
             * Format: float
             * @description The percentage of users who are on at least one escalation policy.
             */
            total_on_escalation_policy_percentage?: number;
            /** @description The number of users who have signed up (completed onboarding). */
            total_signed_up_count?: number;
            /**
             * Format: float
             * @description The percentage of users who have signed up.
             */
            total_signed_up_percentage?: number;
            /** @description The total number of users in the account that match the filters. */
            total_user_count?: number;
            /** @description The number of users who have at least one notification method configured. */
            total_with_notification_methods_count?: number;
            /**
             * Format: float
             * @description The percentage of users who have at least one notification method configured.
             */
            total_with_notification_methods_percentage?: number;
        };
        FieldValueChangeLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "field_value_change_log_entry";
        };
        CustomFieldValueChangeLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "custom_field_value_change_log_entry";
        };
        /** @description An Audit Trail record */
        AuditRecord: {
            id: string;
            /** @description Record URL. */
            self?: string | null;
            /**
             * Format: date-time
             * @description The date/time the action executed, in ISO8601 format and millisecond precision.
             */
            execution_time: string;
            /** @description Action execution context */
            execution_context?: {
                /** @description Request Id */
                request_id?: string | null;
                /** @description remote address */
                remote_address?: string | null;
            } | null;
            actors?: components["schemas"]["Reference"][] | null;
            /** @description The method information */
            method: {
                description?: string | null;
                /**
                 * @description Truncated token containing the last 4 chars of the token's actual value.
                 * @example 3xyz
                 */
                truncated_token?: string | null;
                type: components["parameters"]["audit_method_type"]["schema"];
            };
            root_resource: components["schemas"]["Reference"];
            /** @example create */
            action: string;
            /**
             * @description Additional details to provide further information about the action or
             *     the resource that has been audited.
             */
            details?: {
                resource: components["schemas"]["Reference"];
                /**
                 * @description A set of fields that have been affected.
                 *     The fields that have not been affected MAY be returned.
                 */
                fields?: {
                    /**
                     * @description Name of the resource field
                     * @example name
                     */
                    name: string;
                    /**
                     * @description Human readable description of the resource field
                     * @example First and Last name
                     */
                    description?: string | null;
                    /**
                     * @description new or updated value of the field
                     * @example Jonathan
                     */
                    value?: string | null;
                    /**
                     * @description previous or deleted value of the field
                     * @example John
                     */
                    before_value?: string | null;
                }[] | null;
                /** @description A set of references that have been affected. */
                references?: {
                    /**
                     * @description Name of the reference field
                     * @example team_members
                     */
                    name: string;
                    /**
                     * @description Human readable description of the references field
                     * @example First and Last name
                     */
                    description?: string | null;
                    added?: components["schemas"]["Reference"][] | null;
                    removed?: components["schemas"]["Reference"][] | null;
                }[] | null;
            } | null;
        };
        AuditRecordResponseSchema: {
            records: components["schemas"]["AuditRecord"][];
            response_metadata?: components["schemas"]["AuditMetadata"] | null;
        } & components["schemas"]["CursorPagination"];
        AuditMetadata: {
            messages?: string[] | null;
        };
        /**
         * AutoPauseNotificationsParameters
         * @description Defines how alerts on this service are automatically suspended for a period of time before triggering, when identified as likely being transient. Note that automatically pausing notifications is only available on certain plans.
         * @example {
         *       "enabled": true,
         *       "timeout": 300
         *     }
         */
        AutoPauseNotificationsParameters: {
            /**
             * @description Indicates whether alerts should be automatically suspended when identified as transient
             * @default false
             */
            enabled: boolean;
            /**
             * @description Indicates in seconds how long alerts should be suspended before triggering. To automatically select the recommended timeout for a service, set this value to `0`.
             * @enum {integer}
             */
            timeout?: 0 | 120 | 180 | 300 | 600 | 900;
            /**
             * @description The recommended timeout setting for this service based on prior alert patterns.
             * @enum {integer}
             */
            recommended_timeout?: 120 | 180 | 300 | 600 | 900;
        };
        /**
         * @description sidecar -- The runner is backed by an external sidecar that polls for invocations.
         *     runbook -- The runner communicates directly with a runbook instance.
         * @example runbook
         * @enum {string}
         */
        AutomationActionsRunnerTypeEnum: "sidecar" | "runbook";
        /**
         * @description The base URI of the Runbook server to connect to. May only contain alphanumeric characters, periods, underscores and dashes. Specified as the subdomain portion of an RBA host, as in <runbook_base_uri>.runbook.pagerduty.cloud
         * @example subdomain
         */
        AutomationActionsRunbookBaseURI: string;
        AutomationActionsRunner: components["schemas"]["Tag"] & {
            runner_type: components["schemas"]["AutomationActionsRunnerTypeEnum"];
            /** @example us-west-2 prod runner */
            name: string;
            /** @example us-west-2 runner provisioned in the production environment by the SRE team */
            description?: string;
            /** Format: date-time */
            last_seen?: string;
            status: components["schemas"]["AutomationActionsRunnerStatusEnum"];
            /** Format: date-time */
            creation_time: string;
            runbook_base_uri?: components["schemas"]["AutomationActionsRunbookBaseURI"];
            /** @description The list of teams associated with the Runner */
            readonly teams?: components["schemas"]["TeamReference"][];
            privileges?: components["schemas"]["AutomationActionsUserPermissions"];
            /** @description References to at most 3 actions associated with the Runner. Use appropriate endpoints to retrieve the full list of associated actions. */
            associated_actions?: {
                actions: (Omit<components["schemas"]["Reference"], 'type'> & {
                    /** @enum {string} */
                    type?: "action_reference";
                })[];
            } & {
                /** @description Indicates whether more actions exist for the Runner. */
                more: boolean;
            };
            /** @description Additional metadata */
            metadata?: Record<string, never>;
        };
        /** RunnerRunbookBody */
        AutomationActionsRunnerRunbookBody: {
            /** @example us-west-2 prod runner */
            name?: string;
            /** @example us-west-2 runner provisioned in the production environment by the SRE team */
            description?: string;
            runbook_base_uri?: components["schemas"]["AutomationActionsRunbookBaseURI"];
            /** @description The API key to connect to the Runbook server with. If omitted, the previously stored value will remain unchanged */
            runbook_api_key?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            runner_type: "AutomationActionsRunnerRunbookBody";
        };
        /** RunnerRunbookPostBody */
        AutomationActionsRunnerRunbookPostBody: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            runner_type: "AutomationActionsRunnerRunbookPostBody";
            /** @example us-west-2 prod runner */
            name: string;
            /** @example us-west-2 runner provisioned in the production environment by the SRE team */
            description: string;
            runbook_base_uri: components["schemas"]["AutomationActionsRunbookBaseURI"];
            /** @description The API key to connect to the Runbook server with. If omitted, the previously stored value will remain unchanged */
            runbook_api_key: string;
            /** @description The list of teams associated with the Runner */
            teams?: components["schemas"]["TeamReference"][];
        };
        /** RunnerSidecarBody */
        AutomationActionsRunnerSidecarBody: {
            /** @example us-west-2 prod runner */
            name?: string;
            /** @example us-west-2 runner provisioned in the production environment by the SRE team */
            description?: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            runner_type: "AutomationActionsRunnerSidecarBody";
        };
        /** RunnerSidecarPostBody */
        AutomationActionsRunnerSidecarPostBody: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            runner_type: "AutomationActionsRunnerSidecarPostBody";
            /** @example us-west-2 prod runner */
            name: string;
            /** @example us-west-2 runner provisioned in the production environment by the SRE team */
            description: string;
            /** @description The list of teams associated with the Runner */
            teams?: components["schemas"]["TeamReference"][];
        };
        /**
         * @description Configured -- Runner has connected to the backend at least once
         *     NotConfigured -- Runner has never connected to backend
         * @example Configured
         * @enum {string}
         */
        AutomationActionsRunnerStatusEnum: "Configured" | "NotConfigured";
        AutomationActionsUserPermissions: {
            /**
             * @example [
             *       "update",
             *       "delete"
             *     ]
             */
            permissions: ("create" | "update" | "delete" | "invoke")[];
        };
        AutomationActionsInvocation: components["schemas"]["Tag"] & {
            action_snapshot: {
                /** @example Restart apache */
                name: string;
                action_type: components["parameters"]["automation_actions_action_type"]["schema"];
            } & {
                action_data_reference?: components["schemas"]["AutomationActionsProcessAutomationJobActionDataReference"] | components["schemas"]["AutomationActionsScriptActionDataReference"];
            };
            runner_id: string;
            /** @description A list of state transitions with timestamps, sorted in ascending order by timestamp. Only the 'created' transition is guaranteed to exist at any time. */
            timing: {
                /**
                 * Format: date-time
                 * @description The date/time
                 */
                timestamp: string;
                state: components["parameters"]["automation_actions_invocation_state"]["schema"];
            }[];
            /**
             * @description The duration of the invocation's execution time.
             * @example 23
             */
            duration?: number;
            state: components["parameters"]["automation_actions_invocation_state"]["schema"];
            action_id: string;
            metadata: {
                agent: components["schemas"]["UserReference"] | components["schemas"]["AutomationActionsAbstractAction"]["allOf"]["1"]["last_run_by"]["oneOf"]["1"] | components["schemas"]["Template"]["allOf"]["1"]["created_by"]["oneOf"]["1"] | {
                    /** @example PT4KHRS */
                    id: string;
                    /** @example incident_workflow_reference */
                    type: string;
                };
                incident?: components["schemas"]["IncidentReference"];
            };
        };
        AutomationActionsAbstractAction: components["schemas"]["Tag"] & {
            /** @example Restart apache */
            name: string;
            /** @example Restarts apache on the us-west-2-shopping-cart host */
            description?: string;
            action_type: components["parameters"]["automation_actions_action_type"]["schema"];
            action_classification?: components["schemas"]["AutomationActionsActionClassificationEnum"];
            runner?: string;
            runner_type?: components["schemas"]["AutomationActionsRunnerTypeEnum"];
            services?: components["schemas"]["ServiceReference"][];
            privileges?: components["schemas"]["AutomationActionsUserPermissions"];
            metadata?: Record<string, never>;
            /**
             * Format: date-time
             * @description The date/time
             */
            creation_time: string;
            /**
             * Format: date-time
             * @description The date/time
             */
            modify_time: string;
            /**
             * Format: date-time
             * @description The date/time
             */
            last_run?: string;
            last_run_by?: components["schemas"]["UserReference"] | {
                /** @example /5471da24-eecd-42e2-ac38-a32b2d907406/service/P000000 */
                id: string;
                /** @example event_orchestration_reference */
                type: string;
            } | components["schemas"]["Template"]["allOf"]["1"]["created_by"]["oneOf"]["1"];
            /**
             * @description If true, the action can only be invoked against an unresolved incident.
             * @default false
             * @example false
             */
            only_invocable_on_unresolved_incidents: boolean;
            /**
             * @description If true, the action can only be invoked manually by a user.
             * @default true
             * @example true
             */
            allow_invocation_manually: boolean;
            /**
             * @description If true, the action can only be invoked automatically by an Event Orchestration.
             * @default true
             * @example true
             */
            allow_invocation_from_event_orchestration: boolean;
            /**
             * @description If true, the action will be associated with every service.
             * @default false
             * @example false
             */
            map_to_all_services: boolean;
        };
        AutomationActionsAbstractActionPostBody: {
            /** @example Restart apache */
            name: string;
            /** @example Restarts apache on the us-west-2-shopping-cart host */
            description: string;
            action_classification?: components["schemas"]["AutomationActionsActionClassificationEnum"];
            action_type: components["parameters"]["automation_actions_action_type"]["schema"];
            /** @example 1a6763bd-b1ad-458f-a347-6c8a9bea2d70 */
            runner?: string;
            services?: components["schemas"]["ServiceReference"][];
            teams?: components["schemas"]["TeamReference"][];
            /**
             * @description If true, the action can only be invoked against an unresolved incident.
             * @default false
             * @example false
             */
            only_invocable_on_unresolved_incidents: boolean;
            /**
             * @description If true, the action can only be invoked manually by a user.
             * @default true
             * @example true
             */
            allow_invocation_manually: boolean;
            /**
             * @description If true, the action can only be invoked automatically by an Event Orchestration.
             * @default true
             * @example true
             */
            allow_invocation_from_event_orchestration: boolean;
            /**
             * @description If true, the action will be associated with every service.
             * @default false
             * @example false
             */
            map_to_all_services: boolean;
        };
        AutomationActionsAbstractActionPutBody: {
            /** @example Restart apache */
            name?: string;
            /** @example Restarts apache on the us-west-2-shopping-cart host */
            description?: string;
            action_classification?: components["schemas"]["AutomationActionsActionClassificationEnum"];
            action_type?: components["parameters"]["automation_actions_action_type"]["schema"];
            runner?: string;
            /**
             * @description If true, the action can only be invoked against an unresolved incident.
             * @default false
             * @example false
             */
            only_invocable_on_unresolved_incidents: boolean;
            /**
             * @description If true, the action can only be invoked manually by a user.
             * @default true
             * @example true
             */
            allow_invocation_manually: boolean;
            /**
             * @description If true, the action can only be invoked automatically by an Event Orchestration.
             * @default true
             * @example true
             */
            allow_invocation_from_event_orchestration: boolean;
            /**
             * @description If true, the action will be associated with every service.
             * @default false
             * @example false
             */
            map_to_all_services: boolean;
        };
        /** @enum {string|null} */
        AutomationActionsActionClassificationEnum: "diagnostic" | "remediation" | null;
        AutomationActionsProcessAutomationJobAction: components["schemas"]["AutomationActionsAbstractAction"] & {
            action_data_reference: components["schemas"]["AutomationActionsProcessAutomationJobActionDataReference"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action_type: "process_automation";
        };
        AutomationActionsProcessAutomationJobActionDataReference: {
            /** @example 79c199bba1aff6e519f198457f5ec0fc */
            process_automation_job_id: string;
            /**
             * @description Arguments to pass to the Process Automation job. The maxLength value is specified in bytes.
             * @example -env production
             */
            process_automation_job_arguments?: string;
            /**
             * @description Node filter for the Process Automation job. The maxLength value is specified in bytes. Filter syntax: https://docs.rundeck.com/docs/manual/11-node-filters.html#node-filter-syntax
             * @example mynode1 !nodename: mynode2
             */
            process_automation_node_filter?: string;
        };
        AutomationActionsProcessAutomationJobActionPostBody: components["schemas"]["AutomationActionsAbstractActionPostBody"] & {
            action_data_reference: components["schemas"]["AutomationActionsProcessAutomationJobActionDataReference"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action_type: "process_automation";
        };
        AutomationActionsProcessAutomationJobActionPutBody: components["schemas"]["AutomationActionsAbstractActionPutBody"] & {
            action_data_reference?: components["schemas"]["AutomationActionsProcessAutomationJobActionDataReference"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action_type: "process_automation";
        };
        AutomationActionsProcessAutomationJobActionWithTeams: components["schemas"]["AutomationActionsProcessAutomationJobAction"] & {
            teams?: components["schemas"]["TeamReference"][];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action_type: "process_automation";
        };
        AutomationActionsScriptAction: components["schemas"]["AutomationActionsAbstractAction"] & {
            action_data_reference: components["schemas"]["AutomationActionsScriptActionDataReference"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action_type: "script";
        };
        AutomationActionsScriptActionDataReference: {
            /**
             * @description Body of the script to be executed on the Runner. To execute it, the Runner will write the content of the property into a temp file, make the file executable and execute it. It is assumed that the Runner has a properly configured environment to run the script as an executable file. This behaviour can be altered by providing the `invocation_command` property. The maxLength value is specified in bytes.
             * @example print("Hello from a Python script!")
             */
            script: string;
            /**
             * @description The command to executed a script with. With the body of the script written into a temp file, the Runner will execute the `<invocation_command> <temp_file>` command. The maxLength value is specified in bytes.
             * @example /usr/local/bin/python3
             */
            invocation_command?: string;
        };
        AutomationActionsScriptActionPostBody: components["schemas"]["AutomationActionsAbstractActionPostBody"] & {
            action_data_reference: components["schemas"]["AutomationActionsScriptActionDataReference"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action_type: "script";
        };
        AutomationActionsScriptActionPutBody: components["schemas"]["AutomationActionsAbstractActionPutBody"] & {
            action_data_reference?: components["schemas"]["AutomationActionsScriptActionDataReference"];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action_type: "script";
        };
        AutomationActionsScriptActionWithTeams: components["schemas"]["AutomationActionsScriptAction"] & {
            teams?: components["schemas"]["TeamReference"][];
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            action_type: "script";
        };
        /**
         * Content and Intelligent Grouping
         * @description The configuration for Content Based Intelligent Alert Grouping
         */
        ContentBasedIntelligentAlertGroupingConfiguration: {
            /**
             * @description Whether Alerts should be grouped if `all` or `any` specified fields match. If `all` is selected, an exact match on every specified field name must occur for Alerts to be grouped. If `any` is selected, Alerts will be grouped when there is an exact match on at least one of the specified fields.
             * @enum {string}
             */
            aggregate?: "all, any";
            /** @description An array of strings which represent the fields with which to group against. Depending on the aggregate, Alerts will group if some or all the fields match. */
            fields?: string[];
            /** @description The maximum amount of time allowed between Alerts. Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window up to 24 hours and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours (24 hours only applies to single-service settings). To use the "recommended_time_window," set the value to 0, otherwise the value must be between 300 <= time_window <= 3600. */
            time_window?: number;
            /** @description In order to ensure your Service has the optimal grouping window, we use data science to calculate your Service's average Alert inter-arrival time. We encourage customer's to use this value, please set `time_window` to 0 to use the `recommended_time_window`. */
            readonly recommended_time_window?: number;
        };
        ServiceEventRule: components["schemas"]["EventRule"]["allOf"]["0"] & {
            /** @description Position/index of the Event Rule on the Service.  Starting from position 0 (the first rule), rules are evaluated one-by-one until a matching Event Rule is found or the end of the list is reached. */
            position?: number;
            actions?: components["schemas"]["EventRuleActionsCommon"];
        };
        /** @description When an event matches this Event Rule, the actions that will be taken to change the resulting Alert and Incident. */
        EventRuleActionsCommon: {
            /** @description Set a note on the resulting incident. */
            annotate?: {
                /** @description The content of the note. */
                value: string;
            } | null;
            /** @description Set whether the resulting alert status is trigger or resolve. */
            event_action?: {
                /** @enum {string} */
                value: "trigger" | "resolve";
            } | null;
            /** @description Dynamically extract values to set and modify new and existing PD-CEF fields. */
            extractions?: ({
                /** @description The PD-CEF field that will be set with the value from the regex. */
                target: string;
                /** @description The path to the event field where the regex will be applied to extract a value. */
                source: string;
                /** @description A RE2 regular expression.  If it contains one or more capture groups, their values will be extracted and appended together.  If it contains no capture groups, the whole match is used. */
                regex: string;
            } | {
                /** @description The PD-CEF field that will be set with the value from the regex. */
                target: string;
                /**
                 * @description A value that will be used to populate the target PD-CEF field.  You can include variables extracted from the payload by using string interpolation.
                 * @example Error number {{count}} on host {{host}}
                 */
                template: string;
            })[];
            /** @description Set the priority ID for the resulting incident. You can find the priority you want by calling the priorities endpoint. */
            priority?: {
                /** @description The priority ID. */
                value: string;
            } | null;
            /** @description Set the severity of the resulting alert. */
            severity?: {
                /** @enum {string} */
                value: "info" | "warning" | "error" | "critical";
            } | null;
            /** @description Set whether the resulting alert is suppressed. Can optionally be used with a threshold where resulting alerts will be suppressed until the threshold is met in a window of time. If using a threshold the rule must also set a route action. */
            suppress?: {
                value: boolean;
                /** @description The number of occurences needed during the window of time to trigger the theshold. */
                threshold_value?: number;
                /**
                 * @description The time unit for the window of time.
                 * @enum {string}
                 */
                threshold_time_unit?: "seconds" | "minutes" | "hours";
                /** @description The amount of time units for the window of time. */
                threshold_time_amount?: number;
            };
            /** @description Set the length of time to suspend the resulting alert before triggering. Rules with a suspend action must also set a route action, and cannot have a suppress with threshold action */
            suspend?: {
                /** @description The amount of time to suspend the alert in seconds. */
                value: number;
            } | null;
        };
        EventRule: {
            /** @description ID of the Event Rule. */
            readonly id?: string;
            /**
             * Format: url
             * @description the API show URL at which the object is accessible.
             */
            readonly self?: string;
            /** @description Indicates whether the Event Rule is disabled and would therefore not be evaluated. */
            disabled?: boolean;
            /** @description Conditions evaluated to check if an event matches this Event Rule. Is always empty for the catch_all rule, though. */
            conditions?: {
                /**
                 * @description Operator to combine sub-conditions.
                 * @enum {string}
                 */
                operator: "and" | "or";
                /** @description Array of sub-conditions. */
                subconditions: {
                    /**
                     * @description The type of operator to apply.
                     * @enum {string}
                     */
                    operator: "exists" | "nexists" | "equals" | "nequals" | "contains" | "ncontains" | "matches" | "nmatches";
                    parameters: {
                        /** @description Path to a field in an event, in dot-notation.  For Event Rules on a serivce, this will have to be a PD-CEF field. */
                        path: string;
                        /** @description Value to apply to the operator. */
                        value: string;
                        /** @description Options to configure the operator. */
                        options?: Record<string, never>;
                    };
                }[];
            };
            /** @description Time-based conditions for limiting when the rule is active. */
            time_frame?: {
                /** @description A fixed window of time during which the rule is active. */
                active_between?: {
                    /** @description The start time in milliseconds. */
                    start_time: number;
                    /** @description End time in milliseconds. */
                    end_time: number;
                };
                /** @description A reccuring window of time based on the day of the week, during which the rule is active. */
                scheduled_weekly?: {
                    /** @description The amount of milliseconds into the day at which the window starts. */
                    start_time: number;
                    /** @description The duration of the window in milliseconds. */
                    duration: number;
                    /** @description The timezone. */
                    timezone: string;
                    /** @description An array of day values. Ex [1, 3, 5] is Monday, Wednesday, Friday. */
                    weekdays: number[];
                };
            };
            /** @description [Early Access] Populate variables from event payloads and use those variables in other event actions. */
            variables?: {
                /**
                 * @description The type of operation to populate the variable.
                 * @enum {string}
                 */
                type: "regex";
                /** @description The name of the variable. */
                name: string;
                /** @description The parameters for performing the operation to populate the */
                parameters: {
                    /** @description The value for the operation. For example, an RE2 regular expression for regex-type variables. */
                    value: string;
                    /** @description Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a PD-CEF field. */
                    path: string;
                };
            }[];
        } & {
            /** @description Position/index of the Event Rule in the Ruleset.  Starting from position 0 (the first rule), rules are evaluated one-by-one until a matching rule is found. */
            position?: number;
            /** @description Indicates whether the Event Rule is the last Event Rule of the Ruleset that serves as a catch-all. It has limited functionality compared to other rules and always matches. */
            readonly catch_all?: boolean;
            /** @description When an event matches this rule, the actions that will be taken to change the resulting alert and incident. */
            actions?: components["schemas"]["EventRuleActionsCommon"] & {
                /** @description Set the service ID of the target service for the resulting alert. You can find the service you want to route to by calling the services endpoint. */
                route?: {
                    /** @description The target service's ID. */
                    value: string;
                } | null;
            };
        };
        /**
         * Intelligent Alert Grouping
         * @description The configuration for Intelligent Alert Grouping. Note that this configuration is only available for certain plans.
         */
        FlexibleTimeWindowIntelligentAlertGroupingConfig: {
            /** @description The maximum amount of time allowed between Alerts. Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the "recommended_time_window," set the value to 0, otherwise the value must be between 300 and 3600. */
            time_window?: number;
            /** @description In order to ensure your Service has the optimal grouping window, we use data science to calculate your Service`s average Alert inter-arrival time. We encourage customer`s to use this value, please set `time_window` to 0 to use the `recommended_time_window`. */
            readonly recommended_time_window?: number;
        };
        /**
         * @example {
         *       "id": "0e84de00-9511-4380-9f4f-a7b568bb49a0",
         *       "name": "MySQL Clusters",
         *       "type": "global",
         *       "routing_keys": [
         *         "R0212P1QXGEIQE2NMTQ7L7WXD00DWHIN"
         *       ],
         *       "self": "https://api.pagerduty.com/rulesets/0e84de00-9511-4380-9f4f-a7b568bb49a0",
         *       "created_at": "2019-12-24T21:18:52Z",
         *       "creator": {
         *         "type": "user_reference",
         *         "self": "https://api.pagerduty.com/users/PABO808",
         *         "id": "PABO808"
         *       },
         *       "updated_at": "2019-12-25T14:54:23Z",
         *       "updater": {
         *         "type": "user_reference",
         *         "self": "https://api.pagerduty.com/users/PABO808",
         *         "id": "PABO808"
         *       },
         *       "team": {
         *         "type": "team_reference",
         *         "self": "https://api.pagerduty.com/teams/P3ZQXDF",
         *         "id": "P3ZQXDF"
         *       }
         *     }
         */
        Ruleset: {
            /** @description ID of the Ruleset. */
            readonly id?: string;
            /**
             * Format: url
             * @description the API show URL at which the object is accessible
             */
            readonly self?: string;
            /** @enum {string} */
            readonly type?: "global" | "default_global";
            /** @description Name of the Ruleset. */
            name?: string;
            /** @description Routing keys routed to this Ruleset. */
            readonly routing_keys?: string[];
            /**
             * Format: date-time
             * @description The date the Ruleset was created at.
             */
            readonly created_at?: string;
            /** @description Reference to the user that has created the Ruleset. */
            readonly creator?: {
                readonly id?: string;
                /** @description A string that determines the schema of the object */
                readonly type?: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible
                 */
                readonly self?: string;
            };
            /**
             * Format: date-time
             * @description The date the Ruleset was last updated.
             */
            readonly updated_at?: string;
            /** @description Reference to the user that has updated the Ruleset last. */
            readonly updater?: {
                readonly id?: string;
                /** @description A string that determines the schema of the object */
                readonly type?: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible
                 */
                readonly self?: string;
            };
            /** @description Reference to the team that owns the Ruleset. If none is specified, only admins have access. */
            team?: {
                id: string;
                /** @description A string that determines the schema of the object */
                readonly type: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible
                 */
                readonly self?: string;
            };
        };
        AcknowledgeLogEntry: components["schemas"]["LogEntry"] & {
            /** @description Duration for which the acknowledgement lasts, in seconds. Services can contain an `acknowledgement_timeout` property, which specifies the length of time acknowledgements should last for. Each time an incident is acknowledged, this timeout is copied into the acknowledgement log entry. This property is optional, as older log entries may not contain it. It may also be `null`, as acknowledgements can be performed on incidents whose services have no `acknowledgement_timeout` set. */
            acknowledgement_timeout?: number;
            /** @enum {string} */
            type?: "acknowledgement_log_entry";
        };
        AnnotateLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "annotate_log_entry";
        };
        AssignLogEntry: components["schemas"]["LogEntry"] & {
            /** @description An array of assigned Users for this log entry */
            readonly assignees?: components["schemas"]["UserReference"][];
            /** @enum {string} */
            type?: "assign_log_entry";
        };
        DelegateLogEntry: components["schemas"]["LogEntry"] & {
            /** @description An array of assigned Users for this log entry */
            readonly assignees?: components["schemas"]["UserReference"][];
            /** @enum {string} */
            type?: "delegate_log_entry";
        };
        EscalateLogEntry: components["schemas"]["LogEntry"] & {
            /** @description An array of assigned Users for this log entry */
            readonly assignees?: components["schemas"]["UserReference"][];
            /** @enum {string} */
            type?: "escalate_log_entry";
        };
        ExhaustEscalationPathLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "exhaust_escalation_path_log_entry";
        };
        LogEntryReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "acknowledge_log_entry_reference" | "annotate_log_entry_reference" | "assign_log_entry_reference" | "escalate_log_entry_reference" | "exhaust_escalation_path_log_entry_reference" | "notify_log_entry_reference" | "reach_trigger_limit_log_entry_reference" | "repeat_escalation_path_log_entry_reference" | "resolve_log_entry_reference" | "snooze_log_entry_reference" | "trigger_log_entry_reference" | "unacknowledge_log_entry_reference";
        };
        LogEntry: components["schemas"]["Tag"] & {
            /** @enum {string} */
            type?: "acknowledge_log_entry" | "annotate_log_entry" | "assign_log_entry" | "delegate_log_entry" | "escalate_log_entry" | "exhaust_escalation_path_log_entry" | "notify_log_entry" | "reach_ack_limit_log_entry" | "reach_trigger_limit_log_entry" | "repeat_escalation_path_log_entry" | "resolve_log_entry" | "snooze_log_entry" | "trigger_log_entry" | "unacknowledge_log_entry" | "urgency_change_log_entry" | "field_value_change_log_entry" | "custom_field_value_change_log_entry";
            /**
             * Format: date-time
             * @description Time at which the log entry was created.
             */
            readonly created_at?: string;
            channel?: components["schemas"]["Channel"];
            agent?: components["schemas"]["AgentReference"];
            /** @description Optional field containing a note, if one was included with the log entry. */
            readonly note?: string;
            /** @description Contexts to be included with the trigger such as links to graphs or images. */
            readonly contexts?: components["schemas"]["Context"][];
            service?: components["schemas"]["ServiceReference"];
            incident?: components["schemas"]["IncidentReference"];
            /** @description Will consist of references unless included */
            readonly teams?: components["schemas"]["TeamReference"][];
            readonly event_details?: {
                /** @description Additional details about the event. */
                description?: string;
            };
            /**
             * @description String record of custom field updates
             * @example [
             *       "Updated serial_number to 123",
             *       "Updated affected_room to [\"Queen West\"]"
             *     ]
             */
            changeset?: string[];
        };
        NotifyLogEntry: components["schemas"]["LogEntry"] & {
            /**
             * Format: date-time
             * @description Time at which the log entry was created
             */
            readonly created_at?: string;
            user?: components["schemas"]["UserReference"];
            /** @enum {string} */
            type?: "notify_log_entry";
        };
        ReachAckLimitLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "reach_ack_limit_log_entry";
        };
        ReachTriggerLimitLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "reach_trigger_limit_log_entry";
        };
        RepeatEscalationPathLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "repeat_escalation_path_log_entry";
        };
        ResolveLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "resolve_log_entry";
        };
        SnoozeLogEntry: components["schemas"]["LogEntry"] & {
            changed_actions?: components["schemas"]["IncidentAction"][];
            /** @enum {string} */
            type?: "snooze_log_entry";
        };
        TriggerLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "trigger_log_entry";
        };
        UnacknowledgeLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "unacknowledge_log_entry";
        };
        UrgencyChangeLogEntry: components["schemas"]["LogEntry"] & {
            /** @enum {string} */
            type?: "urgency_change_log_entry";
        };
        AddonReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /**
             * Format: url
             * @description The URL source of the Addon
             */
            src?: string;
            /** @description The user entered name of the Addon. */
            name?: string;
            /** @enum {string} */
            type?: "full_page_addon_reference" | "incident_show_addon_reference";
        };
        Addon: components["schemas"]["Tag"] & {
            /**
             * @description The type of Add-on.
             * @enum {string}
             */
            type: "full_page_addon" | "incident_show_addon";
            /** @description The name of the Add-on. */
            name: string;
            /**
             * Format: url
             * @description The source URL to display in a frame in the PagerDuty UI. HTTPS is required.
             */
            src: string;
        };
        BusinessService: components["schemas"]["Tag"] & {
            /** @description The name of the business service. */
            name?: string;
            /** @description The user-provided description of the business service. */
            description?: string;
            /** @description The point of contact assigned to this service. */
            point_of_contact?: string;
            /**
             * Team
             * @description Reference to the team that owns the business service.
             */
            team?: {
                id: string;
                /** @description A string that determines the schema of the object. */
                readonly type?: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible.
                 */
                readonly self?: string;
            } | null;
        };
        BusinessServiceReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "business_service_reference";
        };
        ChangeEvent: components["schemas"]["Tag"] & {
            /**
             * Format: date-time
             * @description The time at which the emitting tool detected or generated the event.
             */
            readonly timestamp?: string;
            /**
             * @description The type of object being created.
             * @default change_event
             * @enum {string}
             */
            readonly type: "change_event";
            /** @description An array containing Service objects that this change event is associated with. */
            readonly services?: components["schemas"]["ServiceReference"][];
            integration?: unknown & components["schemas"]["IntegrationReference"];
            /**
             * Routing Key
             * @description This is the 32 character Integration Key for an Integration on a Service. The same Integration Key can be used for both alert and change events.
             */
            readonly routing_key?: string;
            /** @description A brief text summary of the event. Displayed in PagerDuty to provide information about the change. The maximum permitted length of this property is 1024 characters. */
            summary?: string;
            /** @description The unique name of the location where the Change Event occurred. */
            readonly source?: string;
            /** @description List of links to include. */
            readonly links?: {
                href?: string;
                text?: string;
            }[];
            readonly images?: {
                src?: string;
                href?: string;
                alt?: string;
            }[];
            /**
             * Custom Details
             * @description Additional details about the change event.
             */
            custom_details?: Record<string, never>;
        };
        Tag: {
            readonly id?: string;
            /** @description A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier. */
            readonly summary?: string | null;
            /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
            readonly type?: string;
            /**
             * Format: url
             * @description the API show URL at which the object is accessible
             */
            readonly self?: string | null;
            /**
             * Format: url
             * @description a URL at which the entity is uniquely displayed in the Web app
             */
            readonly html_url?: string | null;
        } & {
            /**
             * @description The type of object being created.
             * @default tag
             * @enum {string}
             */
            type: "tag";
            /** @description The label of the tag. */
            label: string;
        };
        TagReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "tag_reference";
        };
        EntityReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "user_reference" | "team_reference" | "escalation_policy_reference";
        };
        /**
         * @example {
         *       "type": "incident_show_addon",
         *       "name": "Service Runbook",
         *       "src": "https://intranet.example.com/runbook.html",
         *       "services": [
         *         {
         *           "id": "PIJ90N7",
         *           "type": "service",
         *           "summary": "My Application Service",
         *           "self": "https://api.pagerduty.com/services/PIJ90N7",
         *           "html_url": "https://subdomain.pagerduty.com/service-directory/PIJ90N7"
         *         }
         *       ]
         *     }
         */
        IncidentAddon: components["schemas"]["Addon"] & {
            /**
             * @description The services this Add-on is associated with.
             *     If non-empty, the Add-on will appear only on incidents for those services.
             *     If empty, it will appear on incidents for all services.
             */
            services?: components["schemas"]["ServiceReference"][];
        };
        IncidentUrgencyType: {
            /**
             * @description The type of incident urgency: whether it's constant, or it's dependent on the support hours.
             * @default constant
             * @enum {string}
             */
            type: "constant" | "use_support_hours";
            /**
             * @description The incidents' urgency, if type is constant.
             * @default high
             * @enum {string}
             */
            urgency: "low" | "high" | "severity_based";
        };
        IncidentUrgencyRule: components["schemas"]["IncidentUrgencyType"] & {
            during_support_hours?: components["schemas"]["IncidentUrgencyType"];
            outside_support_hours?: components["schemas"]["IncidentUrgencyType"];
        };
        LicenseWithCounts: {
            /** @description Uniquely identifies the resource */
            id: string;
            /**
             * @description Description of the License. May include the names of add-ons associated with
             *     the License, if there are any.
             */
            description: string;
            /** @description Name of the License. */
            name: string;
            /** @description The roles a User with this License can have */
            valid_roles: string[];
            /**
             * @description Indicates whether this License is assignable to full or stakeholder Users
             * @example FullUser
             * @enum {string}
             */
            role_group?: "FullUser" | "Stakeholder";
            /** @description Type of object */
            type?: string;
            /** @description API URL to access the License */
            self?: string;
            /** @description HTML URL to access the License */
            html_url?: string;
            /** @description Summary of the License */
            summary?: string;
        } & {
            /** @description How many of these Licenses are currently allocated to Users */
            current_value?: number;
            /**
             * @description How many of these licenses are available to be allocated to a user. If this
             *     value is "null" then there is no limit on the number of allocations allowed.
             */
            allocations_available?: number | null;
        };
        LicenseReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "license_reference";
        };
        SupportHours: {
            /**
             * @description The type of support hours
             * @default fixed_time_per_day
             * @enum {string}
             */
            type: "fixed_time_per_day";
            /**
             * Format: activesupport-time-zone
             * @description The time zone for the support hours
             */
            time_zone?: string;
            readonly days_of_week?: number[];
            /**
             * Format: time
             * @description The support hours' starting time of day (date portion is ignored)
             */
            start_time?: string;
            /**
             * Format: time
             * @description The support hours' ending time of day (date portion is ignored)
             */
            end_time?: string;
        };
        Reference: components["schemas"]["Tag"];
        /**
         * @example {
         *       "content": "Firefighters are on the scene."
         *     }
         */
        IncidentNote: {
            readonly id?: string;
            user?: Omit<components["schemas"]["Reference"], 'type'> & {
                /** @enum {string} */
                type?: "user_reference" | "bot_user_reference";
            };
            /** @description The means by which this Note was created. Has different formats depending on type. */
            readonly channel?: {
                /** @description A string describing the source of the Note. */
                readonly summary: string;
                readonly id?: string;
                /** @description A string that determines the schema of the object */
                readonly type?: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible
                 */
                readonly self?: string;
                /**
                 * Format: url
                 * @description a URL at which the entity is uniquely displayed in the Web app
                 */
                readonly html_url?: string;
            };
            /** @description The note content */
            content: string;
            /**
             * Format: date-time
             * @description The time at which the note was submitted
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The time at which the note was last updated
             */
            readonly updated_at?: string;
        };
        Notification: {
            readonly id?: string;
            /**
             * @description The type of notification.
             * @enum {string}
             */
            readonly type?: "sms_notification" | "email_notification" | "phone_notification" | "push_notification";
            /**
             * Format: date-time
             * @description The time at which the notification was sent
             */
            readonly started_at?: string;
            /** @description The address where the notification was sent. This will be null for notification type `push_notification`. */
            readonly address?: string;
            user?: components["schemas"]["UserReference"];
            /** @description The address of the conference bridge */
            conferenceAddress?: string;
            status?: string;
            ""?: string;
        };
        Context: {
            /**
             * @description The type of context being attached to the incident.
             * @enum {string}
             */
            type: "link" | "image";
            /** @description The link's target url */
            href?: string;
            /** @description The image's source url */
            src?: string;
            /** @description The alternate display for an image */
            text?: string;
        };
        /** @description Polymorphic object representation of the means by which the action was channeled. Has different formats depending on type, indicated by channel[type]. Will be one of `auto`, `email`, `api`, `nagios`, or `timeout` if `agent[type]` is `service`. Will be one of `email`, `sms`, `website`, `web_trigger`, or `note` if `agent[type]` is `user`. */
        Channel: {
            /** @description type */
            type: string;
            user?: Record<string, never>;
            team?: Record<string, never>;
            notification?: components["schemas"]["Notification"];
            /** @description channel */
            channel?: Record<string, never>;
            /** @description Changeset present in CustomFieldsValueChange and FieldValueChange log entries. */
            changeset?: {
                /** @description Customer Fields present in CustomFieldsValueChange and FieldValueChange log entries. */
                customer_fields?: {
                    /** @example PDB5RLI */
                    id?: string;
                    /** @example serial_number_hardware */
                    name?: string;
                    value?: number | string[];
                    /** @example incidents */
                    namespace?: string;
                    /** @example null */
                    old_value?: string | null;
                }[];
                /** @description Application Fields present in CustomFieldsValueChange and FieldValueChange log entries. */
                application_fields?: {
                    /** @example PIJ90N7 */
                    id?: string;
                    /** @example service */
                    name?: string;
                    value?: string | number | string[];
                    /** @example incidents */
                    namespace?: string;
                    /** @example null */
                    old_value?: string | null;
                }[];
                /** @description Custom attributes for the changeset. */
                custom_attributes?: {
                    [key: string]: string;
                };
                customer_schema?: {
                    /** @example null */
                    old_value?: string | null;
                };
            };
        } & ({
            /** @description Will be `nagios` */
            type?: string;
            /** @description Same as `host` */
            summary?: string;
            /** @description Nagios host */
            host?: string;
            /** @description Nagios service that created the event, if applicable */
            service?: string;
            /** @description State that caused the event */
            state?: string;
            /** @description Additional details of the incident */
            details?: Record<string, never>;
        } | {
            /** @description Will be `api` */
            type?: string;
            /** @description Same as `description` */
            summary?: string;
            /** @description API service key */
            service_key?: string;
            /** @description Description of the event */
            description?: string;
            /** @description Incident deduping string */
            incident_key?: string;
            /** @description Additional details of the incident */
            details?: Record<string, never>;
        } | {
            /** @description Will be `email` */
            type?: string;
            /** @description Same as `subject` */
            summary?: string;
            /** @description To address of the email */
            to?: string;
            /** @description From address of the email */
            from?: string;
            /** @description Subject of the email */
            subject?: string;
            /** @description Body of the email */
            body?: string;
            /** @description Content type of the email body. Will be `text/plain` or `text/html` */
            body_content_type?: string;
            /** @description URL for raw text of email */
            raw_url?: string;
            /** @description URL for html rendered version of the email. Only present if `content_type` is `text/html` */
            html_url?: string;
        } | {
            /** @description Will be `web_trigger` */
            type?: string;
            /** @description Same as `subject` */
            summary?: string;
            /** @description Subject of the web trigger */
            subject?: string;
            /** @description Details about the web trigger */
            details?: string;
        } | {
            /** @description Will be `website` */
            type: string;
            /** @description For `snooze` log entries, this is the number of seconds that the incident was snoozed for. */
            duration?: number;
        });
        ScheduledAction: {
            /**
             * @description The type of schedule action. Must be set to urgency_change.
             * @enum {string}
             */
            type: "urgency_change";
            /** @description Represents when scheduled action will occur. */
            at: {
                /**
                 * @description Must be set to named_time.
                 * @enum {string}
                 */
                type: "named_time";
                /**
                 * @description Designates either the start or the end of support hours.
                 * @enum {string}
                 */
                name: "support_hours_start" | "support_hours_end";
            };
            /**
             * @description Urgency level. Must be set to high.
             * @enum {string}
             */
            to_urgency: "high";
        };
        /** @description An incident action is a pending change to an incident that will automatically happen at some future time. */
        IncidentAction: {
            /** @enum {string} */
            type: "unacknowledge" | "escalate" | "resolve" | "urgency_change";
            /** Format: date-time */
            at: string;
            /**
             * @description The urgency that the incident will change to. This field is only present when the type is `urgency_change`.
             * @enum {string}
             */
            to?: "high";
        };
        AgentReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "user_reference" | "service_reference" | "integration_reference";
        };
        NotificationRuleReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "assignment_notification_rule_reference";
        };
        NotificationRule: components["schemas"]["Tag"] & {
            /**
             * @description The type of object being created.
             * @default assignment_notification_rule
             * @enum {string}
             */
            type: "assignment_notification_rule";
            /** @description The delay before firing the rule, in minutes. */
            start_delay_in_minutes: number;
            contact_method: components["schemas"]["ContactMethodReference"];
            /**
             * @description Which incident urgency this rule is used for. Account must have the `urgencies` ability to have a low urgency notification rule.
             * @enum {string}
             */
            urgency: "high" | "low";
        };
        ContactMethodReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "email_contact_method_reference" | "phone_contact_method_reference" | "push_notification_contact_method_reference" | "sms_contact_method_reference";
        };
        ContactMethod: components["schemas"]["Tag"] & Omit<{
            /**
             * @description The type of contact method being created.
             * @enum {string}
             */
            type: "email_contact_method" | "phone_contact_method" | "push_notification_contact_method" | "sms_contact_method";
            /** @description The label (e.g., "Work", "Mobile", etc.). */
            label: string;
            /** @description The "address" to deliver to: email, phone number, etc., depending on the type. */
            address: string;
        }, "type">;
        /** @description The Email Contact Method of the User. */
        EmailContactMethod: components["schemas"]["ContactMethod"] & {
            /** @enum {string} */
            type?: "email_contact_method";
            /**
             * @description Send an abbreviated email message instead of the standard email output. Useful for email-to-SMS gateways and email based pagers.
             * @default false
             */
            send_short_email: boolean;
        };
        /** @description The Phone Contact Method of the User, used for Voice or SMS. */
        PhoneContactMethod: components["schemas"]["ContactMethod"] & {
            /** @enum {string} */
            type?: "phone_contact_method" | "sms_contact_method";
            /** @description The 1-to-3 digit country calling code. */
            country_code: number;
            /** @description If true, this phone is capable of receiving SMS messages. */
            readonly enabled?: boolean;
            /** @description If true, this phone has been blacklisted by PagerDuty and no messages will be sent to it. */
            readonly blacklisted?: boolean;
        };
        PushContactMethodSound: {
            /**
             * @description The type of sound.
             * @enum {string}
             */
            type?: "alert_high_urgency" | "alert_low_urgency";
            /** @description The sound file name. */
            file?: string;
        };
        /** @description The Push Contact Method of the User. */
        PushContactMethod: components["schemas"]["ContactMethod"] & {
            /** @enum {string} */
            type?: "push_notification_contact_method";
            /**
             * @description The type of device.
             * @enum {string}
             */
            readonly device_type: "android" | "ios";
            sounds?: components["schemas"]["PushContactMethodSound"][];
            /**
             * Format: date-time
             * @description Time at which the contact method was created.
             */
            created_at?: string;
            /** @description If true, this phone has been blacklisted by PagerDuty and no messages will be sent to it. */
            readonly blacklisted?: boolean;
        };
        /**
         * @example {
         *       "role": "manager",
         *       "resources": [
         *         {
         *           "id": "PANZZEQ",
         *           "type": "escalation_policy",
         *           "summary": "Engineering Escalation Policy",
         *           "self": "https://api.pagerduty.com/escalation_policies/PANZZEQ",
         *           "html_url": "https://subdomain.pagerduty.com/escalation_policies/PANZZEQ"
         *         },
         *         {
         *           "id": "PI7DH85",
         *           "type": "schedule",
         *           "summary": "Daily Engineering Rotation",
         *           "self": "https://api.pagerduty.com/schedules/PI7DH85",
         *           "html_url": "https://subdomain.pagerduty.com/schedules/PI7DH85"
         *         }
         *       ]
         *     }
         */
        UserRole: {
            /**
             * @description The role of the user for a set of resources.
             * @example observer
             * @enum {string}
             */
            role?: "observer" | "responder" | "manager";
            resources?: components["schemas"]["Reference"][];
        };
        UserReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "user_reference";
        };
        /**
         * @example {
         *       "id": "PXPGF42",
         *       "user_id": "PXPGF42",
         *       "created_at": "2018-10-06T21:30:42Z",
         *       "summary": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36",
         *       "type": "browser"
         *     }
         */
        UserSession: {
            readonly id: string;
            readonly user_id: string;
            /**
             * Format: date-time
             * @description The date/time the user session was first created.
             */
            readonly created_at: string;
            /**
             * @description The type of the session
             * @enum {string}
             */
            readonly type: "browser" | "oauth";
            /** @description The summary of the session */
            readonly summary: string;
        };
        User: components["schemas"]["Tag"] & {
            /** @description The name of the user. */
            name: string;
            /**
             * @description The type of object being created.
             * @default user
             * @enum {string}
             */
            type: "user";
            /**
             * Format: email
             * @description The user's email address.
             */
            email: string;
            /**
             * Format: tzinfo
             * @description The preferred time zone name. If null, the account's time zone will be used.
             */
            time_zone?: string;
            /** @description The schedule color. */
            color?: string;
            /**
             * @description The user role. Account must have the `read_only_users` ability to set a user as a `read_only_user` or a `read_only_limited_user`, and must have advanced permissions abilities to set a user as `observer` or `restricted_access`.
             * @enum {string}
             */
            role?: "admin" | "limited_user" | "observer" | "owner" | "read_only_user" | "restricted_access" | "read_only_limited_user" | "user";
            /**
             * Format: url
             * @description The URL of the user's avatar.
             */
            readonly avatar_url?: string;
            /** @description The user's bio. */
            description?: string | null;
            /** @description If true, the user has an outstanding invitation. */
            readonly invitation_sent?: boolean;
            /** @description The user's title. */
            job_title?: string;
            /** @description If true, the user was created via Single Sign-On (SSO). */
            readonly created_via_sso?: boolean;
            /** @description The list of teams to which the user belongs. Account must have the `teams` ability to set this. */
            readonly teams?: components["schemas"]["TeamReference"][];
            /** @description The list of contact methods for the user. */
            readonly contact_methods?: components["schemas"]["ContactMethodReference"][];
            /** @description The list of notification rules for the user. */
            readonly notification_rules?: components["schemas"]["NotificationRuleReference"][];
        };
        TeamReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "team_reference";
        };
        Team: components["schemas"]["Tag"] & {
            /**
             * @description The type of object being created.
             * @default team
             * @enum {string}
             */
            type: "team";
            /** @description The name of the team. */
            name: string;
            /** @description The description of the team. */
            description?: string;
            /**
             * @description The team is private if the value is "none", or public if it is "manager" (the default permissions for a non-member of the team are either "none", or their base role up until "manager").
             * @default manager
             * @enum {string}
             */
            default_role: "manager" | "none";
        };
        /** Impact */
        Impact: {
            readonly id?: string;
            readonly name?: string;
            /**
             * @description The kind of object that has been impacted
             * @enum {string}
             */
            type?: "business_service";
            /**
             * @description The current impact status of the object
             * @enum {string}
             */
            status?: "impacted" | "not_impacted";
            additional_fields?: {
                /** @description Priority information for the highest priority level that is affecting the impacted object. */
                highest_impacting_priority?: {
                    readonly id?: string;
                    readonly order?: number;
                } | null;
            };
        };
        /** Impactor */
        Impactor: {
            readonly id?: string;
            /**
             * @description The kind of object that is impacting
             * @enum {string}
             */
            type?: "incident";
        };
        IncidentReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "incident_reference";
        };
        IncidentType: {
            /** @description State of this Incident Type object. */
            enabled?: boolean;
            readonly id?: string;
            /** @description The name of the Incident Type. */
            name?: string;
            /** @description The parent Incident Type (id/name). If omitted, type is created under top level (incident_default) */
            parent?: {
                id?: string;
                /** @example incident_type_reference */
                type?: string;
            };
            /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
            readonly type?: string;
            /** @description A succinct description of the Incident Type. */
            description?: string;
            /**
             * Format: date-time
             * @description The time the Incident Type was created.
             * @example 2019-12-01T20:00:00Z
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The time the Incident Type was last modified.
             * @example 2019-12-01T21:02:00Z
             */
            updated_at?: string;
            /** @description The display name of the Incident Type. The first character must be alphanumeric. Max length: 50, Min Length : 1. The `display_name` for a Field must be unique. */
            display_name?: string;
        };
        IncidentTypeCustomFields: {
            /** @description Whether the custom field is enabled. */
            readonly enabled: boolean;
            /** @description The ID of the resource. */
            readonly id: string;
            name: components["schemas"]["CustomFieldsFieldValue"]["name"];
            /** @enum {string} */
            readonly type: "field";
            /**
             * Format: url
             * @description The API show URL at which the object is accessible
             */
            readonly self: string | null;
            description?: components["schemas"]["CustomFieldsFieldValue"]["description"];
            field_type: components["schemas"]["CustomFieldsFieldValue"]["field_type"];
            data_type: components["schemas"]["CustomFieldsFieldValue"]["data_type"];
            /**
             * Format: date-time
             * @description The date/time the custom field was last updated.
             */
            readonly updated_at: string;
            /**
             * Format: date-time
             * @description The date/time the custom field was created at.
             */
            readonly created_at: string;
            display_name: components["schemas"]["CustomFieldsFieldValue"]["display_name"];
            default_value?: (components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["0"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["2"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["1"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["3"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["4"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["5"]) | null;
            /** @description The id of the incident type the custom field is associated with. */
            readonly incident_type: string;
            /** @description A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier. */
            readonly summary: string | null;
            /** @description The options for the custom field. */
            field_options: components["schemas"]["CustomFieldsEditableFieldOption"][];
        };
        IncidentTypeCustomFieldWithOptions: {
            /** @description Whether the custom field is enabled. */
            readonly enabled: boolean;
            /** @description The ID of the resource. */
            readonly id: string;
            name: components["schemas"]["CustomFieldsFieldValue"]["name"];
            /** @enum {string} */
            readonly type: "field";
            /**
             * Format: url
             * @description The API show URL at which the object is accessible
             */
            readonly self: string | null;
            description?: components["schemas"]["CustomFieldsFieldValue"]["description"];
            field_type: components["schemas"]["CustomFieldsFieldValue"]["field_type"];
            data_type: components["schemas"]["CustomFieldsFieldValue"]["data_type"];
            /**
             * Format: date-time
             * @description The date/time the object was last updated.
             */
            readonly updated_at: string;
            /**
             * Format: date-time
             * @description The date/time the object was created at.
             */
            readonly created_at: string;
            display_name: components["schemas"]["CustomFieldsFieldValue"]["display_name"];
            default_value?: components["schemas"]["IncidentTypeCustomFields"]["default_value"];
            /** @description The id of the incident type the custom field is associated with. */
            readonly incident_type: string;
            /** @description A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier. */
            readonly summary: string | null;
            /** @description The options for the custom field. Applies only to `single_value_fixed` and `multi_value_fixed` field types. Optionally included in response based on query parameter. */
            field_options?: {
                id?: string;
                /** @enum {string} */
                type?: "field_option";
                /**
                 * Format: date-time
                 * @description The date/time the field option was last updated.
                 */
                readonly updated_at?: string;
                /**
                 * Format: date-time
                 * @description The date/time the field option was created at.
                 */
                readonly created_at?: string;
                data?: {
                    value?: string;
                    /** @enum {unknown} */
                    data_type?: "string";
                };
            }[];
        };
        IncidentTypeReference: {
            readonly id?: string;
            /** @description The name of the Incident Type. */
            name?: string;
        };
        Incident: components["schemas"]["Tag"] & {
            /** @description The number of the incident. This is unique across your account. */
            readonly incident_number?: number;
            /** @description A succinct description of the nature, symptoms, cause, or effect of the incident. */
            title?: string;
            /**
             * Format: date-time
             * @description The time the incident was first triggered.
             * @example 2019-12-01T20:00:00Z
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The time the incident was last modified.
             * @example 2019-12-01T21:02:00Z
             */
            updated_at?: string;
            /**
             * @description The current status of the incident.
             * @enum {string}
             */
            status?: "triggered" | "acknowledged" | "resolved";
            /** @description The incident's de-duplication key. */
            readonly incident_key?: string;
            /** @description The service the incident is on. If the `include[]=services` query parameter is provided, the full service definition will be returned. */
            service?: components["schemas"]["ServiceReference"] | components["schemas"]["Service"];
            /** @description List of all assignments for this incident. This list will be empty if the `Incident.status` is `resolved`. Returns a user reference for each assignment. Full user definitions will be returned if the `include[]=assignees` query parameter is provided. */
            assignments?: components["schemas"]["Assignment"][];
            /**
             * @description How the current incident assignments were decided.  Note that `direct_assignment` incidents will not escalate up the attached `escalation_policy`
             * @enum {string}
             */
            readonly assigned_via?: "escalation_policy" | "direct_assignment";
            /**
             * Format: date-time
             * @description The time the status of the incident last changed. If the incident is not currently acknowledged or resolved, this will be the incident's `updated_at`.
             * @example 2019-12-01T21:01:00Z
             */
            readonly last_status_change_at?: string;
            /**
             * Format: date-time
             * @description The time the incident became "resolved" or `null` if the incident is not resolved.
             * @example 2019-12-01T21:01:00Z
             */
            resolved_at?: string;
            /** @description The first log entry on the incident. The log entry will be of type `TriggerLogEntry` and will represent information about how the incident was triggered. If the `include[]=first_trigger_log_entries` query parameter is provided, the full log entry definition will be returned. */
            first_trigger_log_entry?: components["schemas"]["LogEntryReference"] | components["schemas"]["TriggerLogEntry"];
            alert_counts?: components["schemas"]["AlertCount"];
            /** @description Whether the incident is mergeable. Only incidents that have alerts, or that are manually created can be merged. */
            readonly is_mergeable?: boolean;
            /** @description The incident type of the incident. */
            incident_type?: {
                /** @description The name of the Incident Type. */
                name?: string;
            };
            /** @description The escalation policy attached to the service that the incident is on. If the `include[]=escalation_policies` query parameter is provided, the full escalation policy definition will be returned. */
            escalation_policy?: components["schemas"]["EscalationPolicyReference"] | components["schemas"]["EscalationPolicy"];
            /** @description The teams involved in the incidents lifecycle. If the `include[]=teams` query parameter is provided, the full team definitions will be returned. */
            teams?: (components["schemas"]["TeamReference"] | components["schemas"]["Team"])[];
            /** @description The list of pending_actions on the incident. A pending_action object contains a type of action which can be escalate, unacknowledge, resolve or urgency_change. A pending_action object contains at, the time at which the action will take place. An urgency_change pending_action will contain to, the urgency that the incident will change to. */
            readonly pending_actions?: components["schemas"]["IncidentAction"][];
            /** @description List of all acknowledgements for this incident. This list will be empty if the `Incident.status` is `resolved` or `triggered`. If the `include[]=acknowledgers` query parameter is provided, the full user or service definitions will be returned for each acknowledgement entry. */
            acknowledgements?: components["schemas"]["Acknowledgement"][];
            /** @description Describes the alert grouping state of this incident. Will be null if the incident has no alerts. */
            alert_grouping?: {
                /** @enum {string} */
                grouping_type?: "basic" | "advanced" | "rules";
                /** Format: date-time */
                started_at?: string;
                /** Format: date-time */
                ended_at?: string;
                alert_grouping_active?: boolean;
            };
            /** @description The entity that last changed the status of the incident. If the `include[]=agents` query parameter is provided, the full user/service/integration definition will be returned. */
            last_status_change_by?: components["schemas"]["AgentReference"] | components["schemas"]["User"] | components["schemas"]["Service"];
            priority?: components["schemas"]["Priority"];
            resolve_reason?: components["schemas"]["ResolveReason"];
            /** @description The conference bridge information attached to the incident. Only returned if the `include[]=conference_bridge` query parameter is provided. */
            conference_bridge?: components["schemas"]["ConferenceBridge"];
            /** @description The responders on the incident. Only returned if the account has access to the [responder requests](https://support.pagerduty.com/docs/add-responders) feature. */
            readonly incidents_responders?: components["schemas"]["IncidentsRespondersReference"][];
            /** @description Previous responder requests made on this incident. Only returned if the account has access to the [responder requests](https://support.pagerduty.com/docs/add-responders) feature. */
            readonly responder_requests?: components["schemas"]["ResponderRequest"][];
            /**
             * @description The current urgency of the incident.
             * @enum {string}
             */
            urgency?: "high" | "low";
            /** @description The additional incident body details. Only returned if the `include[]=body` query parameter is provided. */
            body?: components["schemas"]["IncidentBody"];
        };
        EscalationPolicyReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "escalation_policy_reference";
        };
        EscalationPolicy: components["schemas"]["Tag"] & {
            /**
             * @description The type of object being created.
             * @default escalation_policy
             * @enum {string}
             */
            type: "escalation_policy";
            /** @description The name of the escalation policy. */
            name: string;
            /** @description Escalation policy description. */
            description?: string;
            /**
             * @description The number of times the escalation policy will repeat after reaching the end of its escalation.
             * @default 0
             */
            num_loops: number;
            /**
             * @description Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services".
             * @enum {string}
             */
            on_call_handoff_notifications?: "if_has_services" | "always";
            escalation_rules: components["schemas"]["EscalationRule"][];
            readonly services?: components["schemas"]["ServiceReference"][];
            /** @description Team associated with the policy. Account must have the `teams` ability to use this parameter. Only one team may be associated with the policy. */
            teams?: components["schemas"]["TeamReference"][];
        };
        /**
         * @example {
         *       "escalation_delay_in_minutes": 30,
         *       "targets": [
         *         {
         *           "id": "PAM4FGS",
         *           "type": "user_reference"
         *         },
         *         {
         *           "id": "PI7DH85",
         *           "type": "schedule_reference"
         *         }
         *       ]
         *     }
         */
        EscalationRule: {
            readonly id?: string;
            /** @description The number of minutes before an unacknowledged incident escalates away from this rule. */
            escalation_delay_in_minutes: number;
            /** @description The targets an incident should be assigned to upon reaching this rule. */
            targets: components["schemas"]["EscalationTargetReference"][];
            /**
             * @description The strategy used to assign the escalation rule to an incident.
             * @enum {string}
             */
            escalation_rule_assignment_strategy?: "round_robin" | "assign_to_everyone";
        };
        EscalationTargetReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "user" | "schedule" | "user_reference" | "schedule_reference";
        };
        ExtensionReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "extension_reference";
        };
        Extension: components["schemas"]["Tag"] & {
            /** @description The name of the extension. */
            name: string;
            /**
             * @description The type of object being created.
             * @default extension
             * @enum {string}
             */
            type: "extension";
            /**
             * Format: url
             * @description The url of the extension.
             */
            endpoint_url?: string;
            /** @description The objects for which the extension applies */
            extension_objects: components["schemas"]["ServiceReference"][];
            extension_schema: components["schemas"]["ExtensionSchemaReference"];
            /**
             * @description Whether or not this extension is temporarily disabled; for example, a webhook extension that is repeatedly rejected by the server.
             * @default false
             */
            readonly temporarily_disabled: boolean;
            /** @description The object that contains extension configuration values depending on the extension schema specification. */
            config?: Record<string, never>;
        };
        ServiceReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "service_reference";
        };
        Service: components["schemas"]["Tag"] & {
            /**
             * @description The type of object being created.
             * @default service
             * @enum {string}
             */
            type: "service";
            /** @description The name of the service. */
            name?: string;
            /** @description The user-provided description of the service. */
            description?: string;
            /**
             * @description Time in seconds that an incident is automatically resolved if left open for that long. Value is `null` if the feature is disabled. Value must not be negative. Setting this field to `0`, `null` (or unset in POST request) will disable the feature.
             * @default 14400
             */
            auto_resolve_timeout: number;
            /**
             * @description Time in seconds that an incident changes to the Triggered State after being Acknowledged. Value is `null` if the feature is disabled. Value must not be negative. Setting this field to `0`, `null` (or unset in POST request) will disable the feature.
             * @default 1800
             */
            acknowledgement_timeout: number;
            /**
             * Format: date-time
             * @description The date/time when this service was created
             */
            readonly created_at?: string;
            /**
             * @description The current state of the Service. Valid statuses are:
             *
             *
             *     - `active`: The service is enabled and has no open incidents. This is the only status a service can be created with.
             *     - `warning`: The service is enabled and has one or more acknowledged incidents.
             *     - `critical`: The service is enabled and has one or more triggered incidents.
             *     - `maintenance`: The service is under maintenance, no new incidents will be triggered during maintenance mode.
             *     - `disabled`: The service is disabled and will not have any new triggered incidents.
             * @default active
             * @enum {string}
             */
            status: "active" | "warning" | "critical" | "maintenance" | "disabled";
            /**
             * Format: date-time
             * @description The date/time when the most recent incident was created for this service.
             */
            readonly last_incident_timestamp?: string;
            escalation_policy: components["schemas"]["EscalationPolicyReference"];
            /**
             * @deprecated
             * @description Response plays associated with this service.
             */
            response_play?: unknown;
            /** @description The set of teams associated with this service. */
            readonly teams?: components["schemas"]["TeamReference"][];
            /** @description An array containing Integration objects that belong to this service. If `integrations` is passed as an argument, these are full objects - otherwise, these are references. */
            readonly integrations?: components["schemas"]["IntegrationReference"][];
            incident_urgency_rule?: components["schemas"]["IncidentUrgencyRule"];
            support_hours?: components["schemas"]["SupportHours"];
            /** @description An array containing scheduled actions for the service. */
            scheduled_actions?: components["schemas"]["ScheduledAction"][];
            /** @description The array of Add-ons associated with this service. */
            readonly addons?: components["schemas"]["AddonReference"][];
            /**
             * @deprecated
             * @description Whether a service creates only incidents, or both alerts and incidents. A service must create alerts in order to enable incident merging.
             *     * "create_incidents" - The service will create one incident and zero alerts for each incoming event.
             *     * "create_alerts_and_incidents" - The service will create one incident and one associated alert for each incoming event.
             *     This attribute has been deprecated as all services will be migrated to use alerts and incidents. Afterward, the incident only service setting will no longer be available. For details, please refer to the knowledge base: https://support.pagerduty.com/docs/alerts#enable-and-disable-alerts-on-a-service.
             * @default create_alerts_and_incidents
             * @enum {string}
             */
            alert_creation: "create_incidents" | "create_alerts_and_incidents";
            /**
             * @deprecated
             * @description Alert Grouping Parameters
             */
            alert_grouping_parameters?: components["schemas"]["AlertGroupingParameters"] | {
                /** @description id of the related alert grouping setting */
                readonly id?: string;
                /** @description type of reference eg. alert_grouping_setting_reference */
                readonly type?: string;
                /** @description an explanation of this reference */
                readonly summary?: string;
                /** @description link to api endpoint for this setting */
                readonly self?: string;
                /** @description link to the ui page to edit the setting */
                readonly html_url?: string;
            };
            /**
             * @deprecated
             * @description Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. There are three available options:
             *     * null - No alert grouping on the service. Each alert will create a separate incident;
             *     * "time" - All alerts within a specified duration will be grouped into the same incident. This duration is set in the `alert_grouping_timeout` setting (described below). Available on Standard, Enterprise, and Event Intelligence plans;
             *     * "intelligent" - Alerts will be intelligently grouped based on a machine learning model that looks at the alert summary, timing, and the history of grouped alerts. Available on Enterprise and Event Intelligence plans
             *
             *     This attribute has been deprecated and configuration via [Alert Grouping Settings](https://developer.pagerduty.com/api-reference/587edbc8ff416-create-an-alert-grouping-setting) resource is encouraged.
             * @enum {string}
             */
            alert_grouping?: "time" | "intelligent";
            /**
             * @deprecated
             * @description The duration in minutes within which to automatically group incoming alerts. This setting applies only when `alert_grouping` is set to `time`. To continue grouping alerts until the Incident is resolved, set this value to `0`.
             *
             *     This attribute has been deprecated and configuration via [Alert Grouping Settings](https://developer.pagerduty.com/api-reference/587edbc8ff416-create-an-alert-grouping-setting) resource is encouraged.
             */
            alert_grouping_timeout?: number;
            auto_pause_notifications_parameters?: components["schemas"]["AutoPauseNotificationsParameters"];
        };
        /** @description Details of the custom field. */
        ServiceCustomFieldsFieldReadModel: {
            /**
             * Datetime
             * Format: date-time
             * @description The date/time the object was created at.
             */
            created_at?: string;
            data_type?: components["schemas"]["CustomFieldsFieldValue"]["data_type"];
            description?: components["schemas"]["CustomFieldsFieldValue"]["description"];
            display_name?: components["schemas"]["CustomFieldsFieldValue"]["display_name"];
            enabled?: components["schemas"]["CustomFieldsEditableField"]["enabled"];
            /** @description The options for the custom field. Applies only to `single_value_fixed` and `multi_value_fixed` field types. These options are returned only if the `include[]` parameter specifies `field_options`. */
            field_options?: components["schemas"]["ServiceCustomFieldsFieldOptionReadModel"][];
            field_type?: components["schemas"]["CustomFieldsFieldValue"]["field_type"];
            /** @description The ID of the resource. */
            id?: string;
            name?: components["schemas"]["CustomFieldsFieldValue"]["name"];
            /**
             * Format: url
             * @description The API show URL at which the object is accessible
             */
            readonly self?: string | null;
            /** @description A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `display_name`. */
            readonly summary?: string | null;
            /** @enum {string} */
            readonly type?: "field";
            /**
             * Datetime
             * Format: date-time
             * @description The date/time the object was updated at.
             */
            updated_at?: string;
        };
        /** @description Details of the custom field to be created. */
        ServiceCustomFieldsFieldCreateModel: {
            data_type: components["schemas"]["CustomFieldsFieldValue"]["data_type"];
            description?: components["schemas"]["CustomFieldsFieldValue"]["description"];
            display_name: components["schemas"]["CustomFieldsFieldValue"]["display_name"];
            enabled?: components["schemas"]["CustomFieldsEditableField"]["enabled"];
            field_options?: components["schemas"]["ServiceCustomFieldsFieldOptionUpdateModel"][];
            field_type: components["schemas"]["CustomFieldsFieldValue"]["field_type"];
            name: components["schemas"]["CustomFieldsFieldValue"]["name"];
        };
        /** @description Details of the custom field to be updated. */
        ServiceCustomFieldsFieldUpdateModel: {
            description?: components["schemas"]["CustomFieldsFieldValue"]["description"];
            display_name?: components["schemas"]["CustomFieldsFieldValue"]["display_name"];
            enabled?: components["schemas"]["CustomFieldsEditableField"]["enabled"];
            /**
             * @description List of field options to update, insert or delete. This field supports several behaviors:
             *       - Empty array: Deletes all field options
             *       - Omitting the `field_options` array entirely: Preserves all existing options
             *       - Not listing an existing option: Deletes that option (unless it's the current default value)
             */
            field_options?: (components["schemas"]["ServiceCustomFieldsFieldOptionUpdateModel"] & {
                /**
                 * @description The unique identifier of the field option. How this field is used determines the behavior:
                 *       - When included with a valid `id`: Updates the corresponding existing field option
                 *       - When omitted or null: Creates a new field option
                 */
                id?: string;
            })[];
        };
        ServiceCustomFieldsFieldOptionReadModel: {
            created_at?: components["schemas"]["ServiceCustomFieldsFieldReadModel"]["created_at"];
            data?: {
                /**
                 * @description The kind of data represented by this option. Must match the Field's `data_type`.
                 * @enum {string}
                 */
                data_type?: "string";
                value?: string;
            };
            id?: components["schemas"]["ServiceCustomFieldsFieldReadModel"]["id"];
            /** @enum {string} */
            type?: "field_option";
            updated_at?: components["schemas"]["ServiceCustomFieldsFieldReadModel"]["updated_at"];
        };
        /** @description An option for a custom field. Can only be applied to fields with a `field_type` of `single_value_fixed` or `multi_value_fixed`. */
        ServiceCustomFieldsFieldOptionUpdateModel: {
            /** @description The data content of the field option. */
            data: {
                /**
                 * @description The kind of data represented by this option. Must match the Field's `data_type`.
                 * @enum {string}
                 */
                data_type: "string";
                /** @description The value of the field option. Must be unique within the field. */
                value: string;
            };
        };
        ServiceCustomFieldsFieldValueReadModel: {
            data_type?: components["schemas"]["CustomFieldsFieldValue"]["data_type"];
            description?: components["schemas"]["CustomFieldsFieldValue"]["description"];
            display_name?: components["schemas"]["CustomFieldsFieldValue"]["display_name"];
            field_type?: components["schemas"]["CustomFieldsFieldValue"]["field_type"];
            id?: components["schemas"]["ServiceCustomFieldsFieldReadModel"]["id"];
            name?: components["schemas"]["CustomFieldsFieldValue"]["name"];
            /**
             * @description Determines the type of the reference.
             * @enum {string}
             */
            type?: "field_value";
            value?: components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["0"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["1"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["2"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["3"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["4"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["5"];
        };
        /**
         * Custom Field Value
         * @description During updates:
         *     - Omitted fields remain unchanged
         *     - Null values reset fields
         *     - Provided values update fields
         *
         *     Note: All updates succeed or none are applied.
         */
        ServiceCustomFieldsFieldValueUpdateModel: {
            id: components["schemas"]["ServiceCustomFieldsFieldReadModel"]["id"];
            value: components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["0"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["4"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["1"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["2"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["3"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["5"];
        } | {
            name: components["schemas"]["CustomFieldsFieldValue"]["name"];
            value: components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["0"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["4"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["1"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["2"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["3"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["5"];
        };
        PriorityReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "priority_reference";
        };
        Priority: components["schemas"]["Tag"] & {
            /** @description The user-provided short name of the priority. */
            name?: string;
            /** @description The user-provided description of the priority. */
            description?: string;
        };
        Integration: components["schemas"]["Tag"] & {
            /** @enum {string} */
            type?: "aws_cloudwatch_inbound_integration" | "cloudkick_inbound_integration" | "event_transformer_api_inbound_integration" | "generic_email_inbound_integration" | "generic_events_api_inbound_integration" | "keynote_inbound_integration" | "nagios_inbound_integration" | "pingdom_inbound_integration" | "sql_monitor_inbound_integration" | "events_api_v2_inbound_integration";
            /** @description The name of this integration. */
            name?: string;
            service?: components["schemas"]["ServiceReference"];
            /**
             * Format: date-time
             * @description The date/time when this integration was created.
             */
            readonly created_at?: string;
            vendor?: components["schemas"]["VendorReference"];
            /** @description Specify for generic_email_inbound_integration. Must be set to an email address @your-subdomain.pagerduty.com */
            integration_email?: string;
            /**
             * @description Specify for generic_email_inbound_integration
             * @enum {string}
             */
            email_incident_creation?: "on_new_email" | "on_new_email_subject" | "only_if_no_open_incidents" | "use_rules";
            /**
             * @description Specify for generic_email_inbound_integration. May override email_incident_creation
             * @enum {string}
             */
            email_filter_mode?: "all-email" | "or-rules-email" | "and-rules-email";
            /** @description Specify for generic_email_inbound_integration. */
            email_parsers?: components["schemas"]["EmailParser"][];
            /**
             * @description Specify for generic_email_inbound_integration.
             * @enum {string}
             */
            email_parsing_fallback?: "open_new_incident" | "discard";
            /** @description Specify for generic_email_inbound_integration. */
            email_filters?: {
                /** @enum {string} */
                subject_mode: "match" | "no-match" | "always";
                /** @description Specify if subject_mode is set to match or no-match */
                subject_regex?: string;
                /** @enum {string} */
                body_mode: "match" | "no-match" | "always";
                /** @description Specify if body_mode is set to match or no-match */
                body_regex?: string;
                /** @enum {string} */
                from_email_mode: "match" | "no-match" | "always";
                /** @description Specify if from_email_mode is set to match or no-match */
                from_email_regex?: string;
            }[];
        };
        IntegrationReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "aws_cloudwatch_inbound_integration_reference" | "cloudkick_inbound_integration_reference" | "event_transformer_api_inbound_integration_reference" | "generic_email_inbound_integration_reference" | "generic_events_api_inbound_integration_reference" | "keynote_inbound_integration_reference" | "nagios_inbound_integration_reference" | "pingdom_inbound_integration_reference" | "sql_monitor_inbound_integration_reference" | "events_api_v2_inbound_integration_reference" | "inbound_integration_reference";
        };
        MaintenanceWindowReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "maintenance_window_reference";
        };
        MaintenanceWindow: components["schemas"]["Tag"] & {
            /**
             * @description The type of object being created.
             * @default maintenance_window
             * @enum {string}
             */
            type: "maintenance_window";
            /** @description The order in which the maintenance window was created. */
            readonly sequence_number?: number;
            /**
             * Format: date-time
             * @description This maintenance window's start time. This is when the services will stop creating incidents. If this date is in the past, it will be updated to be the current time.
             */
            start_time: string;
            /**
             * Format: date-time
             * @description This maintenance window's end time. This is when the services will start creating incidents again. This date must be in the future and after the `start_time`.
             */
            end_time: string;
            /** @description A description for this maintenance window. */
            description?: string;
            created_by?: components["schemas"]["UserReference"];
            services: components["schemas"]["ServiceReference"][];
            readonly teams?: components["schemas"]["TeamReference"][];
        };
        ScheduleReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "schedule_reference";
        };
        Schedule: components["schemas"]["Tag"] & {
            /**
             * @description The type of object being created.
             * @default schedule
             * @enum {string}
             */
            type: "schedule";
            /** @description A list of schedule layers. */
            schedule_layers?: components["schemas"]["ScheduleLayer"][];
            /**
             * Format: activesupport-time-zone
             * @description The time zone of the schedule.
             */
            time_zone: string;
            /** @description The name of the schedule */
            name?: string;
            /** @description The description of the schedule */
            description?: string;
            final_schedule?: components["schemas"]["SubSchedule"];
            overrides_subschedule?: components["schemas"]["SubSchedule"];
            /** @description An array of all of the escalation policies that uses this schedule. */
            readonly escalation_policies?: components["schemas"]["EscalationPolicyReference"][];
            /** @description An array of all of the users on the schedule. */
            readonly users?: components["schemas"]["UserReference"][];
            /** @description An array of all of the teams on the schedule. */
            readonly teams?: components["schemas"]["TeamReference"][];
            next_oncall_for_user?: {
                /** @description The start date for the User shift */
                readonly start?: string;
                /** @description The end date for the User shift */
                readonly end?: string;
                user?: components["schemas"]["Reference"];
            };
        };
        SubSchedule: {
            /**
             * @description The name of the subschedule
             * @enum {string}
             */
            readonly name: "Final Schedule" | "Overrides";
            /** @description This is a list of entries on the computed layer for the current time range. Since or until must be set in order for this field to be populated. */
            readonly rendered_schedule_entries?: components["schemas"]["ScheduleLayerEntry"][];
            /** @description The percentage of the time range covered by this layer. Returns null unless since or until are set. */
            readonly rendered_coverage_percentage?: number;
        };
        ScheduleLayer: {
            id?: string;
            /**
             * Format: date-time
             * @description The start time of this layer.
             */
            start: string;
            /**
             * Format: date-time
             * @description The end time of this layer. If `null`, the layer does not end.
             */
            end?: string;
            /** @description The ordered list of users on this layer. The position of the user on the list determines their order in the layer. */
            users: components["schemas"]["ScheduleLayerUser"][];
            /** @description An array of restrictions for the layer. A restriction is a limit on which period of the day or week the schedule layer can accept assignments. Restrictions respect the `time_zone` parameter of the request. */
            restrictions?: components["schemas"]["Restriction"][];
            /**
             * Format: date-time
             * @description The effective start time of the layer. This can be before the start time of the schedule.
             */
            rotation_virtual_start: string;
            /** @description The duration of each on-call shift in seconds. */
            rotation_turn_length_seconds: number;
            /** @description The name of the schedule layer. */
            name?: string;
            /** @description This is a list of entries on the computed layer for the current time range. Since or until must be set in order for this field to be populated. */
            readonly rendered_schedule_entries?: components["schemas"]["ScheduleLayerEntry"][];
            /** @description The percentage of the time range covered by this layer. Returns null unless since or until are set. */
            readonly rendered_coverage_percentage?: number;
        };
        ScheduleLayerEntry: {
            user?: components["schemas"]["UserReference"];
            /**
             * Format: date-time
             * @description The start time of this entry.
             */
            readonly start: string;
            /**
             * Format: date-time
             * @description The end time of this entry. If null, the entry does not end.
             */
            readonly end: string;
        };
        ScheduleLayerUser: {
            user: components["schemas"]["UserReference"];
        };
        /** Standard */
        Standard: {
            active?: boolean;
            description?: string;
            id?: string;
            name?: string;
            type?: string;
            /** @enum {string} */
            resource_type?: "technical_service";
            exclusions?: components["schemas"]["StandardInclusionExclusion"][];
            inclusions?: components["schemas"]["StandardInclusionExclusion"][];
        };
        /** StatusDashboard */
        StatusDashboard: {
            id?: string;
            url_slug?: string;
            name?: string;
        };
        Override: components["schemas"]["Tag"] & {
            readonly id?: string;
            /**
             * Format: date-time
             * @description The start date and time for the override.
             */
            start: string;
            /**
             * Format: date-time
             * @description The end date and time for the override.
             */
            end: string;
            user: components["schemas"]["UserReference"];
        };
        Restriction: {
            /**
             * @description Specify the types of `restriction`.
             * @enum {string}
             */
            type: "daily_restriction" | "weekly_restriction";
            /** @description The duration of the restriction in seconds. */
            duration_seconds: number;
            /**
             * Format: partial-time
             * @description The start time in HH:mm:ss format.
             */
            start_time_of_day: string;
            /** @description Only required for use with a `weekly_restriction` restriction type. The first day of the weekly rotation schedule as [ISO 8601 day](https://en.wikipedia.org/wiki/ISO_week_date) (1 is Monday, etc.) */
            start_day_of_week?: number;
        };
        WeeklyRestriction: {
            type: "WeeklyRestriction";
        } & (Omit<components["schemas"]["Restriction"], "type"> & {
            /** @description The first day of the weekly rotation schedule as [ISO 8601 day](https://en.wikipedia.org/wiki/ISO_week_date) (1 is Monday, etc.) */
            start_day_of_week: number;
        });
        Pagination: {
            /** @description Echoes offset pagination property. */
            readonly offset?: number;
            /** @description Echoes limit pagination property. */
            readonly limit?: number;
            /** @description Indicates if there are additional records to return */
            readonly more?: boolean;
            /** @description The total number of records matching the given query. */
            readonly total?: number | null;
        };
        CursorPagination: {
            /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
            readonly limit: number;
            /**
             * @description An opaque string than will deliver the next set of results when provided as the `cursor` parameter in a subsequent request.  A `null` value for this field indicates that there are no additional results.
             * @example dXNlcjaVMzc5V0ZYTlo=
             */
            readonly next_cursor: string | null;
        };
        LiveListResponse: {
            /** @description Echoes limit pagination property. */
            readonly limit?: number;
            /** @description Indicates if there are additional records to return */
            readonly more?: boolean;
        };
        Assignment: {
            /**
             * Format: date-time
             * @description Time at which the assignment was created.
             */
            at: string;
            assignee: components["schemas"]["UserReference"] | components["schemas"]["User"];
        };
        Acknowledgement: {
            /**
             * Format: date-time
             * @description Time at which the acknowledgement was created.
             */
            at: string;
            acknowledger: components["schemas"]["AcknowledgerReference"] | components["schemas"]["User"] | components["schemas"]["Service"];
        };
        AcknowledgerReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "user_reference" | "service_reference";
        };
        /**
         * @example {
         *       "user": {
         *         "id": "PT23IWX",
         *         "type": "user_reference",
         *         "summary": "Tim Wright",
         *         "self": "https://api.pagerduty.com/users/PT23IWX",
         *         "html_url": "https://subdomain.pagerduty.com/users/PT23IWX"
         *       },
         *       "schedule": {
         *         "id": "PI7DH85",
         *         "type": "schedule_reference",
         *         "summary": "Daily Engineering Rotation",
         *         "self": "https://api.pagerduty.com/schedules/PI7DH85",
         *         "html_url": "https://subdomain.pagerduty.com/schedules/PI7DH85"
         *       },
         *       "escalation_policy": {
         *         "id": "PT20YPA",
         *         "type": "escalation_policy_reference",
         *         "summary": "Engineering Escalation Policy",
         *         "self": "https://api.pagerduty.com/escalation_policies/PT20YPA",
         *         "html_url": "https://subdomain.pagerduty.com/escalation_policies/PT20YPA"
         *       },
         *       "escalation_level": 2,
         *       "start": "2015-03-06T15:28:51-05:00",
         *       "end": "2015-03-07T15:28:51-05:00"
         *     }
         */
        Oncall: {
            escalation_policy?: components["schemas"]["EscalationPolicyReference"];
            user?: components["schemas"]["UserReference"];
            schedule?: components["schemas"]["ScheduleReference"];
            /** @description The escalation level for the on-call. */
            readonly escalation_level?: number;
            /**
             * Format: date-time
             * @description The start of the on-call. If `null`, the on-call is a permanent user on-call.
             */
            readonly start?: string;
            /**
             * Format: date-time
             * @description The end of the on-call. If `null`, the user does not go off-call.
             */
            readonly end?: string;
        };
        VendorReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "vendor_reference";
        };
        Vendor: components["schemas"]["Tag"] & {
            /** @description The short name of the vendor */
            readonly name?: string;
            /**
             * Format: url
             * @description URL of the vendor's main website
             */
            readonly website_url?: string;
            /**
             * Format: url
             * @description URL of a logo identifying the vendor
             */
            readonly logo_url?: string;
            /**
             * Format: url
             * @description URL of a small thumbnail image identifying the vendor
             */
            readonly thumbnail_url?: string;
            /** @description A short description of this vendor, and common use-cases of integrations for this vendor. */
            readonly description?: string;
            /**
             * Format: url
             * @description URL of an integration guide for this vendor
             */
            readonly integration_guide_url?: string;
        };
        ExtensionSchemaReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "extension_schema_reference";
        };
        /**
         * @example {
         *       "id": "PJFWPEP",
         *       "type": "extension_schema",
         *       "summary": "Generic Webhook",
         *       "self": "https://api.pagerduty.com/extension_schemas/PJFWPEP",
         *       "html_url": "null",
         *       "description": "Long description here",
         *       "guide_url": "https://developer.pagerduty.com",
         *       "icon_url": "https://extension.com/extension.png",
         *       "key": "generic_webhook",
         *       "label": "Generic Webhook",
         *       "logo_url": "https://extension.com/logo.png",
         *       "send_types": [
         *         "trigger",
         *         "acknowledge",
         *         "resolve",
         *         "delegate",
         *         "escalate",
         *         "unacknowledge",
         *         "assign",
         *         "custom"
         *       ],
         *       "url": "https://developer.pagerduty.com/my_webhook_endpoint"
         *     }
         */
        ExtensionSchema: {
            /**
             * Format: url
             * @description A small logo, 18-by-18 pixels.
             */
            readonly icon_url?: string;
            /**
             * Format: url
             * @description A large logo, 75 pixels high and no more than 300 pixels wide.
             */
            readonly logo_url?: string;
            /** @description Human friendly display label */
            readonly label?: string;
            /** @description Machine friendly display label */
            readonly key?: string;
            /** @description The long description for the Extension */
            description?: string;
            /**
             * Format: url
             * @description A link to the extension's support guide
             */
            readonly guide_url?: string;
            /** @description The types of PagerDuty incident events that will activate this Extension */
            send_types?: ("trigger" | "acknowledge" | "resolve" | "delegate" | "escalate" | "unacknowledge" | "assign" | "custom")[];
            /** @description The url that the webhook payload will be sent to for this Extension. */
            readonly url?: string;
        };
        ResolveReason: {
            /**
             * @description The reason the incident was resolved. The only reason currently supported is merge.
             * @default merge_resolve_reason
             * @enum {string}
             */
            type: "merge_resolve_reason";
            incident?: components["schemas"]["IncidentReference"];
        };
        Alert: components["schemas"]["Tag"] & {
            /**
             * Format: date-time
             * @description The date/time the alert was first triggered.
             */
            readonly created_at?: string;
            /**
             * @description The type of object being created.
             * @default alert
             * @enum {string}
             */
            type: "alert";
            /**
             * @description The current status of the alert.
             * @enum {string}
             */
            status?: "triggered" | "resolved";
            /** @description The alert's de-duplication key. */
            readonly alert_key?: string;
            service?: components["schemas"]["ServiceReference"];
            first_trigger_log_entry?: components["schemas"]["LogEntryReference"];
            incident?: components["schemas"]["IncidentReference"];
            /**
             * @description Whether or not an alert is suppressed. Suppressed alerts are not created with a parent incident.
             * @default false
             */
            readonly suppressed: boolean;
            /**
             * @description The magnitude of the problem as reported by the monitoring tool.
             * @enum {string}
             */
            readonly severity?: "info" | "warning" | "error" | "critical";
            integration?: components["schemas"]["IntegrationReference"];
            /**
             * Body
             * @description A JSON object containing data describing the alert.
             */
            readonly body?: {
                /**
                 * @description The type of the body.
                 * @enum {string}
                 */
                type?: "alert_body";
                /** @description Contexts to be included with the body such as links to graphs or images. */
                readonly contexts?: components["schemas"]["Context"][];
                /** @description An arbitrary JSON object or string containing any data explaining the nature of the alert. */
                readonly details?: Record<string, never>;
            };
        };
        AlertReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "alert_reference";
        };
        AlertCount: {
            /** @description The count of triggered alerts grouped into this incident */
            triggered?: number;
            /** @description The count of resolved alerts grouped into this incident */
            resolved?: number;
            /** @description The total count of alerts grouped into this incident */
            all?: number;
        };
        AlertUpdate: {
            /** @enum {string} */
            status?: "resolved" | "triggered";
            incident?: components["schemas"]["AlertUpdateIncidentReference"];
        };
        AlertUpdateIncidentReference: {
            id: string;
            /** @enum {string} */
            type?: "incident_reference";
        };
        IncidentPrivilege: {
            /** @enum {string} */
            role?: "admin" | "manager" | "observer" | "owner" | "read_only" | "responder" | "team_responder" | "read_only_limited_user" | "none";
            permissions?: ("create" | "update" | "destroy" | "new" | "edit" | "crud" | "delete" | "manage" | "add" | "index" | "read" | "show" | "manage_incidents" | "manually_trigger_incident")[];
        };
        IncidentBody: {
            /** @description Additional incident details. */
            details?: Record<string, never>;
        };
        IncidentWorkflow: components["schemas"]["Tag"] & {
            /** @enum {string} */
            type?: "incident_workflow";
            /** @description A descriptive name for the Incident Workflow */
            name?: string;
            /** @description A description of what the Incident Workflow does */
            description?: string;
            /**
             * Format: date-time
             * @description The timestamp this Incident Workflow was created
             */
            readonly created_at?: string;
            /** @description If specified then workflow edit permissions will be scoped to members of this team */
            team?: {
                /**
                 * @description Type of the referenced object
                 * @enum {string}
                 */
                readonly type?: "team_reference";
                /** @description Unique identifier for the resource */
                readonly id?: string;
            };
            /**
             * @description Indicates whether the Incident Workflow is enabled or not. Disabled workflows will not be triggered, and
             *     will not count toward the account's enabled workflow limit.
             * @default true
             */
            is_enabled: boolean;
            /** @description The ordered list of steps that execute sequentially as part of the workflow */
            steps?: (components["schemas"]["Tag"] & {
                /** @enum {string} */
                type?: "step";
                /** @description A descriptive name for the Step */
                name: string;
                /** @description A description of the action performed by the Step */
                readonly description?: string;
                /** @description Configuration of automated action executed by this Step */
                action_configuration: {
                    /** @description The identifier of the Action to execute */
                    action_id: string;
                    /** @description Description of the Action */
                    readonly description?: string;
                    /** @description An unordered list of standard inputs used to configure the Action to execute */
                    inputs: {
                        /** @description The name for this Input. Input names are unique per action and should be used to find a specific Input. */
                        name: string;
                        /** @description The data type of this Input */
                        readonly parameter_type?: string;
                        /** @description The configured value of the Input */
                        value: string;
                    }[];
                    /** @description An unordered list of specialized inputs used to configure a workflow-within-a-workflow */
                    inline_steps_inputs?: {
                        /** @description The name for this Input. Input names are unique per action and should be used to find a specific Input. */
                        name: string;
                        /** @description The configured value of the Inline Steps Input */
                        value: {
                            steps?: (components["schemas"]["Tag"] & {
                                /** @enum {string} */
                                type?: "step";
                                /** @description A descriptive name for the Step */
                                name: string;
                                /** @description Configuration of automated action executed by this Step */
                                action_configuration: {
                                    /** @description The identifier of the Action to execute */
                                    action_id: string;
                                    /** @description Description of the Action */
                                    readonly description?: string;
                                    /** @description An unordered list of standard inputs used to configure the Action to execute */
                                    inputs: {
                                        /** @description The name for this Input. Input names are unique per action and should be used to find a specific Input. */
                                        name: string;
                                        /** @description The data type of this Input */
                                        readonly parameter_type?: string;
                                        /** @description The configured value of the Input */
                                        value: string;
                                    }[];
                                    /** @description An unordered list of outputs this action produces */
                                    readonly outputs?: {
                                        /** @description The name for this Output. Output names are unique per action and should be used to find a specific Output. */
                                        readonly name: string;
                                        /** @description The reference name of the Output */
                                        readonly reference_name?: string;
                                        /** @description The data type produced by this Output */
                                        readonly parameter_type?: string;
                                    }[];
                                };
                            })[];
                        };
                    }[];
                    /** @description An unordered list of outputs this action produces */
                    readonly outputs?: {
                        /** @description The name for this Output. Output names are unique per action and should be used to find a specific Output. */
                        readonly name: string;
                        /** @description The reference name of the Output */
                        readonly reference_name?: string;
                        /** @description The data type produced by this Output */
                        readonly parameter_type?: string;
                    }[];
                };
            })[];
        };
        IncidentWorkflowAction: components["schemas"]["Tag"] & {
            /** @enum {string} */
            type?: "action";
            /** @description The Verified Domain of the account that created the action */
            domain_name?: string;
            /** @description The Package Name corresponding to the broad category of the Action */
            package_name?: string;
            /** @description The Function Name describing the specific functionality of the Action */
            function_name?: string;
            /** @description The version of the Action */
            version?: number;
            /** @description The descriptive name of the Action */
            name?: string;
            /** @description A description of the Action */
            description?: string;
            /**
             * @description The type of Action
             * @enum {string}
             */
            action_type?: "action" | "trigger";
            /**
             * @description The type of Trigger this Action is, if action_type is trigger
             * @enum {string}
             */
            trigger_type?: "polling" | "subscription" | "web";
            /** @description A set of tags to apply to this action. */
            tags?: string[];
            /** @description A set of search keywords to apply to this action. */
            search_keywords?: string[];
            /** @description JSON-formatted string of metadata pertaining to the Action */
            metadata?: string;
            /**
             * Format: date-time
             * @description The date-time at which this Action was created
             */
            created_at?: string;
            /** @description The obfuscated Id of the User who created this Action */
            created_by_user_id?: string;
            /** @description Inputs whose values used during Action execution */
            inputs?: {
                /** @description The name of the Input */
                name?: string;
                /** @description Describes what the purpose of the Input */
                description?: string;
                /**
                 * @description The data type of this Input
                 * @enum {string}
                 */
                type?: "text" | "password" | "integer" | "decimal" | "date" | "dateTime" | "boolean" | "singleChoice" | "multipleChoice" | "json" | "connection" | "trigger";
                /** @description Serialized form of the default value that the input will take */
                default_value?: string;
                /** @description Whether a value must be provided for this input */
                is_required?: boolean;
                /** @description If true then this input will not be shown to users when configuring this action */
                is_hidden?: boolean;
                advanced?: boolean;
                metadata?: string;
                /** @description The configured value of the Input */
                connection_type_id?: string;
            }[];
            /** @description Outputs whose values set during Action execution */
            readonly outputs?: {
                /** @description The name of the Output */
                name?: string;
                description?: string;
                /**
                 * @description The data type produced by this Output
                 * @enum {string}
                 */
                type?: "text" | "password" | "integer" | "decimal" | "date" | "dateTime" | "boolean" | "singleChoice" | "multipleChoice" | "json";
            }[];
        };
        IncidentWorkflowInstance: {
            readonly id?: string;
            /**
             * @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
             * @enum {string}
             */
            readonly type?: "incident_workflow_instance";
            incident?: components["schemas"]["Reference"];
        };
        IncidentWorkflowTriggerInstance: components["schemas"]["Tag"] & {
            /** @enum {string} */
            type?: "incident_workflow_instance";
            /** @description A descriptive name for the Incident Workflow Instance */
            name?: string;
            /** @description A description of what the Incident Workflow does */
            description?: string;
            /**
             * @description The current status of the Incident Workflow Instance
             * @enum {string}
             */
            status?: "completed" | "running" | "queued";
            /**
             * Format: date-time
             * @description The timestamp this Incident Workflow started
             */
            readonly started_at?: string;
            /**
             * Format: date-time
             * @description The timestamp this Incident Workflow ended
             */
            readonly ended_at?: string;
            /** @description A reference to the Incident Workflow of which this is an instance */
            workflow?: {
                readonly id?: string;
                readonly name?: string | null;
                /**
                 * @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
                 * @enum {string}
                 */
                readonly type?: "workflow_reference";
                /**
                 * Format: url
                 * @description the API show URL at which the object is accessible
                 */
                readonly self?: string | null;
                /**
                 * Format: url
                 * @description a URL at which the entity is uniquely displayed in the Web app
                 */
                readonly html_url?: string | null;
            };
        };
        IncidentWorkflowActionInvocation: {
            id?: string;
            /** @enum {string} */
            type?: "action_invocation";
            /** @description Reference to the Action that was invoked */
            action_id?: string;
            inputs?: (components["schemas"]["IncidentWorkflowAction"]["allOf"]["1"]["inputs"]["items"] & {
                value?: string;
            })[];
            outputs?: (components["schemas"]["IncidentWorkflowAction"]["allOf"]["1"]["outputs"]["items"] & {
                value?: string;
            })[];
        };
        IncidentWorkflowTrigger: components["schemas"]["Tag"] & {
            /** @enum {string} */
            type?: "workflow_trigger";
            /** @description Human readable name for the trigger type */
            trigger_type_name?: string;
            /** @enum {string} */
            trigger_type?: "conditional" | "manual" | "incident_type";
            /**
             * @description A PCL condition string.
             *
             *     If specified, the trigger will execute when the condition is met on an incident.
             *
             *     If unspecified, the trigger will execute on incident creation.
             *
             *     Required if trigger_type is conditional, not allowed for other trigger types.
             */
            condition?: string;
            /** Format: url */
            trigger_url?: string;
            /** @description An optional array of Incident Types associated with the trigger when it is of type `incident_type`. */
            incident_types?: string[];
            /** @description Workflow to start when this trigger is invoked */
            workflow?: {
                id?: string;
                /**
                 * @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
                 * @enum {string}
                 */
                type?: "workflow_reference";
                /** @description A descriptive name for the Incident Workflow */
                name?: string;
                /**
                 * Format: url
                 * @description the API show URL at which the object is accessible
                 */
                self?: string | null;
                /**
                 * Format: url
                 * @description a URL at which the entity is uniquely displayed in the Web app
                 */
                html_url?: string | null;
            };
            /** @description An optional array of Services associated with this workflow. Incidents in any of the listed Services are eligible to fire this Trigger */
            services?: {
                id?: string;
                /** @description A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier. */
                summary?: string | null;
                /**
                 * @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference.
                 * @enum {string}
                 */
                type?: "service";
                /**
                 * Format: url
                 * @description the API show URL at which the object is accessible
                 */
                self?: string | null;
                /**
                 * Format: url
                 * @description a URL at which the entity is uniquely displayed in the Web app
                 */
                html_url?: string | null;
            }[];
            /** @description Indicates that the Trigger should be associated with All Services */
            is_subscribed_to_all_services?: boolean;
            /** @description An object detailing who can start this Trigger. Applicable only to manual Triggers. */
            permissions?: {
                /** @description If true, indicates that the Trigger can only be started by authorized Users. If false, any user can start this Trigger. Applicable only to manual Triggers. */
                restricted?: boolean;
                /** @description The ID of the team whose members can manually start this Trigger. Required and allowed if and only if permissions.restricted is true. */
                team_id?: string;
            };
            /**
             * @deprecated
             * @description Indicates whether the Trigger is disabled or not. Inherited from the "is_enabled" property on the workflow
             *     to which this trigger belongs. This attribute is deprecated, and will be removed in a future version of
             *     this API.
             */
            is_disabled?: boolean;
        };
        StatusUpdate: {
            id?: string;
            /** @description The message of the status update. */
            message?: string;
            /** @description The date/time when this status update was created. */
            created_at?: string;
            sender?: components["schemas"]["UserReference"];
            /** @description The subject of the custom html email status update. Present if included in request body. */
            subject?: string;
            /** @description The html content of the custom html email status update. Present if included in request body. */
            html_message?: string;
        };
        ResponderRequest: {
            incident?: components["schemas"]["IncidentReference"];
            requester?: components["schemas"]["UserReference"];
            /** @description The time the request was made */
            requested_at?: string;
            /** @description The message sent with the responder request */
            message?: string;
            /** @description The array of targets the responder request is being sent to */
            responder_request_targets?: components["schemas"]["ResponderRequestTargetReference"][];
        };
        ResponderRequestTargetReference: {
            /** @description The type of target (either a user or an escalation policy) */
            type?: string;
            /** @description The id of the user or escalation policy */
            id?: string;
            summary?: string;
            /** @description An array of responders associated with the specified incident */
            incident_responders?: components["schemas"]["IncidentsRespondersReference"][];
        };
        IncidentsRespondersReference: {
            /**
             * @description The status of the responder being added to the incident
             * @example pending
             */
            state?: string;
            user?: components["schemas"]["UserReference"];
            incident?: components["schemas"]["IncidentReference"];
            updated_at?: string;
            /** @description The message sent with the responder request */
            message?: string;
            requester?: components["schemas"]["UserReference"];
            requested_at?: string;
        };
        ConferenceBridge: {
            /** @description The phone number of the conference call for the conference bridge. Phone numbers should be formatted like +1 415-555-1212,,,,1234#, where a comma (,) represents a one-second wait and pound (#) completes access code input. */
            conference_number?: string;
            /**
             * Format: url
             * @description An URL for the conference bridge. This could be a link to a web conference or Slack channel.
             */
            conference_url?: string;
        };
        /** @description A message containing information about a single PagerDuty action. */
        Action: {
            /**
             * Format: uuid
             * @description Uniquely identifies this outgoing webhook message; can be used for idempotency when processing the messages.
             */
            readonly id?: string;
            /**
             * Format: date-time
             * @description The date/time when this message was was sent.
             */
            readonly triggered_at?: string;
            webhook?: components["schemas"]["Webhook"];
        };
        WebhookIncidentAction: components["schemas"]["Action"] & {
            /**
             * @description The type of action being reported by this message. * `incident.trigger` - Sent when an incident is newly created/triggered. * `incident.acknowledge` - Sent when an incident is acknowledged by a user. * `incident.unacknowledge` - Sent when an incident is unacknowledged due to its acknowledgement timing out. * `incident.resolve` - Sent when an incident has been resolved. * `incident.assign` - Sent when an incident has been assigned to another user. Often occurs in concert with an `acknowledge`. * `incident.escalate` - Sent when an incident has been escalated to another user in the same escalation chain. * `incident.delegate` - Sent when an incident has been reassigned to another escalation policy. * `incident.annotate` - Sent when a note is created on an incident.
             * @enum {string}
             */
            type?: "incident.trigger" | "incident.acknowledge" | "incident.unacknowledge" | "incident.resolve" | "incident.assign" | "incident.escalate" | "incident.delegate" | "incident.annotate";
            incident?: components["schemas"]["Incident"];
            /** @description Log Entries that correspond to the action this Webhook is reporting. Includes the channels. */
            log_entries?: (components["schemas"]["AcknowledgeLogEntry"] | components["schemas"]["AnnotateLogEntry"] | components["schemas"]["AssignLogEntry"] | components["schemas"]["DelegateLogEntry"] | components["schemas"]["EscalateLogEntry"] | components["schemas"]["ExhaustEscalationPathLogEntry"] | components["schemas"]["NotifyLogEntry"] | components["schemas"]["ReachAckLimitLogEntry"] | components["schemas"]["ReachTriggerLimitLogEntry"] | components["schemas"]["RepeatEscalationPathLogEntry"] | components["schemas"]["ResolveLogEntry"] | components["schemas"]["SnoozeLogEntry"] | components["schemas"]["TriggerLogEntry"] | components["schemas"]["UnacknowledgeLogEntry"] | components["schemas"]["UrgencyChangeLogEntry"])[];
        };
        WebhookObject: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "service" | "service_reference";
        };
        /**
         * @description Information about the configured webhook.
         * @example {
         *       "id": "PPGPXHO",
         *       "type": "webhook",
         *       "summary": "webhook",
         *       "name": "My Webhook",
         *       "endpoint_url": "https://example.com",
         *       "webhook_object": {
         *         "id": "PNTDJ30",
         *         "type": "service_reference"
         *       },
         *       "config": {
         *         "anykey": "anyvalue"
         *       },
         *       "outbound_integration": {
         *         "id": "PJFWPEP",
         *         "type": "outbound_integration_reference"
         *       }
         *     }
         */
        Webhook: {
            /**
             * Format: url
             * @description The url endpoint the webhook payload is sent to.
             */
            endpoint_url?: string;
            /** @description The name of the webhook. */
            name?: string;
            webhook_object?: components["schemas"]["WebhookObject"];
            /** @description The object that contains webhook configuration values depending on the webhook type specification. */
            config?: Record<string, never>;
            outbound_integration?: components["schemas"]["OutboundIntegrationReference"];
        };
        WebhookReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "webhook_reference";
        };
        OutboundIntegrationReference: Omit<components["schemas"]["Reference"], 'type'> & {
            /** @enum {string} */
            type?: "outbound_integration_reference";
        };
        WebhookSubscription: {
            readonly id?: string;
            /**
             * @description The type indicating the schema of the object.
             * @default webhook_subscription
             * @enum {string}
             */
            type: "webhook_subscription";
            /**
             * @description Determines whether this subscription will produce webhook events.
             * @default true
             */
            active: boolean;
            delivery_method: {
                readonly id?: string;
                /** @description The secret used to sign webhook payloads. Only provided on the initial create response. */
                readonly secret?: string | null;
                /** @description Whether or not this webhook subscription is temporarily disabled. Becomes `true` if the delivery method URL is repeatedly rejected by the server. */
                temporarily_disabled?: boolean;
                /**
                 * @description Indicates the type of the delivery method.
                 * @default http_delivery_method
                 * @enum {string}
                 */
                type: "http_delivery_method";
                /**
                 * Format: url
                 * @description The destination URL for webhook delivery.
                 */
                url: string;
                /** @description Optional headers to be set on this webhook subscription when sent. The header values are redacted in GET requests, but are not redacted on the webhook when delivered to the webhook's endpoint. */
                custom_headers?: {
                    /** @description The header name */
                    name?: string;
                    /** @description The header value */
                    value?: string;
                }[];
            };
            /** @description A short description of the webhook subscription. */
            description?: string;
            /** @description The set of outbound event types the webhook will receive. */
            events: string[];
            filter: {
                /** @description The id of the object being used as the filter.  This field is required for all filter types except account_reference. */
                id?: string;
                /**
                 * @description The type of object being used as the filter.
                 * @enum {string}
                 */
                type: "account_reference" | "service_reference" | "team_reference";
            };
            /** @description OAuth client details. This field is populated in responses when oauth_client_id is set. */
            readonly oauth_client?: {
                /**
                 * @description The ID of the OAuth client
                 * @example AGMEB7F7YJYELCPG4Y5YWMYGXE
                 */
                id: string;
                /**
                 * @description The type of object being referenced
                 * @default oauth_client_reference
                 * @example oauth_client_reference
                 * @enum {string}
                 */
                type: "oauth_client_reference";
                /**
                 * @description A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client
                 * @example PagerDuty Webhook Integration
                 */
                readonly summary?: string;
            };
        };
        WebhookSubscriptionUpdate: {
            webhook_subscription?: {
                /** @description A short description of the webhook subscription. */
                description?: string;
                /** @description The set of outbound event types the subscription will receive. */
                events?: string[];
                filter?: {
                    /** @description The id of the object being used as the filter.  This field is required for all filter types except account_reference. */
                    id?: string;
                    /**
                     * @description The type of object being used as the filter.
                     * @enum {string}
                     */
                    type?: "account_reference" | "service_reference" | "team_reference";
                };
                /** @description If true, a webhook will be sent. True is the default state. If false, a webhook will not be sent. */
                active?: boolean;
                /** @description The ID of the OAuth client to use for authenticating webhook requests. Optional field. */
                oauth_client_id?: string | null;
            };
        };
        OAuthClient: {
            /**
             * @description The ID of the OAuth client
             * @example AGMEB7F7YJYELCPG4Y5YWMYGXE
             */
            readonly id?: string;
            /**
             * @description The type of object being created
             * @default oauth_client
             * @example oauth_client
             * @enum {string}
             */
            type: "oauth_client";
            /**
             * @description A human-readable name for the OAuth client
             * @example PagerDuty Webhook Integration
             */
            name: string;
            /**
             * @description The OAuth client ID provided by the OAuth server
             * @example oauth-client-id
             */
            client_id: string;
            /**
             * @description The OAuth scopes requested for this client
             * @example read write
             */
            scope?: string | null;
            /**
             * Format: uri
             * @description The OAuth token endpoint URL
             * @example https://foo.oauth-server.com/oauth_token.do
             */
            token_url: string;
            /**
             * @description The OAuth grant type (currently only client_credentials is supported)
             * @example client_credentials
             * @enum {string}
             */
            grant_type: "client_credentials";
            /**
             * @description The current status of the OAuth client
             * @example active
             * @enum {string}
             */
            readonly status?: "active" | "error";
        };
        CreateOAuthClientRequest: {
            oauth_client: {
                /**
                 * @description A human-readable name for the OAuth client
                 * @example PagerDuty Webhook Integration
                 */
                name: string;
                /**
                 * @description The OAuth client ID provided by the OAuth server
                 * @example oauth-client-id
                 */
                client_id: string;
                /**
                 * @description The OAuth client secret provided by the OAuth server
                 * @example oauth-secret-id
                 */
                client_secret: string;
                /**
                 * @description The OAuth scopes requested for this client
                 * @example read write
                 */
                scope?: string;
                /**
                 * Format: uri
                 * @description The OAuth token endpoint URL
                 * @example https://foo.oauth-server.com/oauth_token.do
                 */
                token_url: string;
                /**
                 * @description The OAuth grant type (currently only client_credentials is supported)
                 * @example client_credentials
                 * @enum {string}
                 */
                grant_type: "client_credentials";
            };
        };
        UpdateOAuthClientRequest: {
            oauth_client: {
                /**
                 * @description A human-readable name for the OAuth client
                 * @example Updated ServiceNow Integration
                 */
                name?: string;
                /**
                 * @description The OAuth client ID provided by the OAuth server
                 * @example oauth-client-id
                 */
                client_id?: string;
                /**
                 * @description The OAuth client secret provided by the OAuth server
                 * @example oauth-secret-id
                 */
                client_secret?: string;
                /**
                 * @description The OAuth scopes requested for this client
                 * @example read write admin
                 */
                scope?: string;
                /**
                 * Format: uri
                 * @description The OAuth token endpoint URL
                 * @example https://foo.oauth-server.com/oauth_token.do
                 */
                token_url?: string;
                /**
                 * @description The OAuth grant type (currently only client_credentials is supported)
                 * @example client_credentials
                 * @enum {string}
                 */
                grant_type?: "client_credentials";
            };
        };
        /** @description A message containing information about a single PagerDuty action. */
        WebhooksV1Message: {
            /**
             * Format: uuid
             * @description Uniquely identifies this outgoing webhook message; can be used for idempotency when processing the messages.
             */
            readonly id?: string;
            /**
             * @description The type of action being reported by this message.
             * @enum {string}
             */
            readonly type?: "incident.trigger" | "incident.acknowledge" | "incident.unacknowledge" | "incident.resolve" | "incident.assign" | "incident.escalate" | "incident.delegate";
            /**
             * Format: date-time
             * @description The date/time when the incident changed state.
             */
            readonly created_on?: string;
            data?: {
                incident?: components["schemas"]["WebhooksV1IncidentData"];
            };
        };
        /** @description The incident details at the time of the state change. */
        WebhooksV1IncidentData: {
            readonly id?: string;
            /** @description The number of the incident. This is unique across the account. */
            readonly incident_number?: number;
            /**
             * Format: date-time
             * @description The date/time the incident was first triggered.
             */
            readonly created_on?: string;
            /**
             * @description The current status of the incident.
             * @enum {string}
             */
            readonly status?: "triggered" | "acknowledged" | "resolved";
            /** Format: url */
            readonly html_url?: string;
            /** @description The incident's de-duplication key. */
            readonly incident_key?: string;
            service?: components["schemas"]["WebhooksV1Service"];
            assigned_to_user?: components["schemas"]["WebhooksV1AssignedToUser"];
            readonly assigned_to?: components["schemas"]["WebhooksV1AssignedTo"][];
            readonly trigger_summary_data?: {
                readonly subject?: string;
            };
            /** Format: url */
            readonly trigger_details_html_url?: string;
            /**
             * Format: date-time
             * @description The time at which the status of the incident last changed.
             */
            readonly last_status_change_on?: string;
            last_status_change_by?: components["schemas"]["WebhooksV1AssignedToUser"];
            /** @description Number of times the incident has been escalated. */
            readonly number_of_escalations?: number;
            /** @enum {string} */
            readonly urgency?: "high" | "low";
        };
        /** @description The service on which the incident occurred. */
        WebhooksV1Service: {
            readonly id?: string;
            /** @description The name of the service. */
            readonly name?: string;
            /** Format: url */
            readonly html_url?: string;
            /**
             * Format: date-time
             * @description The date/time the service was deleted, if it has been removed.
             */
            readonly deleted_at?: string;
            /** @description The description of the service. */
            readonly description?: string;
        };
        WebhooksV1AssignedTo: {
            /**
             * Format: date-time
             * @description Time at which the assignment was created.
             */
            at?: string;
            object?: components["schemas"]["WebhooksV1AssignedToUser"] & {
                /** @enum {string} */
                type?: "user";
            };
        };
        /** @description The user assigned to the incident. */
        WebhooksV1AssignedToUser: {
            readonly id?: string;
            /** @description The user's name. */
            readonly name?: string;
            /**
             * Format: email
             * @description The user's email address.
             */
            readonly email?: string;
            /** Format: url */
            readonly html_url?: string;
        };
        /**
         * NotificationSubscriber
         * @description A reference of a subscriber entity.
         * @example {
         *       "subscriber_id": "PD1234",
         *       "subscriber_type": "user"
         *     }
         */
        NotificationSubscriber: {
            /** @description The ID of the entity being subscribed */
            subscriber_id?: string;
            /**
             * @description The type of the entity being subscribed
             * @enum {string}
             */
            subscriber_type?: "user" | "team";
        };
        /**
         * NotificationSubscriberWithContext
         * @description A reference of a subscriber entity with additional subscription context.
         * @example {
         *       "subscriber_id": "PD1234",
         *       "subscriber_type": "user"
         *     }
         */
        NotificationSubscriberWithContext: {
            /** @description The ID of the entity being subscribed */
            subscriber_id?: string;
            /**
             * @description The type of the entity being subscribed
             * @enum {string}
             */
            subscriber_type?: "user" | "team";
            /** @description If this subcriber has an indirect subscription to this incident via another object */
            has_indirect_subscription?: boolean;
            subscribed_via?: {
                /** @description The id of the object this subscriber is subscribed via */
                id?: string;
                /** @description The type of the object this subscriber is subscribed via */
                name?: string;
            }[] | null;
        };
        /**
         * NotificationSubscribable
         * @description A reference of a subscribable entity.
         * @example {
         *       "subscribable_id": "PD1234",
         *       "subscribable_type": "incident"
         *     }
         */
        NotificationSubscribable: {
            /** @description The ID of the entity to subscribe to */
            subscribable_id?: string;
            /**
             * @description The type of the entity being subscribed to
             * @enum {string}
             */
            subscribable_type?: "incident" | "business_service";
        };
        /**
         * NotificationSubscription
         * @description An object describing the relationship of a NotificationSubscriber and a NotificationSubscribable.
         */
        NotificationSubscription: {
            /** @description The ID of the entity being subscribed */
            subscriber_id?: string;
            /**
             * @description The type of the entity being subscribed
             * @enum {string}
             */
            subscriber_type?: "user" | "team";
            /** @description The ID of the entity being subscribed to */
            subscribable_id?: string;
            /**
             * @description The type of the entity being subscribed to
             * @enum {string}
             */
            subscribable_type?: "incident" | "business_service";
            /** @description The ID of the account belonging to the subscriber entity */
            account_id?: string;
        };
        /**
         * NotificationSubscriptionWithContext
         * @description An object describing the relationship of a NotificationSubscriber and a NotificationSubscribable with additional context on status of subscription attempt.
         */
        NotificationSubscriptionWithContext: {
            /** @description The ID of the entity being subscribed */
            subscriber_id?: string;
            /**
             * @description The type of the entity being subscribed
             * @enum {string}
             */
            subscriber_type?: "user" | "team";
            /** @description The ID of the entity being subscribed to */
            subscribable_id?: string;
            /**
             * @description The type of the entity being subscribed to
             * @enum {string}
             */
            subscribable_type?: "incident" | "business_service";
            /** @description The type of the entity being subscribed to */
            account_id?: string;
            /**
             * @description The resulting status of the subscription
             * @enum {string}
             */
            result?: "success" | "duplicate" | "unauthorized";
        };
        /** @description Defines how alerts will be automatically grouped into incidents based on the configurations defined. Note that the Alert Grouping Setting features are available only on certain plans. */
        AlertGroupingSetting: {
            readonly id?: string;
            /** @description An optional short-form string that provides succinct information about an AlertGroupingSetting object suitable for primary labeling of the entity. It is not intended to be an identifier. */
            name?: string | null;
            /** @description An optional description in string that provides more information about an AlertGroupingSetting object. */
            description?: string | null;
            /** @enum {string} */
            type?: "content_based" | "content_based_intelligent" | "intelligent" | "time";
            config?: components["schemas"]["ContentBasedAlertGroupingConfiguration"] | components["schemas"]["ContentBasedIntelligentAlertGroupingConfiguration"] | {
                /** @description The duration in seconds within which to automatically group incoming Alerts. To continue grouping Alerts until the Incident is resolved, set this value to 0. */
                timeout?: number;
            } | {
                /** @description The maximum amount of time allowed between Alerts. Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window up to 24 hours and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours (24 hours only applies to single-service settings). To use the "recommended_time_window," set the value to 0, otherwise the value must be between 300 <= time_window <= 3600. */
                time_window?: number;
                /** @description In order to ensure your Service has the optimal grouping window, we use data science to calculate your Service's average Alert inter-arrival time. We encourage customer's to use this value, please set `time_window` to 0 to use the `recommended_time_window`. */
                readonly recommended_time_window?: number;
                /**
                 * @description An array of strings which represent the iag fields with which to intelligently group against.
                 * @default [
                 *       "summary"
                 *     ]
                 */
                iag_fields: string[];
            };
            /** @description The array of one or many Services with just ServiceID/name that the AlertGroupingSetting applies to. Type of content_based_intelligent allows for only one service in the array. */
            services?: components["schemas"]["ServiceReference"][];
            /**
             * Format: date-time
             * @description The ISO8601 date/time an AlertGroupingSetting got created at.
             */
            readonly created_at?: string;
            /**
             * Format: date-time
             * @description The ISO8601 date/time an AlertGroupingSetting last got updated at.
             */
            readonly updated_at?: string;
        };
        /**
         * Alert Grouping Parameters
         * @deprecated
         * @description Defines how alerts on this service will be automatically grouped into incidents. Note that the alert grouping features are available only on certain plans. To turn grouping off set the type to null.
         *     This attribute has been deprecated and configuration via [Alert Grouping Settings](https://developer.pagerduty.com/api-reference/587edbc8ff416-create-an-alert-grouping-setting) resource is encouraged.
         */
        AlertGroupingParameters: {
            /** @enum {string|null} */
            type?: "time" | "intelligent" | "content_based" | null;
            config?: components["schemas"]["FlexibleTimeWindowIntelligentAlertGroupingConfig"] | components["schemas"]["TimeBasedAlertGroupingConfiguration"] | components["schemas"]["ContentBasedAlertGroupingConfiguration"];
        };
        /**
         * Content Only Grouping
         * @description The configuration for Content Based Alert Grouping
         */
        ContentBasedAlertGroupingConfiguration: {
            /**
             * @description Whether Alerts should be grouped if `all` or `any` specified fields match. If `all` is selected, an exact match on every specified field name must occur for Alerts to be grouped. If `any` is selected, Alerts will be grouped when there is an exact match on at least one of the specified fields.
             * @enum {string}
             */
            aggregate?: "all, any";
            /** @description An array of strings which represent the fields with which to group against. Depending on the aggregate, Alerts will group if some or all the fields match. */
            fields?: string[];
            /** @description The maximum amount of time allowed between Alerts. Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window up to 24 hours and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours (24 hours only applies to single-service settings). To use the "recommended_time_window," set the value to 0, otherwise the value must be between 300 <= time_window <= 3600 or 86400(i.e. 24 hours). */
            time_window?: number;
            /** @description In order to ensure your Service has the optimal grouping window, we use data science to calculate your Service's average Alert inter-arrival time. We encourage customer's to use this value, please set `time_window` to 0 to use the `recommended_time_window`. */
            readonly recommended_time_window?: number;
        };
        /**
         * Time Grouping
         * @description The configuration for Time Based Alert Grouping
         */
        TimeBasedAlertGroupingConfiguration: {
            /** @description The duration in minutes within which to automatically group incoming Alerts. To continue grouping Alerts until the Incident is resolved, set this value to 0. */
            timeout?: number;
        };
        RelatedIncidentServiceDependencyBase: {
            /** @description The ID of the Service referenced. */
            readonly id?: string;
            /**
             * @description The type of the related Service.
             * @enum {string}
             */
            type?: "business_service_reference" | "technical_service_reference";
            /**
             * Format: url
             * @description The API show URL at which the object is accessible.
             */
            readonly self?: string | null;
        };
        /** @description The data for a type of relationship where the Incident is related due to our machine learning algorithm. */
        RelatedIncidentMachineLearningRelationship: {
            /**
             * @description The classification for why this Related Incident was grouped into this group.
             *     Values can be one of: [similar_contents, prior_feedback], where:
             *     similar_contents - The Related Incident was due to similar contents of the Incidents.
             *     prior_feedback - The Related Incident was determined to be related, based on User feedback or Incident merge/unmerge actions.
             * @enum {string}
             */
            grouping_classification?: "similar_contents" | "prior_feedback";
            /** @description The feedback provided from Users to influence the machine learning algorithm for future Related Incidents. */
            user_feedback?: {
                /** @description The total number of times Users agreed that the Incidents are related. */
                positive_feedback_count?: number;
                /** @description The total number of times Users disagreed that the Incidents are related. */
                negative_feedback_count?: number;
            };
        };
        /**
         * @description The data for a type of relationship where the Incident is related due to Business or Technical Service dependencies.
         *
         *     Both `dependent_services` and `supporting_services` are returned to signify the dependencies between the Services
         *     that the Incident and Related Incident belong to.
         *
         *     Each Service reference returned in the list of supporting and dependent Services has a type of:
         *     [business_service_reference, technical_service_reference].
         */
        RelatedIncidentServiceDependencyRelationship: {
            dependent_services?: components["schemas"]["RelatedIncidentServiceDependencyBase"][];
            supporting_services?: components["schemas"]["RelatedIncidentServiceDependencyBase"][];
        };
        EmailParser: {
            /** @enum {string} */
            action: "trigger" | "resolve";
            match_predicate: components["schemas"]["MatchPredicate"];
            /** @description Additional values that will be pulled in to the Incident object. Exactly one value extractor must have a `value_name` of `incident_key`. */
            value_extractors?: {
                /** @enum {string} */
                type: "entire" | "regex" | "between";
                /** @enum {string} */
                part: "body" | "subject" | "from_addresses";
                /** @description The field name to set in the Incident object. Exactly one must use the `value_name` of `incident_key` */
                value_name: string;
                regex?: string;
                starts_after?: string;
                ends_with?: string;
            }[];
        };
        MatchPredicate: {
            /** @enum {string} */
            type: "all" | "any" | "not" | "contains" | "exactly" | "regex";
            /** @description Required if the type is `contains`, `exactly` or `regex`. */
            matcher?: string;
            /**
             * @description The email field that will attempt to use the matcher expression. Required if the type is `contains`, `exactly` or `regex`.
             * @enum {string}
             */
            part: "body" | "subject" | "from_addresses";
            /** @description Additional matchers to be run. Must be not empty if the type is `all`, `any`, or `not`. */
            children: components["schemas"]["MatchPredicate"][];
        };
        /**
         * @description A rule for contacting the user for Handoff Notifications.
         * @example {
         *       "id": "PXPGF42",
         *       "notify_advance_in_minutes": 180,
         *       "handoff_type": "both",
         *       "contact_method": {
         *         "id": "PXPGF42",
         *         "type": "email_contact_method_reference"
         *       }
         *     }
         */
        HandoffNotificationRule: {
            readonly id: string;
            /** @description The delay before firing the rule, in minutes. */
            notify_advance_in_minutes?: number;
            /**
             * @description The type of handoff being created.
             * @default both
             * @enum {string}
             */
            handoff_type: "both" | "oncall" | "offcall";
            contact_method: components["schemas"]["ContactMethodReference"];
        };
        Orchestration: {
            /** @description ID of the Orchestration. */
            readonly id?: string;
            /**
             * Format: url
             * @description The API show URL at which the object is accessible
             */
            readonly self?: string;
            /** @description Name of the Orchestration. */
            name?: string;
            /** @description A description of this Orchestration's purpose. */
            description?: string;
            /** @description Reference to the team that owns the Orchestration. If none is specified, only admins have access. */
            team?: {
                id?: string;
                /** @description A string that determines the schema of the object */
                readonly type?: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible
                 */
                readonly self?: string;
            };
            readonly integrations?: components["schemas"]["OrchestrationIntegration"][];
            /** @description Number of different Service Orchestration being routed to */
            readonly routes?: number;
            /**
             * Format: date-time
             * @description The date the Orchestration was created at.
             */
            readonly created_at?: string;
            /** @description Reference to the user that has created the Orchestration. */
            readonly created_by?: {
                readonly id?: string;
                /** @description A string that determines the schema of the object */
                readonly type?: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible
                 */
                readonly self?: string;
            };
            /**
             * Format: date-time
             * @description The date the Orchestration was last updated.
             */
            readonly updated_at?: string;
            /** @description Reference to the user that has updated the Orchestration last. */
            readonly updated_by?: {
                readonly id?: string;
                /** @description A string that determines the schema of the object */
                readonly type?: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible
                 */
                readonly self?: string;
            };
            /** @description Version of the Orchestration. */
            readonly version?: string;
        };
        /** Trigger Event Count */
        OrchestrationCacheVariableTriggerEventCount: components["schemas"]["OrchestrationCacheVariableRecentValue"]["allOf"]["0"] & {
            configuration?: {
                /**
                 * @description Cache Variable will be set to the number of trigger events that have been seen within the TTL range
                 * @enum {string}
                 */
                type?: "trigger_event_count";
                /** @description The time to live (in seconds) for how long to count trigger events before resetting back to 0. */
                ttl_seconds?: number;
            };
            /**
             * @description Each of these conditions is evaluated to check if an event matches this rule.
             *     The rule is considered a match if **any** of these conditions match.
             */
            conditions?: {
                /**
                 * @description A PCL condition string.
                 *
                 *     Note: The `trigger_count` and `resetting_trigger_count` operators are unsupported for Cache Variables
                 * @example event.summary matches part 'my service error'
                 */
                expression?: string;
            }[];
        };
        /** Recent Value */
        OrchestrationCacheVariableRecentValue: {
            readonly id?: string;
            /** @description The name of the Cache Variable */
            name: string;
            /** @description Indicates whether the Cache Variable is disabled and would therefore not be evaluated. */
            disabled?: boolean;
            /**
             * Format: date-time
             * @description The date/time the object was created.
             */
            readonly created_at?: string;
            /** @description Reference to the user that created the object. */
            readonly created_by?: {
                readonly id?: string;
                /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
                readonly type?: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible
                 */
                readonly self?: string;
            };
            /**
             * Format: date-time
             * @description The date/time the object was last updated.
             */
            readonly updated_at?: string;
            /** @description Reference to the user that last updated the object. */
            readonly updated_by?: {
                readonly id?: string;
                /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
                readonly type?: string;
                /**
                 * Format: url
                 * @description The API show URL at which the object is accessible
                 */
                readonly self?: string;
            };
        } & {
            configuration?: {
                /**
                 * @description Cache Variable will be set to the most recent value seen, based on the source event field and the extraction regex specified
                 * @enum {string}
                 */
                type?: "recent_value";
                /**
                 * @description The path to the event field where the regex will be applied to extract a value.
                 * @example event.summary
                 */
                source?: string;
                /** @description A RE2 regular expression. If it contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. */
                regex?: string;
            };
            /**
             * @description Each of these conditions is evaluated to check if an event matches this rule.
             *     The rule is considered a match if **any** of these conditions match.
             */
            conditions?: {
                /**
                 * @description A PCL condition string.
                 *
                 *     Note: The `trigger_count` and `resetting_trigger_count` operators are unsupported for Cache Variables
                 * @example event.summary matches part 'my service error'
                 */
                expression?: string;
            }[];
        };
        /** External Data */
        OrchestrationCacheVariableExternalData: components["schemas"]["OrchestrationCacheVariableRecentValue"]["allOf"]["0"] & {
            configuration?: {
                /**
                 * @description The Cache Variable value will be set via a PUT API request to a dedicated endpoint that is made available after the creation of the cache variable.
                 * @enum {string}
                 */
                type?: "external_data";
                /**
                 * @description The type of data that will eventually be set for this cache variable via an API request.
                 * @enum {string}
                 */
                data_type?: "string" | "number" | "boolean";
                /** @description The time to live (in seconds) for how long data sent to endpoint is persisted. After the TTL passes the data is deleted. */
                ttl_seconds?: number;
            };
            /**
             * Format: uri
             * @description The endpoint that can be used to manage the data for an `external_data` type cache variable
             */
            readonly data_endpoint?: string;
        };
        OrchestrationIntegration: {
            /** @description ID of the Integration. */
            readonly id?: string;
            /** @description Name of the Integration. */
            label?: string;
            readonly parameters?: {
                /** @description Routing Key used to send Events to this Orchestration */
                readonly routing_key?: string;
                /** @default global */
                readonly type?: string;
            };
        };
        OrchestrationGlobal: {
            orchestration_path: {
                /** @default service */
                readonly type: string;
                readonly parent?: {
                    /** @description ID of the object these Orchestration Rules belongs to. */
                    readonly id?: string;
                    /** @description A string that determines the schema of the parent object */
                    readonly type?: string;
                    /**
                     * Format: url
                     * @description The API show URL at which the parent object is accessible
                     */
                    readonly self?: string;
                };
                /** @description Must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph of rules. */
                sets?: {
                    /**
                     * @description The ID of this set of rules. Rules in other sets can route events into this set using the "route_to" properties.
                     * @default start
                     */
                    id: string;
                    rules?: {
                        /** @description ID of the rule */
                        readonly id?: string;
                        /** @description A description of this rule's purpose. */
                        label?: string;
                        /** @description Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if **any** of these conditions match. */
                        conditions?: {
                            /**
                             * @description A PCL condition string
                             * @example event.summary matches part 'my service error'
                             */
                            expression?: string;
                        }[];
                        /** @description When an event matches this rule, these are the actions that will be taken to change the resulting alert and incident. */
                        actions?: Record<string, never>;
                        /** @description Indicates whether the rule is disabled and would therefore not be evaluated. */
                        disabled?: boolean;
                    }[];
                }[];
                /** @description When none of the Rules in a set match an event, we apply the catch_all actions to the event. */
                catch_all?: {
                    /** @description These are the actions that will be taken to change the resulting alert and incident. */
                    actions?: Record<string, never>;
                };
                /**
                 * Format: date-time
                 * @description The date/time the object was created.
                 */
                readonly created_at?: string;
                /** @description Reference to the user that created the object. */
                readonly created_by?: {
                    readonly id?: string;
                    /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
                    readonly type?: string;
                    /**
                     * Format: url
                     * @description The API show URL at which the object is accessible
                     */
                    readonly self?: string;
                };
                /**
                 * Format: date-time
                 * @description The date/time the object was last updated.
                 */
                readonly updated_at?: string;
                /** @description Reference to the user that last updated the object. */
                readonly updated_by?: {
                    readonly id?: string;
                    /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
                    readonly type?: string;
                    /**
                     * Format: url
                     * @description The API show URL at which the object is accessible
                     */
                    readonly self?: string;
                };
                /** @description Version of these Orchestration Rules */
                readonly version?: string;
            };
        } & {
            orchestration_path?: {
                /**
                 * @description Indicates that these are a set of "global" rules.
                 * @default global
                 */
                type: unknown;
                parent?: {
                    /** @description ID of the Global Event Orchestration these Global Rules belongs to. */
                    id?: unknown;
                    /** @enum {unknown} */
                    type?: "event_orchestration_reference";
                };
                /** @description You must define at least a "start" set, but you can also define any number of additional sets that are routed to by other rules to form a directional graph. */
                sets?: unknown;
                /** @description When none of the rules match an event, the event will be routed according to the catch_all settings. */
                catch_all?: {
                    actions?: {
                        /** @description If true, the resulting alert is suppressed. Suppressed alerts will not trigger an incident. */
                        suppress?: boolean;
                        /** @description The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a resolve event arrives before the alert triggers then PagerDuty won't create an incident for this the resulting alert. */
                        suspend?: number;
                        /** @description If true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules. */
                        drop_event?: boolean;
                    } & {
                        /**
                         * @description The ID of the priority you want to set on resulting incident. You can find the list of priority IDs for your account by calling the priorities endpoint.
                         * @example P53ZZH5
                         */
                        priority?: string;
                        /**
                         * @description The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
                         * @example PQOMK4S
                         */
                        escalation_policy?: string;
                        /** @description Add this text as a note on the resulting incident. AIOps users can additionally use the {{event}} variable to include elements of the event payload in the note. */
                        annotate?: string;
                    } & components["schemas"]["OrchestrationUnrouted"]["allOf"]["1"]["orchestration_path"]["catch_all"]["actions"] & {
                        /** @description Create a Webhoook associated with the resulting incident. */
                        automation_actions?: {
                            /** @description The name of the Webhook. */
                            name?: string;
                            /** @description The API endpoint where PagerDuty's servers will send the webhook request. */
                            url?: string;
                            /**
                             * @description When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website & mobile app.
                             * @default false
                             */
                            auto_send: boolean;
                            /** @description Specify custom key/value pairs that'll be sent with the webhook request as request headers. */
                            headers?: {
                                key?: string;
                                /** @description AIOps users can additionally use the {{event}} variable to include elements of the event payload in the header value. */
                                value?: string;
                            }[];
                            /**
                             * @description The Webhook will be associated (or automatically triggered, if `auto_send` is `true`) with the incident, whenever an alert reaches the specified state
                             *
                             *     Note: `auto_send` must be `true` for trigger types of `alert_suppressed` and `alert_suspended`
                             */
                            trigger_types?: ("alert_triggered" | "alert_suppressed" | "alert_suspended")[];
                            /** @description Specify custom key/value pairs that'll be included in the webhook request's JSON payload. */
                            parameters?: {
                                key?: string;
                                /** @description AIOps users can additionally use the {{event}} variable to include elements of the event payload in the parameter value. */
                                value?: string;
                            }[];
                        }[];
                    } & {
                        /** @description Configure custom field updates for the incident. */
                        incident_custom_field_updates?: {
                            /**
                             * @description Unique identifier for the custom field resource. You can find the list of IDs by calling the List Custom Fields endpoint.
                             * @example PEXCK89
                             */
                            id?: string;
                            /**
                             * @description A value that will be used to populate the specified Incident Custom Field. AIOps users can additionally use the {{event}} variable to include elements of the event payload in the custom field value.
                             * @example High CPU on server
                             */
                            value?: string;
                        }[];
                    };
                };
            };
        };
        OrchestrationRouter: components["schemas"]["OrchestrationGlobal"]["allOf"]["0"] & {
            orchestration_path?: {
                /**
                 * @description Indicates that these are a "router" type set of rules.
                 * @default router
                 */
                type: unknown;
                parent?: {
                    /** @description ID of the Global Event Orchestration this Router belongs to. */
                    id?: unknown;
                    /** @enum {unknown} */
                    type?: "event_orchestration_reference";
                };
                /** @description The Router contains a single set of rules (the "start" set). The Router evaluates Events against these Rules, one at a time, and routes each Event to a specific Service based on the first rule that matches. */
                sets?: unknown;
                /** @description When none of the rules match an event, the event will be routed according to the catch_all settings. */
                catch_all?: {
                    actions?: {
                        /**
                         * @description With a value of 'unrouted', all events are sent to the Unrouted Orchestration.
                         * @default unrouted
                         */
                        route_to: string;
                    };
                };
            };
        };
        OrchestrationUnrouted: components["schemas"]["OrchestrationGlobal"]["allOf"]["0"] & {
            orchestration_path?: {
                /**
                 * @description Indicates that these are a "unrouted" type set of rules.
                 * @default unrouted
                 */
                type: unknown;
                parent?: {
                    /** @description ID of the Global Event Orchestration this Unrouted Orchestration belongs to. */
                    id?: unknown;
                    /** @enum {unknown} */
                    type?: "event_orchestration_reference";
                };
                /** @description An Unrouted Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph. */
                sets?: unknown;
                catch_all?: {
                    actions?: {
                        /**
                         * @description Set the severity of the resulting alert.
                         * @enum {string}
                         */
                        severity?: "info" | "error" | "warning" | "critical";
                        /**
                         * @description Set whether the resulting alert status is trigger or resolve.
                         * @enum {string}
                         */
                        event_action?: "trigger" | "resolve";
                        /** @description Populate variables from event payloads and use those variables in other event actions. */
                        variables?: {
                            /**
                             * @description The name of the variable
                             * @example server_name
                             */
                            name?: string;
                            /**
                             * @description Path to a field in an event, in dot-notation.
                             * @example event.summary
                             */
                            path?: string;
                            /**
                             * @description The type of operation to populate the variable. Currently only Regex-based variable extraction is supported.
                             * @enum {string}
                             */
                            type?: "regex";
                            /**
                             * @description A RE2 regular expression. If it contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used.
                             * @example High CPU on (.*) server
                             */
                            value?: string;
                        }[];
                        /** @description Dynamically extract values to set and modify new and existing PD-CEF fields. */
                        extractions?: ({
                            /**
                             * @description The PD-CEF field that will be set with the value from the template.
                             * @example event.summary
                             */
                            target?: string;
                            /**
                             * @description A value that will be used to populate the target PD-CEF field. You can include variables extracted from the payload by using string interpolation.
                             * @example High CPU on {{hostname}} server
                             */
                            template?: string;
                        } | {
                            /**
                             * @description The PD-CEF field that will be set with the value from the regex.
                             * @example event.custom_details.server
                             */
                            target?: string;
                            /**
                             * @description A RE2 regular expression. If it contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used.
                             * @example High CPU on (.*) server
                             */
                            regex?: string;
                            /**
                             * @description The path to the event field where the regex will be applied to extract a value.
                             * @example event.summary
                             */
                            source?: string;
                        })[];
                    };
                };
            };
        };
        ServiceOrchestration: components["schemas"]["OrchestrationGlobal"]["allOf"]["0"] & {
            orchestration_path?: {
                /**
                 * Format: date-time
                 * @description The date/time the service's Event Rules were converted to this Service Orchestration. This property is only included if the `migrated_metadata` query parameter is provided.
                 */
                readonly migrated_at?: string;
                /** @description Reference to the user that converted the service's Event Rules to this Service Orchestration. This property is only included if the `migrated_metadata` query parameter is provided. */
                readonly migrated_by?: {
                    readonly id?: string;
                    /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
                    readonly type?: string;
                    /**
                     * Format: url
                     * @description The API show URL at which the object is accessible
                     */
                    readonly self?: string;
                };
                /** @description Reference to the Service Event Rules that were converted to this Service Orchestration. This property is only included if the `migrated_metadata` query parameter is provided. */
                readonly migrated_from?: {
                    readonly id?: string;
                    /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
                    readonly type?: string;
                    /**
                     * Format: url
                     * @description The API show URL at which the object is accessible
                     */
                    readonly self?: string;
                };
                /**
                 * @description The status indicating whether the service's Event Rules were successfully converted to this Service Orchestration. This property is only included if the `migrated_metadata` query parameter is provided.
                 * @enum {string}
                 */
                readonly migrated_status?: "completed";
                /**
                 * @description Indicates whether the conversion was performed via the PagerDuty API or PagerDuty website. This property is only included if the `migrated_metadata` query parameter is provided.
                 * @enum {string}
                 */
                readonly migrated_via?: "API" | "UI";
            } & {
                /**
                 * @description Indicates that these are sets of rules belonging to a service.
                 * @default service
                 */
                type: unknown;
                parent?: {
                    /** @description The ID of the Service this Orchestration belongs to. */
                    id?: unknown;
                    /** @enum {unknown} */
                    type?: "service_reference";
                };
                /** @description A Service Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph. */
                sets?: unknown;
                catch_all?: {
                    actions?: {
                        /** @description If true, the resulting alert is suppressed. Suppressed alerts will not trigger an incident. */
                        suppress?: boolean;
                        /** @description The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a resolve event arrives before the alert triggers then PagerDuty won't create an incident for this the resulting alert. */
                        suspend?: number;
                    } & components["schemas"]["OrchestrationGlobal"]["allOf"]["1"]["orchestration_path"]["catch_all"]["actions"]["allOf"]["1"] & components["schemas"]["OrchestrationUnrouted"]["allOf"]["1"]["orchestration_path"]["catch_all"]["actions"] & {
                        /** @description Configure an Automation Action to be run for certain alert states. */
                        pagerduty_automation_actions?: {
                            /** @description Automation Action ID */
                            action_id?: string;
                            /** @description The Automation Action will be triggered whenever an alert reaches the specified state */
                            trigger_types?: ("alert_triggered" | "alert_suppressed" | "alert_suspended")[];
                        }[];
                    } & components["schemas"]["OrchestrationGlobal"]["allOf"]["1"]["orchestration_path"]["catch_all"]["actions"]["allOf"]["3"] & components["schemas"]["OrchestrationGlobal"]["allOf"]["1"]["orchestration_path"]["catch_all"]["actions"]["allOf"]["4"];
                };
            };
        };
        /** @description This rule is using a feature that is currently unavailable on the current account plan. */
        OrchestrationWarningIneligible: {
            /** @description A description of the warning and any potential side effects. */
            message?: string;
            /** @description The ID of the rule using the feature. */
            rule_id?: string;
            /**
             * @description The feature that the current account plan does not have access to.
             *
             *     Example values include:
             *     * `threshold_condition`
             *     * `nested_rules`
             *     * `suspend`
             *     * `automation_actions`
             *     * `cache_variable:automation_actions`
             *     * `cache_variable:annotate`
             *     * `variables`
             *     * `interpolation:annotate`
             *     * `interpolation:extractions`
             *     * `interpolation:incident_custom_field_updates`
             *     * `suppress`
             *     * `incident_custom_field_updates`
             *     * `dynamic_route_to`
             *     * `escalation_policy`
             *     * `aiops_routing_mismatch`
             */
            feature?: string;
            /**
             * @description Specifies whether the feature is a part of the rule's conditions, or its actions.
             *
             *     Example values include:
             *     * `conditions`
             *     * `actions`
             *     * `nested_rules`
             *     * `global_orchestrations`
             *     * `aiops_routing`
             */
            feature_type?: string;
            /**
             * @description The type of warning that is being returned for the rule.
             * @enum {string}
             */
            warning_type?: "forbidden_feature" | "invalid_routing";
        };
        /** @description This rule includes invalid data for a feature item. */
        OrchestrationWarningInvalidData: {
            /** @description A description of the warning and any potential side effects. */
            message?: string;
            /** @description The ID of the rule using the feature. */
            rule_id?: string;
            /**
             * @description The feature that includes invalid data.
             *
             *     Example values include:
             *       * `incident_custom_field_updates`
             *       * `escalation_policy`
             *       * `cache_variable:annotate`
             *       * `cache_variable:conditions`
             *       * `cache_variable:automation_actions`
             */
            feature?: string;
            /**
             * @description Specifies the feature type of the impacted item.
             *
             *     Example values include:
             *       * `actions`
             *       * `conditions`
             */
            feature_type?: string;
            /**
             * @description The type of warning that is being returned for the rule.
             * @enum {string}
             */
            warning_type?: "invalid_data";
        };
        Template: components["schemas"]["EditableTemplate"] & {
            readonly id?: string;
            /** @description A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `name`, though it is not intended to be an identifier. */
            readonly summary?: string | null;
            /**
             * Format: url
             * @description the API show URL at which the object is accessible
             */
            readonly self?: string | null;
            /**
             * Format: url
             * @description a URL at which the entity is uniquely displayed in the Web app
             */
            readonly html_url?: string | null;
            /** @enum {string} */
            type?: "template";
            /** @description User/Account object reference of the creator */
            created_by?: components["schemas"]["UserReference"] | (Omit<components["schemas"]["Reference"], 'type'> & {
                /** @enum {string} */
                type?: "account_reference";
            });
            /** @description User/Account object reference of the updator */
            updated_by?: components["schemas"]["UserReference"] | components["schemas"]["Template"]["allOf"]["1"]["created_by"]["oneOf"]["1"];
        };
        RenderedTemplate: {
            templated_fields?: {
                /** @description The rendered e-mail subject */
                email_subject?: string;
                /** @description The rendered e-mail body */
                email_body?: string;
                /** @description The rendered short message (SMS, Push, Slack, etc) */
                message?: string;
            };
            /**
             * @description List of render warnings messages for each rendered field.
             *     (Ex:  ["{{incident.invalid_field}} does not exist."])
             */
            warnings?: {
                /** @description List of warnings for email_subject */
                email_subject?: string[];
                /** @description List of warnings for email_body */
                email_body?: string[];
                /** @description List of warnings for message field */
                message?: string[];
            };
            /** @description List of errors */
            errors?: string[];
        };
        EditableTemplate: {
            /**
             * @description The type of template (`status_update` is the only supported template at this time)
             * @enum {string}
             */
            template_type?: "status_update";
            /** @description The name of the template */
            name?: string;
            /** @description Description of the template */
            description?: string | null;
            templated_fields?: {
                /** @description The subject of the e-mail */
                email_subject?: string | null;
                /** @description The HTML body of the e-mail message */
                email_body?: string | null;
                /**
                 * @description The short-message of the template (SMS, Push notification, Slack,
                 *     etc)
                 */
                message?: string | null;
            };
        };
        StatusUpdateTemplateInput: {
            /** @description The incident id to render the template for */
            incident_id?: string;
            status_update?: {
                /** @description An optional status update message that will be sent to the template */
                message?: string;
            };
            /** @description An optional object collection that can be referenced in the template. */
            external?: unknown;
        };
        CustomFieldsField: {
            /**
             * Format: date-time
             * @description The date/time the object was created at.
             */
            readonly created_at: string;
            data_type: components["schemas"]["CustomFieldsFieldValue"]["data_type"];
            default_value?: components["schemas"]["IncidentTypeCustomFields"]["default_value"];
            description?: components["schemas"]["CustomFieldsFieldValue"]["description"];
            display_name: components["schemas"]["CustomFieldsFieldValue"]["display_name"];
            field_type: components["schemas"]["CustomFieldsFieldValue"]["field_type"];
            /** @description The ID of the resource. */
            readonly id: string;
            name: components["schemas"]["CustomFieldsFieldValue"]["name"];
            /**
             * Format: url
             * @description The API show URL at which the object is accessible
             */
            readonly self: string | null;
            /** @description A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `display_name`. */
            readonly summary: string | null;
            /** @enum {string} */
            readonly type: "field";
            /**
             * Format: date-time
             * @description The date/time the object was last updated.
             */
            readonly updated_at: string;
        };
        CustomFieldsEditableField: {
            display_name?: components["schemas"]["CustomFieldsFieldValue"]["display_name"];
            description?: components["schemas"]["CustomFieldsFieldValue"]["description"];
            default_value?: components["schemas"]["IncidentTypeCustomFields"]["default_value"];
            /**
             * @description Whether the field is enabled.
             * @enum {boolean}
             */
            enabled?: true | false;
        };
        CustomFieldsFieldOption: components["schemas"]["CustomFieldsEditableFieldOption"];
        CustomFieldsEditableFieldOption: {
            data?: {
                /**
                 * @description The kind of data represented by this option. Must match the Field's `data_type`. (enum property replaced by openapi-typescript)
                 * @enum {string}
                 */
                data_type: "string";
                value: string;
            };
            /** @description The ID of the resource. */
            readonly id: string;
            /** @enum {string} */
            readonly type: "field_option";
            /**
             * Format: date-time
             * @description The date/time the object was last updated.
             */
            readonly updated_at: string;
            /**
             * Format: date-time
             * @description The date/time the object was created at.
             */
            readonly created_at: string;
        };
        CustomFieldsFieldWithOptions: {
            /**
             * Format: date-time
             * @description The date/time the object was created at.
             */
            readonly created_at: string;
            data_type: components["schemas"]["CustomFieldsFieldValue"]["data_type"];
            default_value?: components["schemas"]["IncidentTypeCustomFields"]["default_value"];
            description?: components["schemas"]["CustomFieldsFieldValue"]["description"];
            display_name: components["schemas"]["CustomFieldsFieldValue"]["display_name"];
            /** @description The fixed list of value options that may be stored in this field. */
            field_options?: components["schemas"]["CustomFieldsFieldOption"][] | null;
            field_type: components["schemas"]["CustomFieldsFieldValue"]["field_type"];
            /** @description The ID of the resource. */
            readonly id: string;
            name: components["schemas"]["CustomFieldsFieldValue"]["name"];
            /**
             * Format: url
             * @description The API show URL at which the object is accessible
             */
            readonly self: string | null;
            /** @description A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to `display_name`. */
            readonly summary: string | null;
            /** @enum {string} */
            readonly type: "field";
            /**
             * Format: date-time
             * @description The date/time the object was last updated.
             */
            readonly updated_at: string;
        };
        CustomFieldsFieldValue: {
            /** @description Id of the field. */
            id: string;
            /**
             * Field Name
             * @description The name of the field. May include ASCII characters, specifically lowercase letters, digits, and underescores. The `name` for a Field must be unique and cannot be changed once created.
             */
            name: string;
            /**
             * @description Determines the type of the reference.
             * @enum {string}
             */
            type: "field_value";
            /** @description The human-readable name of the field. This must be unique across an account. */
            display_name: string;
            /**
             * @description The type of data this field contains. In combination with the `data_type` field.
             * @enum {string}
             */
            field_type: "single_value" | "single_value_fixed" | "multi_value" | "multi_value_fixed";
            /**
             * @description The kind of data the custom field is allowed to contain.
             * @enum {string}
             */
            data_type: "boolean" | "integer" | "float" | "string" | "datetime" | "url";
            /** @description A description of the data this field contains. */
            description: string | null;
            value: {
                value?: boolean | null;
            } | {
                value?: number | null;
            } | {
                value?: number | null;
            } | {
                value?: (string | null) | (string[] | null);
            } | {
                /** Format: date-time */
                value?: string | null;
            } | {
                /** Format: uri */
                value?: string | null;
            };
        };
        /** Custom Field Value */
        CustomFieldsEditableFieldValue: {
            name?: components["schemas"]["CustomFieldsFieldValue"]["name"];
            value?: components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["0"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["1"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["2"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["3"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["4"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["5"];
        } | {
            /** @description The ID of the Field. */
            id?: string;
            value?: components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["0"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["1"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["2"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["3"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["4"] | components["schemas"]["CustomFieldsFieldValue"]["value"]["oneOf"]["5"];
        };
        FeatureEnablement: {
            /**
             * @description The name of the product addon whose set of features will be enabled or disabled.
             * @example aiops
             */
            readonly feature?: string;
            /** @description A boolean value indicating whether the specified product addon is enabled or disabled. */
            enabled: boolean;
            /**
             * Format: date-time
             * @description The time the feature enablement was last updated.
             */
            readonly updated_at?: string;
            /** @description An array of warnings related to this feature enablement. Only present if warning conditions are met. */
            readonly warnings?: {
                /** @description The warning message. */
                message?: string;
            }[];
        };
        /** StandardApplied */
        StandardApplied: {
            resource_id?: string;
            /** @enum {string} */
            resource_type?: "technical_service";
            score?: {
                passing?: number;
                total?: number;
            };
            standards?: {
                active?: boolean;
                description?: string;
                id?: string;
                name?: string;
                type?: string;
                pass?: boolean;
            }[];
        };
        /** StandardInclusionExclusion */
        StandardInclusionExclusion: {
            /** @enum {string} */
            type?: "technical_service_reference";
            id?: string;
        };
        /**
         * StatusPage
         * @description A Status Page with all the configuration needed to present the system status in a public or private manner.
         */
        StatusPage: {
            /** @description An unique identifier within Status Page scope that defines a Status Page entry. */
            readonly id?: string;
            /** @description The name of a Status Page to be presented as a brand title (for example, the rendered Status Page HTML header). */
            name?: string;
            /**
             * Format: date-time
             * @description The date time moment when a Status Page was published to be publicly available.
             */
            readonly published_at?: string | null;
            /**
             * @description The type of Status Pages to retrieve - public is accessible to everyone on the internet or private requiring some sort of authentication/authorization layer.
             * @enum {string}
             */
            status_page_type?: "public" | "private";
            /**
             * Format: url
             * @description The URL from which the Status Page can be accessed on the internet (either customer's domain or default *.trust.pagerduty.com).
             */
            url?: string;
            /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by _reference if the object is a reference. */
            type?: string;
        };
        /**
         * StatusPageImpact
         * @description A StatusPageImpact resource represents a level of impact for a given Status Page Post.
         */
        StatusPageImpact: {
            /** @description An unique identifier within Status Page scope that defines a Impact entry. */
            readonly id?: string;
            /** @description The API resource URL of the Impact. */
            readonly self?: string;
            /** @description The description is a human-readable text that describes the Impact level. */
            description?: string;
            /**
             * @description The type of the Post.
             * @enum {string}
             */
            post_type?: "incident" | "maintenance";
            /** @description Status Page */
            status_page?: {
                /** @description Status page unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description The type of the object returned by the API - in this case, a Status Page Impact. */
            type?: string;
        };
        /**
         * StatusPagePost
         * @description A Post represents a communication resource presented in the Status Page about certain aspects of one or more services associated.
         */
        StatusPagePost: {
            /** @description An unique identifier within Status Page scope that defines a single Post resource. */
            readonly id?: string;
            /** @description The API resource URL of the Post. */
            readonly self?: string;
            /**
             * @description The type of the object returned by the API - in this case, a Status Page Post.
             * @default status_page_post
             */
            readonly type: string;
            /**
             * @description The type of the Post.
             * @enum {string}
             */
            post_type?: "incident" | "maintenance";
            /** @description Status Page */
            status_page?: {
                /** @description Status page unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description Linked resource */
            linked_resource?: {
                /** @description Linked resource unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description Postmortem */
            postmortem?: {
                /** @description Postmortem unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description The title given to a Post. */
            title?: string;
            /**
             * Format: date-time
             * @description The date and time the Post intent becomes effective - only for maintenance post type.
             */
            starts_at?: string | null;
            /**
             * Format: date-time
             * @description The date and time the Post intent is concluded - only for maintenance post type.
             */
            ends_at?: string | null;
            /** @description List of status_page_post_update references associated to a Post. */
            updates?: components["schemas"]["StatusPagePostUpdate"][];
        };
        /**
         * StatusPagePostRequest
         * @description Request schema for creating/updating a given Status Page Post resource.
         */
        StatusPagePostPostRequest: {
            /**
             * @description The type of the object returned by the API - in this case, a Status Page Post.
             * @enum {string}
             */
            type: "status_page_post";
            /** @description The title given to a Post. */
            title: string;
            /**
             * @description The type of the Post.
             * @enum {string}
             */
            post_type: "incident" | "maintenance";
            /**
             * Format: date-time
             * @description The date and time the Post intent becomes effective - only for maintenance post type.
             */
            starts_at: string | null;
            /**
             * Format: date-time
             * @description The date and time the Post intent is concluded - only for maintenance post type.
             */
            ends_at: string | null;
            /** @description Post Updates to be associated with a Post */
            updates: components["schemas"]["StatusPagePostUpdateRequest"][];
            /** @description Status Page */
            status_page: {
                /** @description Status page unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
        };
        /**
         * StatusPagePostPutRequest
         * @description Request schema for creating a given Status Page Post resource.
         */
        StatusPagePostPutRequest: {
            /**
             * @description The type of the object returned by the API - in this case, a Status Page Post.
             * @enum {string}
             */
            type: "status_page_post";
            /** @description The title given to a Post. */
            title: string;
            /**
             * @description The type of the Post.
             * @enum {string}
             */
            post_type: "incident" | "maintenance";
            /**
             * Format: date-time
             * @description The date and time the Post intent becomes effective - only for maintenance post type.
             */
            starts_at: string | null;
            /**
             * Format: date-time
             * @description The date and time the Post intent is concluded - only for maintenance post type.
             */
            ends_at: string | null;
            /** @description Status Page */
            status_page: {
                /** @description Status page unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
        };
        /**
         * StatusPagePostUpdate
         * @description An update for a Post.
         */
        StatusPagePostUpdate: {
            /** @description The ID of the Post Update. */
            readonly id?: string;
            /** @description The path to which the Post Update resource is accessible. */
            readonly self?: string;
            /** @description Status Page Post */
            post?: {
                /** @description Status page post unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description The message of the Post Update. */
            message?: string;
            /**
             * @description The status of the Post Updates to retrieve.
             * @enum {string}
             */
            reviewed_status?: "approved" | "not_reviewed";
            /** @description Status Page Status */
            status?: {
                /** @description Status page Status unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description Status Page Severity */
            severity?: {
                /** @description Status page Severity unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description Impacted services represent the status page services affected by a post update, and its impact. */
            impacted_services?: {
                /** @description Status Page Service */
                service?: {
                    /** @description An unique identifier within Status Page scope that defines a Service entry. */
                    readonly id?: string;
                    /** @description The type of the object returned by the API - in this case, a Status Page Service. */
                    type?: string;
                };
                /** @description Status Page Impact */
                impact?: {
                    /** @description An unique identifier within Status Page scope that defines a Status Page Impact entry. */
                    readonly id?: string;
                    /** @description The type of the object returned by the API - in this case, a Status Page Impact. */
                    type?: string;
                };
            }[];
            /** @description The frequency of the next Post Update in milliseconds. */
            update_frequency_ms?: number | null;
            /** @description Determines if the subscribers should be notified of the Post Update. */
            notify_subscribers?: boolean;
            /**
             * Format: date-time
             * @description The date and time the Post Update was reported.
             */
            reported_at?: string | null;
            /** @description The type of the object returned by the API - in this case, a Status Page Post Update. */
            type?: string;
        };
        /**
         * StatusPagePostUpdateRequest
         * @description Attributes for Post Update creation/update
         */
        StatusPagePostUpdateRequest: {
            /** @description The path to which the Post Update resource is accessible. */
            readonly self?: string;
            /** @description Status Page Post */
            post: {
                /** @description Status page post unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description The message of the Post Update. */
            message: string;
            /** @description Status Page Status */
            status: {
                /** @description Status page Status unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description Status Page Severity */
            severity: {
                /** @description Status page Severity unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description Impacted services represent the status page services affected by a post update, and its impact. */
            impacted_services: components["schemas"]["StatusPagePostUpdate"]["impacted_services"]["items"][];
            /** @description The frequency of the next Post Update in milliseconds. */
            update_frequency_ms: number | null;
            /** @description Determines if the subscribers should be notified of the Post Update. */
            notify_subscribers: boolean;
            /**
             * Format: date-time
             * @description The date and time the Post Update was reported.
             */
            reported_at?: string | null;
            /** @description The type of the object returned by the API - in this case, a Status Page Post Update. */
            type: string;
        };
        /**
         * StatusPagePostmortem
         * @description A Postmortem represents a communication resource presented in the Status Page about follow-up made to a certain Post.
         */
        StatusPagePostmortem: {
            /** @description An unique identifier within Status Page scope that defines a single Postmortem resource. */
            readonly id?: string;
            /** @description The API resource URL of the Postmortem. */
            readonly self?: string;
            /** @description Status Page Post */
            post?: {
                /** @description The id of the status page post. */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description The message of the Postmortem (supports Rich-Text). */
            message?: string;
            /** @description Whether or not subscribers of the Status Page should be notified about the Postmortem. */
            notify_subscribers?: boolean;
            /**
             * Format: date-time
             * @description The date and time the Postmortem was reported.
             */
            reported_at?: string;
            /** @description The type of the object returned by the API - in this case, a Status Page Post Postmortem. */
            type?: string;
        };
        /**
         * PostmortemRequest
         * @description Request to create/update a given Postmortem resource.
         */
        StatusPagePostmortemRequest: {
            /**
             * @description The type of the object returned by the API - in this case, a Status Page Post Postmortem.
             * @default status_page_post_postmortem
             * @enum {string}
             */
            readonly type: "status_page_post_postmortem";
            /** @description Status Page Post */
            post: {
                /** @description Status page post unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description The message of the Postmortem (supports Rich-Text). */
            message: string;
            /** @description Whether or not subscribers of the Status Page should be notified about the Postmortem. */
            notify_subscribers: boolean;
        };
        /**
         * StatusPageService
         * @description A Service represents a PagerDuty service that is linked to a Status Page.
         */
        StatusPageService: {
            /** @description An unique identifier within Status Page scope that defines a Service entry. */
            readonly id?: string;
            /** @description The API resource URL of the Service. */
            readonly self?: string;
            /** @description The name of the Service. */
            name?: string;
            /** @description Status Page */
            status_page?: {
                /** @description Status page unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description Business Service */
            business_service?: {
                /** @description Business Service unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description A string that determines the schema of the object. */
            type?: string;
        };
        /**
         * StatusPageSeverity
         * @description A Severity represents a level of impact for a given Status Page post.
         */
        StatusPageSeverity: {
            /** @description An unique identifier within Status Page scope that defines a Severity entry. */
            readonly id?: string;
            /** @description The API resource URL of the Severity. */
            readonly self?: string;
            /** @description The description is a human-readable text that describes the Severity level. */
            description?: string;
            /**
             * @description The type of the Post.
             * @enum {string}
             */
            post_type?: "incident" | "maintenance";
            /** @description Status Page */
            status_page?: {
                /** @description Status page unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description The type of the object returned by the API - in this case, a Status Page Severity. */
            type?: string;
        };
        /**
         * StatusPageSubscription
         * @description A StatusPageSubscription resource represents a subscription to a specific status page entity.
         */
        StatusPageSubscription: {
            /**
             * SubscriptionChannel
             * @description The channel of the subscription.
             * @enum {string}
             */
            channel?: "webhook" | "email" | "slack";
            /** @description The subscriber's contact - email address, webhook URL, etc... */
            contact?: string;
            /** @description The ID of the Subscription. */
            id?: string;
            /** @description The path in which the Subscription resource is accessible. */
            self?: string;
            /**
             * SubscriptionStatus
             * @description The status of the Subscription.
             * @enum {string}
             */
            status?: "active" | "pending" | "suspended";
            /** @description Status Page */
            status_page?: {
                /** @description Status page unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /**
             * SubscribableObject
             * @description The subscribed entity for a given subscription.
             */
            subscribable_object?: {
                /** @description The ID of the subscribed entity. */
                id?: string;
                /**
                 * @description The type of the subscribed entity.
                 * @enum {string}
                 */
                type?: "status_page" | "status_page_service" | "status_page_post";
            };
            /** @description A string that determines the schema of the object. */
            type?: string;
        };
        /**
         * StatusPageStatus
         * @description A Status represents a level of undergoing work and/or assessment for a given Status Page post.
         */
        StatusPageStatus: {
            /** @description An unique identifier within Status Page scope that defines a Status entry. */
            readonly id?: string;
            /** @description The API resource URL of the Status. */
            readonly self?: string;
            /** @description The description is a human-readable text that describes the Status level. */
            description?: string;
            /**
             * @description The type of the Post.
             * @enum {string}
             */
            post_type?: "incident" | "maintenance";
            /** @description Status Page */
            status_page?: {
                /** @description Status page unique identifier */
                id: string;
                /** @description A string that determines the schema of the object. */
                type?: string;
            };
            /** @description The type of the object returned by the API - in this case, a Status Page Status. */
            type?: string;
        };
        WorkflowIntegration: components["schemas"]["Tag"] & {
            /** @description The ID of the integration */
            readonly id?: string;
            /** @description The type of the resource */
            readonly type?: string;
            /** @description Will be pagerduty.com */
            domain_name?: string;
            /** @description The package that the integration is part of */
            package_name?: string;
            /** @description The name of the integration */
            name?: string;
            /** @description The description of the integration */
            description?: string;
            /** @description The svg string of the icon for the integration */
            icon_svg?: string;
            /** @description A list of tags applied to the integration */
            tags?: string[];
            /** @description A list of keywords that match this integration */
            search_keywords?: string[];
            /** @description Whether or not the integration is deprecated */
            is_deprecated?: boolean;
            /** @description Whether or not the integration is entitled */
            entitled?: boolean;
            /** @description The application that this integration is associated with */
            application?: string;
            /** @description The JSON schema for the configuration of the integration. This is a dynamic field and is different for every integration */
            configuration_schema?: Record<string, never>;
            /** @description The JSON schema for the secrets of the integration. This is a dynamic field and is different for every integration */
            secrets_schema?: Record<string, never>;
            /** Format: date-time */
            readonly created_at?: string;
            /** @description Reference to the user who created this connection */
            readonly created_by?: {
                /**
                 * @description Type of the referenced object
                 * @enum {string}
                 */
                readonly type?: "user_reference";
                /** @description Unique identifier of the user */
                readonly id?: string;
                /** @description The user's name */
                readonly summary?: string;
                /**
                 * Format: url
                 * @description a URL at which the entity is uniquely displayed in the Web app
                 */
                readonly html_url?: string;
                /**
                 * Format: url
                 * @description the API show URL at which the object is accessible
                 */
                readonly self?: string;
            } | null;
        };
        WorkflowIntegrationConnection: components["schemas"]["Tag"] & {
            /** @description The ID of the connection */
            readonly id?: string;
            /** @description The type of the connection */
            readonly type?: string;
            /** @description The integration ID that this connection is associated with */
            readonly integration_id?: string;
            /** @description The name given to the connection */
            name?: string;
            /** @description The URL of the service that this connection is associated with */
            service_url?: string;
            /** @description The ID of the external system that this connection is used to connect to */
            external_id?: string;
            /** @description The label of the external system that this connection is used to connect to */
            external_id_label?: string;
            scopes?: string[];
            /** @description Whether or not this connection is the default connection for this integration */
            is_default?: boolean;
            readonly health?: {
                /** @description Whether or not the connection is healthy */
                readonly is_healthy?: boolean;
                /** @description A message describing the health of the connection */
                readonly health_message?: string;
                /**
                 * Format: date-time
                 * @description The timestamp of the last health check
                 */
                readonly last_checked_at?: string;
            };
            /** @description The configuration for this connection */
            configuration?: Record<string, never>;
            /** @description The secrets for this connection. This will always be `null` on a response so that secrets are not leaked. */
            secrets?: Record<string, never>;
            /** @description The teams whose managers are allowed to use or edit this connection */
            teams?: {
                /** @description The ID of the team */
                team_id?: string;
                /** @enum {string} */
                type?: "team_reference";
            }[];
            /** @description The app IDs for this connection */
            apps?: {
                /** @description The ID of the app */
                app_id?: string;
                /** @enum {string} */
                type?: "pd_app_reference";
            }[];
            /**
             * Format: date-time
             * @description The timestamp of when the connection was created
             */
            readonly created_at?: string;
            /** @description Reference to the user who created this connection */
            readonly created_by?: {
                /**
                 * @description Type of the referenced object
                 * @enum {string}
                 */
                readonly type?: "user_reference";
                /** @description Unique identifier of the user */
                readonly id?: string;
                /** @description The user's name */
                readonly summary?: string;
                /**
                 * Format: url
                 * @description a URL at which the entity is uniquely displayed in the Web app
                 */
                readonly html_url?: string;
                /**
                 * Format: url
                 * @description the API show URL at which the object is accessible
                 */
                readonly self?: string;
            } | null;
        };
    };
    responses: {
        /** @description Caller provided invalid arguments. Please review the response for error details. Retrying with the same arguments will *not* work. */
        ArgumentError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /** @description The request conflicts with the current state of the server. */
        Conflict: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /**
                     * @example {
                     *       "message": "Not Found",
                     *       "code": 2100
                     *     }
                     */
                    error?: {
                        readonly code?: number;
                        /** @description Error message string */
                        readonly message?: string;
                        readonly errors?: string[];
                    };
                };
            };
        };
        /**
         * @description Caller is not authorized to view the requested resource.
         *     While your authentication is valid, the authenticated user or token does not have permission to perform this action.
         */
        Forbidden: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /** @description Internal Server Error the PagerDuty server experienced an error. */
        InternalServerError: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /** @description The request was received and recognized by the server, but its HTTP method was rejected for the requested resource. */
        NotAllowed: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /** @description The requested resource was not found. */
        NotFound: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /** @description Too many requests have been made, the rate limit has been reached. */
        TooManyRequests: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /**
         * @description Account does not have the abilities to perform the action. Please review the response for the required abilities.
         *     You can also use the [Abilities API](#resource_Abilities) to determine what features are available to your account.
         */
        PaymentRequired: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /**
         * @description Caller did not supply credentials or did not provide the correct credentials.
         *     If you are using an API key, it may be invalid or your Authorization header may be malformed.
         */
        Unauthorized: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /** @description Unprocessable Entity. Some arguments failed validation checks. */
        UnprocessableEntity: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /** @description Caller provided a request that is too large to process. */
        RequestEntityTooLarge: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["responses"]["Conflict"]["content"]["application/json"]["error"];
            };
        };
        /** @description The Cache Variables for this Event Orchestration. */
        OrchestrationCacheVariableListResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    cache_variables?: (components["schemas"]["OrchestrationCacheVariableRecentValue"] | components["schemas"]["OrchestrationCacheVariableTriggerEventCount"] | components["schemas"]["OrchestrationCacheVariableExternalData"])[];
                };
            };
        };
        /** @description The fetched Cache Variable for this Event Orchestration. */
        OrchestrationCacheVariableGetResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    cache_variable?: components["schemas"]["OrchestrationCacheVariableRecentValue"] | components["schemas"]["OrchestrationCacheVariableTriggerEventCount"] | components["schemas"]["OrchestrationCacheVariableExternalData"];
                };
            };
        };
        /** @description The data on an `external_data` type Cache Variable for this Event Orchestration. */
        OrchestrationCacheVariableGetDataResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /**
                     * @description The string value to set on an external data cache variable configured with `data_type: string`.
                     * @example Hello World!
                     */
                    cache_variable_data: string;
                    /**
                     * Format: date-time
                     * @description The date/time the cache variable data was last updated.
                     */
                    readonly updated_at?: string;
                } | {
                    /**
                     * @description The number value to set on an external data cache variable configured with `data_type: number`.
                     * @example 45.678
                     */
                    cache_variable_data: number;
                    /**
                     * Format: date-time
                     * @description The date/time the cache variable data was last updated.
                     */
                    readonly updated_at?: string;
                } | {
                    /**
                     * @description The boolean value to set on an external data cache variable configured with `data_type: boolean`.
                     * @example true
                     */
                    cache_variable_data: boolean;
                    /**
                     * Format: date-time
                     * @description The date/time the cache variable data was last updated.
                     */
                    readonly updated_at?: string;
                };
            };
        };
        /** @description The created Cache Variable for this Event Orchestration. */
        OrchestrationCacheVariablePostResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    cache_variable?: components["schemas"]["OrchestrationCacheVariableRecentValue"] | components["schemas"]["OrchestrationCacheVariableTriggerEventCount"] | components["schemas"]["OrchestrationCacheVariableExternalData"];
                };
            };
        };
        /** @description The updated Cache Variable for this Event Orchestration. */
        OrchestrationCacheVariablePutResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    cache_variable?: components["schemas"]["OrchestrationCacheVariableRecentValue"] | components["schemas"]["OrchestrationCacheVariableTriggerEventCount"] | components["schemas"]["OrchestrationCacheVariableExternalData"];
                };
            };
        };
        /** @description The Orchestration Router object. */
        OrchestrationPathRouterTypeResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["OrchestrationRouter"];
            };
        };
        /** @description The Service Orchestration object. */
        OrchestrationPathServiceTypeResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ServiceOrchestration"];
            };
        };
        /** @description An object with the active status. */
        OrchestrationPathServiceActiveResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @description The status of the service orchestration. */
                    active?: boolean;
                };
            };
        };
        /** @description The Unrouted Orchestration object. */
        OrchestrationPathUnroutedTypeResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["OrchestrationUnrouted"];
            };
        };
        /**
         * @description Caller provided invalid arguments. Please review the response for error
         *     details. Retrying with the same arguments will *not* work.
         */
        WebhookBadRequest: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /**
         * @description Caller did not supply credentials or did not provide the correct
         *     credentials.
         *
         *     If you are using an API key, it may be invalid or your Authorization header may be malformed.
         */
        WebhookUnauthorized: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /**
         * @description Caller is not authorized to view the requested resource.
         *
         *     While your authentication is valid, the authenticated user or token does not have permission to perform this action.
         */
        WebhookForbidden: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description The requested resource was not found. */
        WebhookNotFound: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
    };
    parameters: {
        /** @description The `Accept` header is used as a versioning header. */
        header_Accept: string;
        "header_Content-Type": "application/json";
        /** @description Should contain the API key or OAuth token to authorize the request. Format: `Token token=<token>` or `Bearer <token>` */
        header_Authorization: string;
        /** @description MCP clients must accept both application/json and text/event-stream. */
        header_MCPAccept: "application/json, text/event-stream";
        /** @description The start of the date range over which you want to search. If not specified, defaults to `now() - 24 hours` (past 24 hours) */
        audit_since: string;
        /** @description The end of the date range over which you want to search. If not specified, defaults to `now()`. May not be more than 31 days after `since`. */
        audit_until: string;
        /** @description Resource type filter for the root_resource. */
        audit_root_resource_types: "users" | "teams" | "schedules" | "escalation_policies" | "services";
        /** @description Actor type filter. */
        audit_actor_type: "user_reference" | "api_key_reference" | "app_reference";
        /** @description Actor Id filter. Must be qualified by providing the `actor_type` param. */
        audit_actor_id: string;
        /** @description Method type filter. */
        audit_method_type: "browser" | "oauth" | "api_token" | "identity_provider" | "other";
        /** @description Method truncated_token filter. Must be qualified by providing the `method_type` param. */
        audit_method_truncated_token: string;
        /** @description Action filter */
        audit_actions: "create" | "update" | "delete";
        /** @description The number of results per page. */
        offset_limit: number;
        /** @description Offset to start pagination search results. */
        offset_offset: number;
        /**
         * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
         *
         *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
         */
        offset_total: boolean;
        /** @description Filters results to include the ones matching the name (case insensitive substring matching) */
        automation_actions_name: string;
        /** @description Includes additional data elements into the response */
        automation_actions_runners_include: "associated_actions"[];
        /**
         * @description Filters results to include the ones linked to the specified runner.
         *     Specifying the value `any` filters results to include the ones linked to runners only,
         *     thus omitting the results not linked to runners.
         */
        automation_actions_runner_id: string;
        /** @description Filters results to include the ones matching the specified classification (aka category) */
        automation_actions_classification: components["schemas"]["AutomationActionsActionClassificationEnum"];
        /** @description Filters results to include the ones matching the specified action type */
        automation_actions_action_type: "script" | "process_automation";
        /** @description Filters results to include the ones associated with the specified team. */
        automation_actions_team_id: string;
        /** @description Filters results to include the ones associated with the specified service */
        automation_actions_service_id: string;
        /** @description Invocation state */
        automation_actions_invocation_state: "prepared" | "created" | "sent" | "queued" | "running" | "aborted" | "completed" | "error" | "unknown";
        /** @description Invocation state inverse filter (matches invocations NOT in the specified state) */
        automation_actions_not_invocation_state: components["parameters"]["automation_actions_invocation_state"]["schema"];
        /** @description Incident ID */
        automation_actions_incident_id: string;
        /** @description Action ID */
        automation_actions_action_id: string;
        /** @description The number of results per page. Maximum of 100. */
        incident_list_limit: number;
        /** @description The ID or name of the Incident Type. */
        incident_type_id_or_name: string;
        /** @description The ID or name of the Incident Type. */
        incident_type_id_or_name_dub: string;
        /** @description Filters the list of incident types based on their `enabled` state. */
        incident_type_list_filter: "enabled" | "disabled" | "all";
        /** @description The number of results to be returned in the response. */
        past_incidents_limit: number;
        /** @description By default the `total` field in the response body is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated with the total number of Past Incidents. */
        past_incidents_total: boolean;
        /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
        cursor_limit: number;
        /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
        cursor_cursor: string;
        /** @description This header indicates that this API endpoint is __UNDER CONSTRUCTION__ and may change at any time.  You __MUST__ pass in this header and the above value.  Do not use this endpoint in production, as it may change! */
        early_access_analytics: "analytics-v2";
        /** @description This header indicates that this API endpoint is __UNDER CONSTRUCTION__ and may change at any time. You __MUST__ pass in this header with the value `business-impact-early-access`. Do not use this endpoint in production, as it may change! */
        early_access_bis: string;
        /** @description This header indicates that this API endpoint is __UNDER CONSTRUCTION__ and may change at any time. You __MUST__ pass in this header with the value `status-dashboards`. Do not use this endpoint in production, as it may change! */
        early_access_status_dashboards: string;
        /** @description The type of resource to filter upon. */
        webhooks_filter_type: "account" | "service" | "team";
        /** @description The id of the resource to filter upon. Required if filter_type is service or team. */
        webhooks_filter_id: string;
        /** @description The type of OAuth delegations this request should target. Allowed values are 'mobile' (to sign users out of the mobile app) and 'web' (to sign users out of the web app). You can pass one or more types in, separated by commas (e.g., type=web,mobile). */
        oauth_delegation_type: "mobile" | "web";
        /** @description The ID of the user for whom this request is applicable. */
        oauth_delegation_user_id: string;
        /** @description The end of the date range over which you want to search. If not specified, this will default to current time. */
        oauth_delegation_requested_at_end: string;
        /** @description The ID of the OAuth client. */
        oauth_client_id: string;
        /** @description The ID of the resource. */
        id: string;
        /** @description The IDs of the resources. */
        ids: string;
        /** @description The ID of the responder. */
        responder_id: string;
        /** @description Type of entity related with the tag */
        entity_type: "users" | "teams" | "escalation_policies";
        /** @description The business service ID. */
        business_service_id: string;
        /** @description The team ID */
        team_id: string;
        /** @description The user ID on the team. */
        team_user_id: string;
        /** @description The escalation policy ID on the team. */
        team_escalation_policy_id: string;
        /** @description The escalation rule ID on the escalation policy. */
        escalation_policy_escalation_rule_id: string;
        /** @description Provides access to additional fields such as highest priority per business service and total impacted count */
        impacts_additional_fields: "services.highest_impacting_priority" | "total_impacted_count";
        /** @description Array of additional Models to include in response. */
        include_addon: "services";
        /** @description Array of additional Models to include in response. */
        include_escalation_policy: "services" | "teams" | "targets";
        /** @description Whether to include deprecated Integrations in the response. */
        include_deprecated: boolean;
        /** @description Array of additional Models to include in response. */
        include_log_entry: "incidents" | "services" | "channels" | "teams";
        /** @description Array of additional Models to include in response. */
        include_user: "contact_methods" | "notification_rules" | "teams" | "subdomains";
        /** @description Array of additional Models to include in response. */
        include_maintenance_window: "teams" | "services" | "users";
        /** @description Array of additional Models to include in response. */
        include_teams: "privileges";
        /** @description Array of additional Models to include in response. */
        include_teams_members: "users";
        /** @description Array of additional Models to include in response. */
        include_triggers: "triggers";
        /** @description Used to specify the field you wish to sort the results on. */
        sort_by_escalation_policy: "name" | "name:asc" | "name:desc";
        /** @description Used to specify the field you wish to sort the results on. */
        sort_by_service: "name" | "name:asc" | "name:desc";
        /**
         * @description Any on-call schedule entries that pass the date range bounds will be truncated at the bounds, unless the parameter `overflow=true` is passed. This parameter defaults to false.
         *     For instance, if your schedule is a rotation that changes daily at midnight UTC, and your date range is from `2011-06-01T10:00:00Z` to `2011-06-01T14:00:00Z`:
         *
         *
         *     - If you don't pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T10:00:00Z` and end of `2011-06-01T14:00:00Z`.
         *     - If you do pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T00:00:00Z` and end of `2011-06-02T00:00:00Z`.
         */
        schedule_overflow: boolean;
        /** @description The override ID on the schedule. */
        schedule_override_id: string;
        /** @description An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter. */
        team_ids: string[];
        /** @description Time zone in which results will be rendered. This will default to the account time zone. */
        time_zone: string;
        /** @description Time zone in which results will be rendered. This will default to the schedule's time zone. */
        schedule_time_zone: string;
        /** @description Time zone in which results will be rendered. This will default to the current user's time zone and then the account's time zone. */
        schedule_list_time_zone: string;
        /** @description Session configuration type. This can be either 'mobile' or 'web', or a comma-separated list of both. */
        session_configuration_type: "mobile" | "web";
        /** @description Session configuration type. If omitted, returns both mobile and web configurations. */
        optional_session_configuration_type: "mobile" | "web";
        /** @description The service ID */
        service_id: string;
        /** @description An array of service IDs. Only results related to these services will be returned. */
        services: string[];
        /** @description The integration ID on the service. */
        integration_id: string;
        /** @description An array of integration IDs. Only results related to these integrations will be returned. */
        integration_ids: string[];
        /** @description If `true`, will return a subset of log entries that show only the most important changes to the incident. */
        log_entry_is_overview: boolean;
        /** @description The start of the date range over which you want to search. */
        since: string;
        /** @description The end of the date range over which you want to search. */
        until: string;
        /** @description The `url_slug` for a status dashboard */
        url_slug: string;
        /** @description When set to all, the since and until parameters and defaults are ignored. */
        date_range: "all";
        /** @description Incident de-duplication key. Incidents with child alerts do not have an incident key; querying by incident key will return incidents whose alerts have alert_key matching the given incident key. */
        incident_key: string;
        /** @description Returns only the incidents associated with the passed service(s). This expects one or more service IDs. */
        incident_services: string[];
        /** @description Returns only the incidents currently assigned to the passed user(s). This expects one or more user IDs. Note: When using the assigned_to_user filter, you will only receive incidents with statuses of triggered or acknowledged. This is because resolved incidents are not assigned to any user. */
        incident_assigned_to_user: string[];
        /** @description Array of the urgencies of the incidents to be returned. Defaults to all urgencies. Account must have the `urgencies` ability to do this. */
        incident_urgencies: "high" | "low";
        /** @description The email address of a valid user associated with the account making the request. */
        from_header: string;
        /** @description The email address of a valid user associated with the account making the request. This is optional, and is only used for change tracking. */
        optional_from_header: string;
        /** @description The contact method ID on the user. */
        user_contact_method_id: string;
        /** @description The notification rule ID on the user. */
        user_notification_rule_id: string;
        /** @description The status update notification rule ID on the user. */
        user_status_update_notification_rule_id: string;
        /** @description The oncall handoff notification rule ID on the user. */
        oncall_handoff_notification_rule_id: string;
        /** @description The session ID for the user. */
        session_id: string;
        /** @description The session type for the user session ID. */
        type: string;
        /** @description Alert de-duplication key. */
        alert_key: string;
        /**
         * @deprecated
         * @description The response play ID of the response play associated with the request.
         */
        response_play_id: string;
        /** @description Filters the result, showing only the records whose name matches the query. */
        query: string;
        /** @description Filters the result, showing only the tags whose label matches the query. */
        tag_query: string;
        /** @description Filters the results, showing only Add-ons for the given services */
        addon_services: string[];
        /** @description Filters the results, showing only Add-ons of the given type */
        addon_filter: "full_page_addon" | "incident_show_addon";
        /** @description The start of the date range over which you want to search, as a UTC ISO 8601 datetime string. Will return an HTTP 400 for non-UTC datetimes. */
        change_since: string;
        /** @description The end of the date range over which you want to search, as a UTC ISO 8601 datetime string. Will return an HTTP 400 for non-UTC datetimes. */
        change_until: string;
        /** @description Filters the results, showing only escalation policies on which any of the users is a target. */
        user_ids_escalation_policies: string[];
        /** @description The id of the extension object you want to filter by. */
        extension_object_id: string;
        /** @description Filter the extensions by extension vendor id. */
        extension_schema_id: string;
        /** @description Array of additional details to include. */
        include_extensions: "extension_objects" | "extension_schemas";
        /** @description Array of additional details to include. */
        include_extensions_id: "extension_schemas" | "extension_objects" | "temporarily_disabled";
        /** @description Array of additional details to include. */
        include_incident_workflow_children: "steps" | "team";
        /** @description Return only incidents with the given statuses. To query multiple statuses, pass `statuses[]` more than once, for example: `https://api.pagerduty.com/incidents?statuses[]=triggered&statuses[]=acknowledged`. (More status codes may be introduced in the future.) */
        statuses_incidents: "triggered" | "acknowledged" | "resolved";
        /** @description Used to specify both the field you wish to sort the results on (incident_number/created_at/resolved_at/urgency), as well as the direction (asc/desc) of the results. The sort_by field and direction should be separated by a colon. A maximum of two fields can be included, separated by a comma. Sort direction defaults to ascending. The account must have the `urgencies` ability to sort by the urgency. */
        sort_by_incidents: string[];
        /** @description Array of additional details to include. */
        include_incidents: "acknowledgers" | "agents" | "assignees" | "conference_bridge" | "escalation_policies" | "first_trigger_log_entries" | "priorities" | "services" | "teams" | "users";
        /** @description Array of additional details to include. */
        include_incident: "acknowledgers" | "agents" | "assignees" | "conference_bridge" | "custom_fields" | "escalation_policies" | "first_trigger_log_entries" | "priorities" | "services" | "teams" | "users";
        /** @description The start of the date range over which you want to search. Maximum range is 6 months and default is 1 month. */
        since_incidents: string;
        /** @description The end of the date range over which you want to search. Maximum range is 6 months and default is 1 month. */
        until_incidents: string;
        /** @description Return only alerts with the given statuses. (More status codes may be introduced in the future.) */
        statuses_incident_alerts: "triggered" | "resolved";
        /** @description Used to specify both the field you wish to sort the results on (created_at/resolved_at), as well as the direction (asc/desc) of the results. The sort_by field and direction should be separated by a colon. A maximum of two fields can be included, separated by a comma. Sort direction defaults to ascending. */
        sort_by_incident_alerts: "created_at" | "resolved_at" | "created_at:asc" | "created_at:desc" | "resolved_at:asc" | "resolved_at:desc";
        /** @description Array of additional details to include. */
        include_incident_alerts: "services" | "first_trigger_log_entries" | "incidents";
        /** @description The id of the alert to retrieve. */
        alert_id: string;
        /** @description Count only incidents with the requested statuses. `all` returns all statuses. If `any` is specified, there will be an additional `any` boolean field in the response that is true if there are any incidents matching the criteria in the request. If no statuses are provided, then only the total count of incidents is returned regardless of status. More status codes may be introduced in the future. */
        statuses_incident_count: "triggered" | "acknowledged" | "resolved" | "any" | "all";
        /** @description Only return maintenance windows in a given state. */
        filter_maintenance_windows: "past" | "future" | "ongoing" | "open" | "all";
        /** @description The start of the date range over which you want to search. The time element is optional. */
        since_notifications: string;
        /** @description The end of the date range over which you want to search. This should be in the same format as since. The size of the date range must be less than 3 months. */
        until_notifications: string;
        /** @description Return notification of this type only. */
        filter_notifications: "sms_notification" | "email_notification" | "phone_notification" | "push_notification";
        /** @description Array of additional details to include. */
        include_notifications: "users";
        /** @description Array of additional details to include. */
        include_oncalls: "escalation_policies" | "users" | "schedules";
        /** @description Filters the results, showing only on-calls for the specified user IDs. */
        user_ids_oncalls: string[];
        /** @description Filters the results, showing only on-calls for the specified escalation policy IDs. */
        escalation_policy_ids_oncalls: string[];
        /** @description Filters the results, showing only on-calls for the specified schedule IDs. If `null` is provided in the array, it includes permanent on-calls due to direct user escalation targets. */
        schedule_ids_oncalls: string[];
        /** @description The start of the time range over which you want to search. If an on-call period overlaps with the range, it will be included in the result. Defaults to current time. On-call shifts are limited to 90 days in the future. */
        since_oncalls: string;
        /** @description The end of the time range over which you want to search. If an on-call period overlaps with the range, it will be included in the result. Defaults to current time. On-call shifts are limited to 90 days in the future, and the `until` time cannot be before the `since` time. */
        until_oncalls: string;
        /** @description This will filter on-calls such that only the earliest on-call for each combination of escalation policy, escalation level, and user is returned. This is useful for determining when the "next" on-calls are for a given set of filters. */
        earliest_oncalls: boolean;
        /**
         * @deprecated
         * @description When this parameter is present, only those Response Plays that can be run manually will be returned.
         */
        filter_for_manual_run: boolean;
        /** @description The id of the Event Rule to retrieve. */
        rule_id: string;
        /** @description The start of the date range over which you want to search. */
        since_schedules: string;
        /** @description The end of the date range over which you want to search. */
        until_schedules: string;
        /** @description When this parameter is present, only editable overrides will be returned. The result will only include the id of the override if this parameter is present. Only future overrides are editable. */
        editable_schedules: boolean;
        /** @description Any on-call schedule entries that pass the date range bounds will be truncated at the bounds, unless the parameter overflow=true is passed. This parameter defaults to false. */
        overflow_schedules: boolean;
        /** @description Array of additional details to include. */
        include_services: "escalation_policies" | "teams" | "integrations" | "auto_pause_notifications_parameters";
        /** @description Filters the results, showing only services with the specified name. */
        service_name: string;
        /** @description Array of additional details to include. */
        include_services_id: "escalation_policies" | "teams" | "auto_pause_notifications_parameters" | "integrations";
        /** @description Array of additional details to include. */
        include_services_integrations: "services" | "vendors";
        /**
         * @description Team to reassign unresolved incident to.
         *     If an unresolved incident exists on both the reassignment team and
         *     the team being deleted, a duplicate will not be made. If not supplied,
         *     unresolved incidents will be made account-level.
         */
        reassignment_team: string;
        /** @description Array of additional details to include. */
        include_notification_rules: "contact_methods";
        /** @description Array of additional attributes to any of the returned incidents for related incidents. */
        additional_details: "incident";
        /** @description Array of additional details to include. */
        include_schedules: "schedule_layers" | "overrides_subschedule" | "final_schedule";
        /** @description Specify an `user_id`, and the schedule list API will return information about this user's next on-call. */
        include_next_oncall_for_user: string;
        /** @description Used to specify the field you wish to sort the results on. */
        sort_by_event_orchestration: "name:asc" | "name:desc" | "routes:asc" | "routes:desc" | "created_at:asc" | "created_at:desc";
        /** @description The ID of an Event Orchestration. */
        event_orchestration_id: string;
        /** @description The ID of an Integration. */
        event_orchestration_integration_id: string;
        /** @description The ID of a Cache Variable. */
        event_orchestration_cache_variable_id: string;
        /** @description The incident urgency for which the notification rules are applied. If not specified, defaults to `high`. */
        urgency: "high" | "low" | "all";
        /** @description Template name or description to search */
        template_query: string;
        /** @description Filters templates by type. */
        template_type: string;
        /** @description Used to specify both the field you wish to sort the results on (name/created_at), as well as the direction (asc/desc) of the results. The sort_by field and direction should be separated by a colon. Sort direction defaults to ascending. */
        sort_by_template: "name" | "name:asc" | "name:desc" | "created_at" | "created_at:asc" | "created_at:desc";
        /** @description The start of the date range over which you want to show schedule entries. Defaults to 2 weeks before until if an until is given. Optional parameter. When provided with include[] for schedule types, populates the rendered_schedule_entries fields in the response. */
        schedule_since: string;
        /** @description The end of the date range over which you want to show schedule entries. Defaults to 2 weeks after since if a since is given. Optional parameter. When provided with include[] for schedule types, populates the rendered_schedule_entries fields in the response. */
        schedule_until: string;
        /** @description Specifies a filter to limit the scope of reporting to a particular service */
        paused_incident_reports_service_id: string;
        /** @description Specifies a filter to scope the response to either alerts suspended by Auto Pause or Event Rules. */
        paused_incident_reports_suspended_by: "auto_pause" | "rules";
        /** @description If provided, only show triggers configured to start the given workflow. Useful for listing all services associated with the given workflow */
        triggers_filter_workflow_id: string;
        /** @description If provided, only show triggers configured to start workflows whose name contain the provided value. */
        triggers_filter_workflow_name_contains: string;
        /** @description If provided, only show triggers configured on the service of the given incident. Useful for finding manual triggers that are configured on the service for a specific incident. Cannot be specified if `service_id` is provided. */
        triggers_filter_incident_id: string;
        /** @description If provided, only show triggers configured for incidents in the given service. Useful for listing all workflows associated with the given service. Cannot be specified if `incident_id` is provided. */
        triggers_filter_service_id: string;
        /** @description If provided, only show triggers of the given type. For example manual to search for manual triggers */
        triggers_filter_trigger_type: "manual" | "conditional" | "incident_type";
        /**
         * @deprecated
         * @description If provided, filters between disabled and enabled Triggers.
         *     This query parameter is deprecated, and will be removed in a future version of this API.
         */
        triggers_filter_is_disabled: boolean;
        /** @description Identifier for the Trigger */
        triggers_path_trigger_id: string;
        /** @description Identifier for the Service */
        triggers_path_service_id: string;
        /** @description The type of trigger the request is targeting */
        triggers_path_trigger_type: "manual" | "conditional";
        /** @description If provided, returns triggers sorted by the specified property. */
        triggers_sort_by: "workflow_id" | "workflow_id asc" | "workflow_id desc" | "workflow_name" | "workflow_name asc" | "workflow_name desc";
        /** @description If provided, only show actions tagged with the specified keyword */
        actions_filter_keyword: string;
        /** @description The id of the note. */
        note_id: string;
        /** @description The feature enablement identifier, typically the name of the product addon. Currently only `aiops` is supported. */
        enablement_feature_name: "aiops";
        /** @description Array of additional details to include. */
        include_customfields_field: "field_options";
        /** @description Array of additional details to include. */
        include_customfields_field_configuration: "fields";
        /** @description The ID of the field. */
        field_id: string;
        /** @description The ID of the field option. */
        field_option_id: string;
        /** @description The ID of the field configuration. */
        field_configuration_id: string;
        /** @description Array of additional Models to include in response. */
        include_ruleset_migrated_metadata: "migrated_metadata";
        active_standard: boolean;
        /** @description Id of the resource to apply the standards. */
        resource_id_standard: string;
        resource_type_standard: "technical_services";
        /** @description Ids of resources to apply the standards. Maximum of 100 items */
        resource_ids_standard: string[];
        /** @description Id of the standard */
        id_standard: string;
        query_resource_type_standard: "technical_service";
        /** @description Cursor to retrieve next page; only present if next page exists. */
        offset_after: string;
        /** @description Cursor to retrieve previous page; only present if not on first page. */
        offset_before: string;
        /** @description The ID of the Status Page. */
        status_page_id: string;
        /** @description The type of the Status Page. */
        status_page_type: "public" | "private";
        /** @description The ID of the Status Page Impact. */
        status_page_impact_id: string;
        /** @description Filter by Post type. */
        status_page_impact_post_type: "incident" | "maintenance";
        /** @description The ID of the Status Page Post Update. */
        status_page_post_update_id: string;
        /** @description Filter by the reviewed status of the Post Update to retrieve. */
        status_page_post_update_reviewed_status: "approved" | "not_reviewed";
        /** @description The ID of the Status Page Post. */
        status_page_post_id: string;
        /** @description Filter by Post type. */
        status_page_post_type: "incident" | "maintenance";
        /** @description Filter by the reviewed status of the Post to retrieve. */
        status_page_post_reviewed_status: "approved" | "not_reviewed";
        /** @description Filter by an array of Status identifiers. */
        status_page_post_status: string[];
        /** @description Array of additional Models to include in response. */
        status_page_post_include: "status_page_post_update"[];
        /** @description The ID of the Status Page service. */
        status_page_service_id: string;
        /** @description The ID of the Status Page severity. */
        status_page_severity_id: string;
        /** @description Filter by Post type. */
        status_page_severity_post_type: "incident" | "maintenance";
        /** @description The ID of the Status Page status. */
        status_page_status_id: string;
        /** @description Filter by Post type. */
        status_page_status_post_type: "incident" | "maintenance";
        /** @description The ID of the Status Page subscription. */
        status_page_subscription_id: string;
        /** @description Filter by Subscription status. */
        status_page_subscription_status: "active" | "pending";
        /** @description Filter by Subscription channel. */
        status_page_subscription_channel: "webhook" | "email" | "slack";
        /** @description Filter Integrations by application. */
        application: string[];
        /** @description The ID of the Workflow Integration */
        workflow_integrations_integration_id: string;
        /** @description Filter Integrations by partial name. */
        name: string;
    };
    requestBodies: {
        OrchestrationCacheVariablePostRequest: {
            content: {
                "application/json": {
                    cache_variable: components["schemas"]["OrchestrationCacheVariableRecentValue"] | components["schemas"]["OrchestrationCacheVariableTriggerEventCount"] | components["schemas"]["OrchestrationCacheVariableExternalData"];
                };
            };
        };
        OrchestrationCacheVariablePutRequest: {
            content: {
                "application/json": {
                    cache_variable: components["schemas"]["OrchestrationCacheVariableRecentValue"] | components["schemas"]["OrchestrationCacheVariableTriggerEventCount"] | components["schemas"]["OrchestrationCacheVariableExternalData"];
                };
            };
        };
        /** @description The updated data for an `external_data` type Cache Variable for this Event Orchestration. */
        OrchestrationCacheVariableDataPutRequest: {
            content: {
                "application/json": components["responses"]["OrchestrationCacheVariableGetDataResponse"]["content"]["application/json"]["schema"]["oneOf"]["0"] | components["responses"]["OrchestrationCacheVariableGetDataResponse"]["content"]["application/json"]["schema"]["oneOf"]["1"] | components["responses"]["OrchestrationCacheVariableGetDataResponse"]["content"]["application/json"]["schema"]["oneOf"]["2"];
            };
        };
        /** @description The data on an `external_data` type Cache Variable for this Event Orchestration. */
        OrchestrationCacheVariableDataPutResponse: {
            content: {
                "application/json": components["responses"]["OrchestrationCacheVariableGetDataResponse"]["content"]["application/json"]["schema"]["oneOf"]["0"] | components["responses"]["OrchestrationCacheVariableGetDataResponse"]["content"]["application/json"]["schema"]["oneOf"]["1"] | components["responses"]["OrchestrationCacheVariableGetDataResponse"]["content"]["application/json"]["schema"]["oneOf"]["2"];
            };
        };
        CreateWorkflowIntegrationConnection: {
            content: {
                "application/json": {
                    /** @description The ID of the connection */
                    readonly id?: string;
                    /** @description The type of the connection */
                    readonly type?: string;
                    /** @description The integration ID that this connection is associated with */
                    readonly integration_id?: string;
                    /** @description The name given to the connection */
                    name: string;
                    /** @description The URL of the service that this connection is associated with */
                    service_url?: string;
                    /** @description The ID of the external system that this connection is used to connect to */
                    external_id?: string;
                    /** @description The label of the external system that this connection is used to connect to */
                    external_id_label?: string;
                    scopes?: string[];
                    /** @description Whether or not this connection is the default connection for this integration */
                    is_default?: boolean;
                    readonly health?: {
                        /** @description Whether or not the connection is healthy */
                        readonly is_healthy?: boolean;
                        /** @description A message describing the health of the connection */
                        readonly health_message?: string;
                        /**
                         * Format: date-time
                         * @description The timestamp of the last health check
                         */
                        readonly last_checked_at?: string;
                    };
                    /**
                     * @description The configuration for this connection.
                     *     The configuration schema is defined in the Workflow Integration's `configuration_schema` property.
                     *     It is dynamic based on the specific Workflow Integration.
                     */
                    configuration?: Record<string, never>;
                    /**
                     * @description The secrets for this connection.
                     *     The secrets schema is defined in the Workflow Integration's `secrets_schema` property.
                     *     It is dynamic based on the specific Workflow Integration.
                     *     This field is write-only and will always be `null` on a response so that secrets are not leaked.
                     */
                    secrets: Record<string, never>;
                    /** @description The teams whose managers are allowed to use or edit this connection */
                    teams?: {
                        /** @description The ID of the team */
                        team_id?: string;
                        /** @enum {string} */
                        type?: "team_reference";
                    }[];
                    /** @description The app IDs for this connection */
                    apps?: {
                        /** @description The ID of the app */
                        app_id?: string;
                        /** @enum {string} */
                        type?: "pd_app_reference";
                    }[];
                };
            };
        };
        UpdateWorkflowIntegrationConnection: {
            content: {
                "application/json": {
                    /** @description The ID of the connection */
                    readonly id?: string;
                    /** @description The type of the connection */
                    readonly type?: string;
                    /** @description The integration ID that this connection is associated with */
                    readonly integration_id?: string;
                    /** @description The name given to the connection */
                    name: string;
                    /** @description The URL of the service that this connection is associated with */
                    service_url?: string;
                    /** @description The ID of the external system that this connection is used to connect to */
                    external_id?: string;
                    /** @description The label of the external system that this connection is used to connect to */
                    external_id_label?: string;
                    scopes?: string[];
                    /** @description Whether or not this connection is the default connection for this integration */
                    is_default?: boolean;
                    readonly health?: {
                        /** @description Whether or not the connection is healthy */
                        readonly is_healthy?: boolean;
                        /** @description A message describing the health of the connection */
                        readonly health_message?: string;
                        /**
                         * Format: date-time
                         * @description The timestamp of the last health check
                         */
                        readonly last_checked_at?: string;
                    };
                    /**
                     * @description The configuration for this connection.
                     *     The configuration schema is defined in the Workflow Integration's `configuration_schema` property.
                     *     It is dynamic based on the specific Workflow Integration.
                     */
                    configuration?: Record<string, never>;
                    /**
                     * @description The secrets for this connection.
                     *     The secrets schema is defined in the Workflow Integration's `secrets_schema` property.
                     *     It is dynamic based on the specific Workflow Integration.
                     *     This field is write-only and will always be `null` on a response so that secrets are not leaked.
                     */
                    secrets: Record<string, never>;
                    /** @description The teams whose managers are allowed to use or edit this connection */
                    teams?: {
                        /** @description The ID of the team */
                        team_id?: string;
                        /** @enum {string} */
                        type?: "team_reference";
                    }[];
                    /** @description The app IDs for this connection */
                    apps?: {
                        /** @description The ID of the app */
                        app_id?: string;
                        /** @enum {string} */
                        type?: "pd_app_reference";
                    }[];
                };
            };
        };
    };
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    createEntityTypeByIdChangeTags: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description Type of entity related with the tag */
                entity_type: components["parameters"]["entity_type"];
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description Array of tags and/or tag references to add to the entity.
                     *     For elements with type `tag_reference`, the tag with the corresponding `id` is added to the entity.
                     *     For elements with type `tag`, if there is an existing tag with the given
                     *     label that tag is added to the entity. If there is no existing tag with that label and the user has permission
                     *     to create tags, a new tag is created with that label and assigned to the entity.
                     */
                    add?: {
                        /** @enum {string} */
                        type: "tag" | "tag_reference";
                        /** @description The label of the tag. Should be used when type is "tag". */
                        label?: string;
                        /** @description The id of the tag. Should be used when type is "tag_reference". */
                        readonly id?: string;
                    }[];
                    /** @description Array of tag references to remove from the entity. */
                    remove?: {
                        /** @enum {string} */
                        type: "tag_reference";
                        /** @description The id of the tag */
                        readonly id: string;
                    }[];
                };
            };
        };
        responses: {
            /** @description The tags were added and/or removed. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getEntityTypeByIdTags: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description Type of entity related with the tag */
                entity_type: components["parameters"]["entity_type"];
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of tags. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        tags: components["schemas"]["Tag"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listAbilities: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of ability names. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The set of abilities your account has. */
                        abilities: string[];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAbility: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The account has the requested ability. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listAddon: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_addon"];
                /** @description Filters the results, showing only Add-ons for the given services */
                "service_ids[]"?: components["parameters"]["addon_services"];
                /** @description Filters the results, showing only Add-ons of the given type */
                filter?: components["parameters"]["addon_filter"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of installed Add-ons. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        addons: components["schemas"]["AddonReference"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createAddon: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description The Add-on to be installed. */
        requestBody?: {
            content: {
                "application/json": {
                    addon: components["schemas"]["Addon"];
                };
            };
        };
        responses: {
            /** @description The Add-on that was installed. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        addon: components["schemas"]["AddonReference"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAddon: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requested Add-on. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        addon: components["schemas"]["Addon"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateAddon: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The Add-on to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    addon: components["schemas"]["Addon"];
                };
            };
        };
        responses: {
            /** @description The Add-on that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        addon: components["schemas"]["Addon"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteAddon: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Add-on was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listAlertGroupingSettings: {
        parameters: {
            query?: {
                /** @description Cursor to retrieve next page; only present if next page exists. */
                after?: components["parameters"]["offset_after"];
                /** @description Cursor to retrieve previous page; only present if not on first page. */
                before?: components["parameters"]["offset_before"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description An array of service IDs. Only results related to these services will be returned. */
                "service_ids[]"?: components["parameters"]["services"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of alert grouping settings. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The list of alert grouping settings your account has. */
                        alert_grouping_settings: components["schemas"]["AlertGroupingSetting"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
        };
    };
    postAlertGroupingSettings: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    alert_grouping_setting: components["schemas"]["AlertGroupingSetting"];
                };
            };
        };
        responses: {
            /** @description The new Alert Grouping Setting. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        alert_grouping_setting: components["schemas"]["AlertGroupingSetting"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
        };
    };
    getAlertGroupingSetting: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Alert Grouping Setting. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        alert_grouping_setting: components["schemas"]["AlertGroupingSetting"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    putAlertGroupingSetting: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    alert_grouping_setting: components["schemas"]["AlertGroupingSetting"];
                };
            };
        };
        responses: {
            /** @description The updated Alert Grouping Setting. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        alert_grouping_setting: components["schemas"]["AlertGroupingSetting"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    deleteAlertGroupingSetting: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Alert Grouping Setting was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            404: components["responses"]["NotFound"];
        };
    };
    getAnalyticsMetricsIncidentsAll: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsModel"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            /** @description Mean count of instances where responders were assigned an incident (including through reassignment or escalation) or accepted a responder request. */
                            mean_assignment_count?: number;
                            /**
                             * @description Mean engaged time across all responders.
                             *     Engaged time is measured from the time a user engages with an incident (by
                             *     acknowledging or accepting a responder request) until the incident is resolved.
                             *     This may include periods in which the incidents were snoozed.
                             */
                            mean_engaged_seconds?: number;
                            /**
                             * @description Mean number of users who engaged with an incident. *Engaged* is defined as
                             *     acknowledging an incident or accepting a responder request in it.
                             */
                            mean_engaged_user_count?: number;
                            /**
                             * @description A measure of *people response time*. This metric measures the time from
                             *     the first user engagement (acknowledge or responder accept) to the last.
                             *     This metric is only used for incidents with **multiple responders**;
                             *     for incidents with one or no engaged users, this value is null.
                             */
                            mean_seconds_to_engage?: number;
                            /** @description Mean time between the start of an incident, and the first responder to acknowledge. */
                            mean_seconds_to_first_ack?: number;
                            /**
                             * @description Mean time between the start of an incident, and the last additional responder
                             *     to acknowledge. For incidents with one or no engaged users, this value is null.
                             */
                            mean_seconds_to_mobilize?: number;
                            /** @description Mean time from when an incident was triggered until it was resolved. */
                            mean_seconds_to_resolve?: number;
                            /**
                             * @description Mean engaged time across all responders. Engaged time is measured from the time
                             *     a user engages with an incident (by acknowledging or accepting a responder request)
                             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
                             *     This metric uses the incident response effort values that
                             *     [users have defined](https://support.pagerduty.com/docs/edit-incidents#edit-incident-duration),
                             *     if they exist.
                             */
                            mean_user_defined_engaged_seconds?: number;
                            /** @description Median time between the start of an incident, and the first responder to acknowledge. */
                            p50_seconds_to_first_ack?: number;
                            /** @description Median time from when an incident was triggered until it was resolved. */
                            p50_seconds_to_resolve?: number;
                            /** @description 75th percentile for the time between the start of an incident, and the first responder to acknowledge. */
                            p75_seconds_to_first_ack?: number;
                            /** @description 75th percentile for the time when an incident was triggered until it was resolved. */
                            p75_seconds_to_resolve?: number;
                            /** @description 90th percentile for the time between the start of an incident, and the first responder to acknowledge. */
                            p90_seconds_to_first_ack?: number;
                            /** @description 90th percentile for the time when an incident was triggered until it was resolved. */
                            p90_seconds_to_resolve?: number;
                            /** @description 95th percentile for the time between the start of an incident, and the first responder to acknowledge. */
                            p95_seconds_to_first_ack?: number;
                            /** @description 95th percentile for the time when an incident was triggered until it was resolved. */
                            p95_seconds_to_resolve?: number;
                            /** @description Start of the date range for which the metrics were calculated. Only included when an aggregate unit is specified in the request. */
                            range_start?: string;
                            /** @description ID of the service. Only included when aggregating by service. Not included when aggregating by all. */
                            service_id?: string;
                            /** @description Name of the service. Only included when aggregating by service. Not included when aggregating by all. */
                            service_name?: string;
                            /** @description ID of the team to which the incident was assigned. Not included when aggregating by all. */
                            team_id?: string;
                            /** @description Name of the team to which the incident was assigned. Not included when aggregating by all. */
                            team_name?: string;
                            /** @description Total number of unique interruptions during business hours; 8am-6pm Mon-Fri, based on the users time zone. */
                            total_business_hour_interruptions?: number;
                            /**
                             * @description Total engaged time across all responders. Engaged time is measured from
                             *     the time a user engages with an incident (by acknowledging or accepting a responder request)
                             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
                             */
                            total_engaged_seconds?: number;
                            /**
                             * @description Total count of instances where an incident is escalated between responders
                             *     assigned to an escalation policy.
                             */
                            total_escalation_count?: number;
                            /** @description The total number of incidents that were created. */
                            total_incident_count?: number;
                            /**
                             * @description The total count of assigned incidents acknowledged.
                             *     Only explicit incident acknowledgment counts; reassign, resolve, and escalation actions do not imply acknowledgement.
                             */
                            total_incidents_acknowledged?: number;
                            /**
                             * @description The total count of incidents that were resolved automatically.
                             *     This count includes incidents resolved via an integration and those that were [auto-resolved in PagerDuty](https://support.pagerduty.com/docs/configurable-service-settings#auto-resolution).
                             */
                            total_incidents_auto_resolved?: unknown;
                            /** @description The total count of incidents that were manually escalated. */
                            total_incidents_manual_escalated?: number;
                            /** @description The total count of incidents that were reassigned. */
                            total_incidents_reassigned?: number;
                            /** @description The total count of incidents that were escalated due to timeouts. */
                            total_incidents_timeout_escalated?: number;
                            /** @description Total number of unique interruptions. */
                            total_interruptions?: number;
                            /** @description The total count of incident notifications sent via email, SMS, phone call and push. */
                            total_notifications?: number;
                            /** @description Total number of unique interruptions during off hours; 6pm-10pm Mon-Fri and all day Sat-Sun, based on the users time zone. */
                            total_off_hour_interruptions?: number;
                            /**
                             * @description Total number of unique interruptions during sleep hours.
                             *     Sleep hours: 10pm-8am every day, based on the users time zone.
                             */
                            total_sleep_hour_interruptions?: number;
                            /** @description Total number of seconds incidents were snoozed. */
                            total_snoozed_seconds?: number;
                            /**
                             * @description Total engaged time across all responders. Engaged time is measured from
                             *     the time a user engages with an incident (by acknowledging or accepting a responder request)
                             *     until the incident is resolved. This may include periods in which the incidents were snoozed.
                             *     This metric uses the edited incident response effort values that
                             *     [users have defined](https://support.pagerduty.com/docs/edit-incidents#edit-incident-duration),
                             *     if they exist.
                             */
                            total_user_defined_engaged_seconds?: number;
                            /**
                             * @description The percentage of time in the defined date range that the service was not interrupted
                             *     by a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents).
                             *     Only included when aggregating by team, escalation policy, service, or all services.
                             */
                            up_time_pct?: number;
                        }[];
                    } & components["schemas"]["AnalyticsModel"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsIncidentsEscalationPolicy: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsModel"];
            };
        };
        responses: {
            /** @description Only returns data for escalation policies that match the filters and have data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["AnalyticsIncidentMetricsEscalationPolicy"][];
                    } & components["schemas"]["AnalyticsModel"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsIncidentsEscalationPolicyAll: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsModel"];
            };
        };
        responses: {
            /** @description Only returns data for escalation policies that match the filters and have data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["AnalyticsIncidentMetricsEscalationPolicy"][];
                    } & components["schemas"]["AnalyticsModel"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsIncidentsService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsModel"];
            };
        };
        responses: {
            /** @description Only returns data for services that match the filters and have data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["AnalyticsIncidentMetrics"][];
                    } & components["schemas"]["AnalyticsModel"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsIncidentsServiceAll: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsModel"];
            };
        };
        responses: {
            /** @description Only returns data for services that match the filters and have data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["AnalyticsIncidentMetrics"][];
                    } & components["schemas"]["AnalyticsModel"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsIncidentsTeam: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsModel"];
            };
        };
        responses: {
            /** @description Only returns data for teams that match the filters and have data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["AnalyticsIncidentMetrics"][];
                    } & components["schemas"]["AnalyticsModel"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsIncidentsTeamAll: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsModel"];
            };
        };
        responses: {
            /** @description Only returns data for teams that match the filters and have data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["AnalyticsIncidentMetrics"][];
                    } & components["schemas"]["AnalyticsModel"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsPdAdvanceUsageFeatures: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsPdAdvanceUsageFilter"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: {
                            /** @description Which feature of PD Advance was used. */
                            feature_id?: string;
                            /** @description How many credits were used by this feature. */
                            total_credits_used?: number;
                            /** @description How many times this feature was used. */
                            total_use_count?: number;
                            /** @description How many of the credits used were initiated by PD Advance rather than a user. */
                            total_proactive_credits_used?: number;
                            /** @description How many times this feature was initiated by PD Advance rather than a user. */
                            total_proactive_use_count?: number;
                        }[];
                    } & components["schemas"]["AnalyticsPdAdvanceUsageFilter"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsRespondersAll: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsResponderFilter"];
            };
        };
        responses: {
            /** @description Only returns data for responders that match the filters and have data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["AnalyticsResponderMetrics"][];
                    } & components["schemas"]["AnalyticsResponderFilter"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsRespondersTeam: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsResponderFilter"];
            };
        };
        responses: {
            /** @description Only returns data for responders and teams that match the filters and have data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["AnalyticsResponderMetrics"][];
                    } & components["schemas"]["AnalyticsResponderFilter"];
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsMetricsUsersAll: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsUserFilter"];
            };
        };
        responses: {
            /** @description Returns user metrics aggregated across the account */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        data?: components["schemas"]["AnalyticsUserMetrics"][];
                        filters?: {
                            /**
                             * Format: date-time
                             * @description The start of the date range used for filtering
                             */
                            created_at_start?: string;
                            /**
                             * Format: date-time
                             * @description The end of the date range used for filtering
                             */
                            created_at_end?: string;
                            /** @description The team IDs used for filtering */
                            team_ids?: string[];
                        };
                        /** @description The time zone used for the results */
                        time_zone?: string;
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsIncidents: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Filters the result, only show incidents that match the conditions passed in the filter. */
                    filters?: {
                        /**
                         * @description Filters the result, showing only the incidents where the creation timestamp is greater than or equal to the filter value.
                         * @example 2023-05-01T00:00:00-04:00
                         */
                        created_at_start?: string;
                        /**
                         * @description Filters the result, showing only the incidents where the creation timestamp is less than the filter value.
                         * @example 2023-06-01T00:00:00-04:00
                         */
                        created_at_end?: string;
                        /** @description Filters the result, showing only incidents where the updated_at value is greater than the filter value. */
                        updated_after?: string;
                        /**
                         * @description Filters the result, showing only the incidents where urgency matches the filter value.
                         * @example high
                         */
                        urgency?: string;
                        /**
                         * @description An incident is classified as a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents) if it has one of the two highest priorities, or if multiple responders are added and acknowledge the incident.
                         * @example true
                         */
                        major?: boolean;
                        /**
                         * @description An array of team IDs. Only incidents that are assigned to a member of these teams will be returned. Account must have the teams ability to use this parameter.
                         * @example [
                         *       "P373JQQ",
                         *       "PAECHJV",
                         *       "P7SYGW6"
                         *     ]
                         */
                        team_ids?: string[];
                        /**
                         * @description An array of service IDs. Only results related to these services will be returned.
                         * @example [
                         *       "PC8O0L3",
                         *       "PX01HJD",
                         *       "P5FK83M"
                         *     ]
                         */
                        service_ids?: string[];
                        /**
                         * @description The priority_ids filter applied to the results.
                         * @example [
                         *       "PITMC5Y",
                         *       "PEHBBT8",
                         *       "PB8QADI"
                         *     ]
                         */
                        priority_ids?: string[];
                        /**
                         * @description The priority_names filter applied to the results.
                         * @example [
                         *       "P1",
                         *       "P2",
                         *       "P3"
                         *     ]
                         */
                        priority_names?: string[];
                        /**
                         * @description Filter incidents by specific incident type IDs. Only incidents matching the given IDs will be returned.
                         * @example [
                         *       "PIJ90N7",
                         *       "PKL73Z2"
                         *     ]
                         */
                        incident_type_ids?: string[];
                    };
                    /** @description A cursor to indicate the reference point that the results should follow */
                    starting_after?: string;
                    /** @description A cursor to indicate the reference point that the results should precede */
                    ending_before?: string;
                    /**
                     * @description The order the results;  asc for ascending, desc for descending. Defaults to 'desc'.
                     * @enum {string}
                     */
                    order?: "asc" | "desc";
                    /**
                     * @description The column to use for ordering the results. Defaults to 'created_at'.
                     * @enum {string}
                     */
                    order_by?: "created_at" | "seconds_to_resolve";
                    /**
                     * @description Number of results to include in each batch.
                     *     Limits between 1 to 1000 are accepted.
                     * @example 20
                     */
                    limit?: number;
                    /**
                     * @description The time zone to use for the results.
                     * @example Etc/UTC
                     */
                    time_zone?: string;
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Cursor to identify the first object in the response. */
                        first: string;
                        /** @description Cursor to identify the last object in the response. */
                        last: string;
                        /** @description Number of results to include in the batch. */
                        limit: number;
                        /** @description Indicates if there are more resources available than were returned. */
                        more: boolean;
                        /**
                         * @description The order in which the results were sorted;  asc for ascending, desc for descending.
                         * @enum {string}
                         */
                        order: "asc" | "desc";
                        /**
                         * @description The column that was used for ordering the results.
                         * @enum {string}
                         */
                        order_by: "created_at" | "seconds_to_resolve" | "updated_at";
                        /** @description A collection of filters that were applied to the results. */
                        filters?: {
                            /** @description The lower boundary for the created_at range filter applied to the results. */
                            created_at_start?: string;
                            /** @description The upper boundary for the created_at range filter applied to the results. */
                            created_at_end?: string;
                            /**
                             * @description The urgency filter applied to the results.
                             * @enum {string}
                             */
                            urgency?: "high" | "low";
                            /** @description The [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents) filter applied to the results. */
                            major?: boolean;
                            /** @description The team_ids filter applied to the results. */
                            team_ids?: string[];
                            /** @description The service_ids filter applied to the results. */
                            service_ids?: string[];
                            /** @description The priority_ids filter applied to the results. */
                            priority_ids?: string[];
                            /** @description The priority_names filter applied to the results. */
                            priority_names?: string[];
                            /** @description The incident_type_ids filter applied to the results. */
                            incident_type_ids?: string[];
                        };
                        /** @description The time zone that the results are in. */
                        time_zone: string;
                        data: components["schemas"]["AnalyticsRawIncident"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsIncidentsById: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AnalyticsRawIncident"];
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsIncidentResponsesById: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description Parameters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description Number of results to include in each batch.
                     *     Limits between 1 to 1000 are accepted.
                     * @example 20
                     */
                    limit?: number;
                    /**
                     * @description The order in which to display the results; asc for ascending, desc for descending. Defaults to `desc`.
                     * @enum {string}
                     */
                    order?: "asc" | "desc";
                    /**
                     * @description The column to use for ordering the results.
                     * @enum {string}
                     */
                    order_by?: "requested_at";
                    /**
                     * @description The time zone to use for the results.
                     * @example Etc/UTC
                     */
                    time_zone?: string;
                };
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The Incident ID passed into the request. */
                        incident_id?: string;
                        /** @description Number of results to include in the batch. */
                        limit?: number;
                        /**
                         * @description The order in which the results were sorted; asc for ascending, desc for descending.
                         * @enum {string}
                         */
                        order?: "asc" | "desc";
                        /**
                         * @description The column that was used for ordering the results.
                         * @enum {string}
                         */
                        order_by?: "requested_at";
                        /** @description The time zone that the results are in. */
                        time_zone?: string;
                        responses?: components["schemas"]["AnalyticsRawIncidentResponses"][];
                    };
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsResponderIncidents: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the responder. */
                responder_id: components["parameters"]["responder_id"];
            };
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Filters the result, only show incidents that match the conditions passed in the filter. */
                    filters?: {
                        /**
                         * @description Filters the result, showing only the incidents where the creation timestamp is greater than the filter value.
                         * @example 2023-05-01T00:00:00-04:00
                         */
                        created_at_start?: string;
                        /**
                         * @description Filters the result, showing only the incidents where the creation timestamp is less than the filter value.
                         * @example 2023-06-01T00:00:00-04:00
                         */
                        created_at_end?: string;
                        /**
                         * @description Filters the result, showing only the incidents where urgency matches the filter value.
                         * @example high
                         */
                        urgency?: string;
                        /**
                         * @description An incident is classified as a [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents) if it has one of the two highest priorities, or if multiple responders are added and acknowledge the incident.
                         * @example true
                         */
                        major?: boolean;
                        /**
                         * @description An array of team IDs. Only incidents that are assigned to a member of these teams will be returned. Account must have the teams ability to use this parameter.
                         * @example [
                         *       "P373JQQ",
                         *       "PAECHJV",
                         *       "P7SYGW6"
                         *     ]
                         */
                        team_ids?: string[];
                        /**
                         * @description An array of service IDs. Only results related to these services will be returned.
                         * @example [
                         *       "PC8O0L3",
                         *       "PX01HJD",
                         *       "P5FK83M"
                         *     ]
                         */
                        service_ids?: string[];
                        /**
                         * @description The priority_ids filter applied to the results.
                         * @example [
                         *       "PITMC5Y",
                         *       "PEHBBT8",
                         *       "PB8QADI"
                         *     ]
                         */
                        priority_ids?: string[];
                        /**
                         * @description The priority_names filter applied to the results.
                         * @example [
                         *       "P1",
                         *       "P2",
                         *       "P3"
                         *     ]
                         */
                        priority_names?: string[];
                        /**
                         * @description Filter incidents by specific incident type IDs. Only incidents matching the given IDs will be returned.
                         * @example [
                         *       "PIJ90N7",
                         *       "PKL73Z2"
                         *     ]
                         */
                        incident_type_ids?: string[];
                    };
                    /** @description A cursor to indicate the reference point that the results should follow */
                    starting_after?: string;
                    /** @description A cursor to indicate the reference point that the results should precede */
                    ending_before?: string;
                    /**
                     * @description The order in which to display the results; asc for ascending, desc for descending. Defaults to `desc`.
                     * @enum {string}
                     */
                    order?: "asc" | "desc";
                    /**
                     * @description The column to use for ordering the results. Defaults to `incident_created_at`.
                     * @enum {string}
                     */
                    order_by?: "incident_created_at";
                    /**
                     * @description Number of results to include in each batch.
                     *     Limits between 1 to 1000 are accepted.
                     * @example 20
                     */
                    limit?: number;
                    /**
                     * @description The time zone to use for the results.
                     * @example Etc/UTC
                     */
                    time_zone?: string;
                };
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Cursor to identify the first object in the response. */
                        first?: string;
                        /** @description Cursor to identify the last object in the response. */
                        last?: string;
                        /** @description The Responder ID passed into the request. */
                        responder_id?: string;
                        /** @description Number of results to include in the batch. */
                        limit?: number;
                        /**
                         * @description The order in which the results were sorted; asc for ascending, desc for descending.
                         * @enum {string}
                         */
                        order?: "asc" | "desc";
                        /**
                         * @description The column that was used for ordering the results.
                         * @enum {string}
                         */
                        order_by?: "incident_created_at";
                        /** @description The time zone that the results are in. */
                        time_zone?: string;
                        /** @description A collection of filters that were applied to the results. */
                        filters?: {
                            /** @description The lower boundary for the created_at range filter applied to the results. */
                            created_at_start?: string;
                            /** @description The upper boundary for the created_at range filter applied to the results. */
                            created_at_end?: string;
                            /**
                             * @description The urgency filter applied to the results.
                             * @enum {string}
                             */
                            urgency?: "high" | "low";
                            /** @description The [major incident](https://support.pagerduty.com/docs/operational-reviews#major-incidents) filter applied to the results. */
                            major?: boolean;
                            /** @description The team_ids filter applied to the results. */
                            team_ids?: string[];
                            /** @description The service_ids filter applied to the results. */
                            service_ids?: string[];
                            /** @description The priority_ids filter applied to the results. */
                            priority_ids?: string[];
                            /** @description The priority_names filter applied to the results. */
                            priority_names?: string[];
                            /** @description The incident_type_ids filter applied to the results. */
                            incident_type_ids?: string[];
                        };
                        data?: components["schemas"]["AnalyticsRawResponderIncidents"][];
                    };
                };
            };
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getAnalyticsUsers: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description Parameters and filters to apply to the dataset. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["AnalyticsUserFilter"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Cursor to identify the first object in the response. */
                        first?: string;
                        /** @description Cursor to identify the last object in the response. */
                        last?: string;
                        /** @description Number of results to include in the batch. */
                        limit?: number;
                        /** @description Indicates if there are more resources available than were returned. */
                        more?: boolean;
                        /**
                         * @description The order in which the results were sorted; asc for ascending, desc for descending.
                         * @enum {string}
                         */
                        order?: "asc" | "desc";
                        /**
                         * @description The column that was used for ordering the results.
                         * @default name
                         */
                        order_by: string;
                        /** @description A collection of filters that were applied to the results. */
                        filters?: {
                            /** @description The lower boundary for the created_at range filter applied to the results. */
                            created_at_start?: string;
                            /** @description The upper boundary for the created_at range filter applied to the results. */
                            created_at_end?: string;
                            /** @description The team_ids filter applied to the results. */
                            team_ids?: string[];
                            /** @description The roles filter applied to the results. */
                            roles?: string[];
                        };
                        /** @description The time zone that the results are in. */
                        time_zone?: string;
                        data?: components["schemas"]["AnalyticsRawUser"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listAuditRecords: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description The start of the date range over which you want to search. If not specified, defaults to `now() - 24 hours` (past 24 hours) */
                since?: components["parameters"]["audit_since"];
                /** @description The end of the date range over which you want to search. If not specified, defaults to `now()`. May not be more than 31 days after `since`. */
                until?: components["parameters"]["audit_until"];
                /** @description Resource type filter for the root_resource. */
                "root_resource_types[]"?: components["parameters"]["audit_root_resource_types"];
                /** @description Actor type filter. */
                actor_type?: components["parameters"]["audit_actor_type"];
                /** @description Actor Id filter. Must be qualified by providing the `actor_type` param. */
                actor_id?: components["parameters"]["audit_actor_id"];
                /** @description Method type filter. */
                method_type?: components["parameters"]["audit_method_type"];
                /** @description Method truncated_token filter. Must be qualified by providing the `method_type` param. */
                method_truncated_token?: components["parameters"]["audit_method_truncated_token"];
                /** @description Action filter */
                "actions[]"?: components["parameters"]["audit_actions"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Records matching the query criteria. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditRecordResponseSchema"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAllAutomationActions: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description Filters results to include the ones matching the name (case insensitive substring matching) */
                name?: components["parameters"]["automation_actions_name"];
                /**
                 * @description Filters results to include the ones linked to the specified runner.
                 *     Specifying the value `any` filters results to include the ones linked to runners only,
                 *     thus omitting the results not linked to runners.
                 */
                runner_id?: components["parameters"]["automation_actions_runner_id"];
                /** @description Filters results to include the ones matching the specified classification (aka category) */
                classification?: components["parameters"]["automation_actions_classification"];
                /** @description Filters results to include the ones associated with the specified team. */
                team_id?: components["parameters"]["automation_actions_team_id"];
                /** @description Filters results to include the ones associated with the specified service */
                service_id?: components["parameters"]["automation_actions_service_id"];
                /** @description Filters results to include the ones matching the specified action type */
                action_type?: components["parameters"]["automation_actions_action_type"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of actions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        actions: (components["schemas"]["AutomationActionsScriptAction"] | components["schemas"]["AutomationActionsProcessAutomationJobAction"])[];
                    } & {
                        privileges?: components["schemas"]["AutomationActionsUserPermissions"];
                    } & components["schemas"]["CursorPagination"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createAutomationAction: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    action: components["schemas"]["AutomationActionsScriptActionPostBody"] | components["schemas"]["AutomationActionsProcessAutomationJobActionPostBody"];
                };
            };
        };
        responses: {
            /** @description Action information */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        action: components["schemas"]["AutomationActionsScriptActionWithTeams"] | components["schemas"]["AutomationActionsProcessAutomationJobActionWithTeams"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationAction: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Action information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        action: components["schemas"]["AutomationActionsScriptActionWithTeams"] | components["schemas"]["AutomationActionsProcessAutomationJobActionWithTeams"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateAutomationAction: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    action: components["schemas"]["AutomationActionsScriptActionPutBody"] | components["schemas"]["AutomationActionsProcessAutomationJobActionPutBody"];
                };
            };
        };
        responses: {
            /** @description Action information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        action: components["schemas"]["AutomationActionsScriptActionWithTeams"] | components["schemas"]["AutomationActionsProcessAutomationJobActionWithTeams"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteAutomationAction: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createAutomationActionInvocation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    invocation: {
                        metadata: {
                            incident_id: string;
                            alert_id?: string;
                        };
                    };
                };
            };
        };
        responses: {
            /** @description Created invocation */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        invocation: components["schemas"]["AutomationActionsInvocation"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationActionsActionServiceAssociations: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of service references */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        services?: components["schemas"]["ServiceReference"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createAutomationActionServiceAssocation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    service: components["schemas"]["ServiceReference"];
                };
            };
        };
        responses: {
            /** @description The action-service association was created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        service: components["schemas"]["ServiceReference"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationActionsActionServiceAssociation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Service reference */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        service?: components["schemas"]["ServiceReference"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteAutomationActionServiceAssociation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationActionsActionTeamAssociations: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        teams?: components["schemas"]["TeamReference"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createAutomationActionTeamAssociation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    team: components["schemas"]["TeamReference"];
                };
            };
        };
        responses: {
            /** @description The action-team association was created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        team: components["schemas"]["TeamReference"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationActionsActionTeamAssociation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The team ID */
                team_id: components["parameters"]["team_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        team?: components["schemas"]["TeamReference"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteAutomationActionTeamAssociation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The team ID */
                team_id: components["parameters"]["team_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listAutomationActionInvocations: {
        parameters: {
            query?: {
                /** @description Invocation state */
                invocation_state?: components["parameters"]["automation_actions_invocation_state"];
                /** @description Invocation state inverse filter (matches invocations NOT in the specified state) */
                not_invocation_state?: components["parameters"]["automation_actions_not_invocation_state"];
                /** @description Incident ID */
                incident_id?: components["parameters"]["automation_actions_incident_id"];
                /** @description Action ID */
                action_id?: components["parameters"]["automation_actions_action_id"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Invocations matching the criteria */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of invocations sorted by creation_time in reverse chronological order (newest invocations first). At most 25 invocations are returned. */
                        invocations: components["schemas"]["AutomationActionsInvocation"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationActionsInvocation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Invocation information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        invocation: components["schemas"]["AutomationActionsInvocation"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationActionsRunners: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description Filters results to include the ones matching the name (case insensitive substring matching) */
                name?: components["parameters"]["automation_actions_name"];
                /** @description Includes additional data elements into the response */
                "include[]"?: components["parameters"]["automation_actions_runners_include"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Runners matching the criteria. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        runners?: components["schemas"]["AutomationActionsRunner"][];
                    } & {
                        privileges?: components["schemas"]["AutomationActionsUserPermissions"];
                    } & components["schemas"]["CursorPagination"];
                };
            };
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createAutomationActionsRunner: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    runner: components["schemas"]["AutomationActionsRunnerSidecarPostBody"] | components["schemas"]["AutomationActionsRunnerRunbookPostBody"];
                };
            };
        };
        responses: {
            /** @description Runner information */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        runner: components["schemas"]["AutomationActionsRunner"] & {
                            /** @description Secret used for authentication of sidecar runner_types */
                            secret?: string;
                        };
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationActionsRunner: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Runner information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        runner: components["schemas"]["AutomationActionsRunner"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateAutomationActionsRunner: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    runner: components["schemas"]["AutomationActionsRunnerSidecarBody"] | components["schemas"]["AutomationActionsRunnerRunbookBody"];
                };
            };
        };
        responses: {
            /** @description Runner information */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        runner: components["schemas"]["AutomationActionsRunner"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteAutomationActionsRunner: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationActionsRunnerTeamAssociations: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        teams?: components["schemas"]["TeamReference"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createAutomationActionsRunnerTeamAssociation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    team: components["schemas"]["TeamReference"];
                };
            };
        };
        responses: {
            /** @description The runner-team association that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        team: components["schemas"]["TeamReference"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getAutomationActionsRunnerTeamAssociation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The team ID */
                team_id: components["parameters"]["team_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        team?: components["schemas"]["TeamReference"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteAutomationActionsRunnerTeamAssociation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The team ID */
                team_id: components["parameters"]["team_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Ok. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listBusinessServices: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of services. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        business_services: components["schemas"]["BusinessService"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
        };
    };
    createBusinessService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description The Business Service to be created */
                    business_service?: {
                        /** @description The name of the Business Service. */
                        name?: string;
                        /** @description The description of the Business Service. */
                        description?: string;
                        /** @description The owner of the Business Service. */
                        point_of_contact?: string;
                        /**
                         * Team
                         * @description Reference to the team that owns the Business Service.
                         */
                        team?: {
                            /** @description The Team ID */
                            id?: string;
                        };
                    };
                };
            };
        };
        responses: {
            /** @description The Business Service that was created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        business_service: components["schemas"]["BusinessService"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    getBusinessService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The service business requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        business_service: components["schemas"]["BusinessService"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateBusinessService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description The Business Service to be created */
                    business_service?: {
                        /** @description The name of the Business Service. */
                        name?: string;
                        /** @description The description of the Business Service. */
                        description?: string;
                        /** @description The owner of the Business Service. */
                        point_of_contact?: string;
                        /**
                         * Team
                         * @description Reference to the team that owns the Business Service.
                         */
                        team?: {
                            /** @description The team ID */
                            id?: string;
                        };
                    };
                };
            };
        };
        responses: {
            /** @description The Business Service that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        business_service: components["schemas"]["BusinessService"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    deleteBusinessService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Business Service was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    createBusinessServiceAccountSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        account_is_subscribed: boolean;
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    removeBusinessServiceAccountSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The account was unsubscribed successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getBusinessServiceSubscribers: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        subscribers?: components["schemas"]["NotificationSubscriber"][];
                    } & {
                        /** @description The ID of the account belonging to the subscriber entity */
                        account_id?: string;
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createBusinessServiceNotificationSubscribers: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The entities to subscribe. */
        requestBody?: {
            content: {
                "application/json": {
                    subscribers: components["schemas"]["NotificationSubscriber"][];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        subscriptions?: components["schemas"]["NotificationSubscriptionWithContext"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getBusinessServiceSupportingServiceImpacts: {
        parameters: {
            query?: {
                /** @description Provides access to additional fields such as highest priority per business service and total impacted count */
                "additional_fields[]"?: components["parameters"]["impacts_additional_fields"];
                /** @description The IDs of the resources. */
                "ids[]"?: components["parameters"]["ids"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LiveListResponse"] & {
                        services?: components["schemas"]["Impact"][];
                    } & {
                        additional_fields?: {
                            total_impacted_count?: number;
                        };
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    removeBusinessServiceNotificationSubscriber: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The entities to unsubscribe. */
        requestBody?: {
            content: {
                "application/json": {
                    subscribers: components["schemas"]["NotificationSubscriber"][];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        deleted_count: number;
                        unauthorized_count: number;
                        non_existent_count: number;
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getBusinessServiceTopLevelImpactors: {
        parameters: {
            query?: {
                /** @description The IDs of the resources. */
                "ids[]"?: components["parameters"]["ids"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LiveListResponse"] & {
                        impactors?: components["schemas"]["Impactor"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getBusinessServiceImpacts: {
        parameters: {
            query?: {
                /** @description Provides access to additional fields such as highest priority per business service and total impacted count */
                "additional_fields[]"?: components["parameters"]["impacts_additional_fields"];
                /** @description The IDs of the resources. */
                "ids[]"?: components["parameters"]["ids"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LiveListResponse"] & {
                        services?: components["schemas"]["Impact"][];
                    } & {
                        additional_fields?: {
                            total_impacted_count?: number;
                        };
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getBusinessServicePriorityThresholds: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        global_threshold?: {
                            id?: string;
                            order?: number;
                        } | null;
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    putBusinessServicePriorityThresholds: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        /**
         * @description Set the `id` and `order` of the global Priority Threshold. These values can be obtained by calling the `/priorities` endpoint.
         *
         *     Once set, Incidents must be at or above the specified level in order to impact Business Services.  An exception to this rule is if the Incident has been added to the incident directly using the `PUT /incidents/{id}/business_services/{business_service_id}/impacts` endpoint.
         */
        requestBody?: {
            content: {
                "application/json": {
                    global_threshold: {
                        id: string;
                        order: number;
                    };
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        global_threshold: {
                            id: string;
                            order: number;
                        };
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    deleteBusinessServicePriorityThresholds: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Priority Threshold for the account was successfully cleared. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listChangeEvents: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter. */
                "team_ids[]"?: components["parameters"]["team_ids"];
                /** @description An array of integration IDs. Only results related to these integrations will be returned. */
                "integration_ids[]"?: components["parameters"]["integration_ids"];
                /** @description The start of the date range over which you want to search, as a UTC ISO 8601 datetime string. Will return an HTTP 400 for non-UTC datetimes. */
                since?: components["parameters"]["change_since"];
                /** @description The end of the date range over which you want to search, as a UTC ISO 8601 datetime string. Will return an HTTP 400 for non-UTC datetimes. */
                until?: components["parameters"]["change_until"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The array of Change Events returned by the query. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        change_events?: components["schemas"]["ChangeEvent"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
        };
    };
    createChangeEvent: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description See [`Send Change Event`](https://developer.pagerduty.com/api-reference/b3A6Mjc0ODI2Ng-send-change-events-to-the-pager-duty-events-api) in the V2 Events API reference. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    getChangeEvent: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Change Event requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        change_event?: components["schemas"]["ChangeEvent"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateChangeEvent: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The Change Event to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    change_event: components["schemas"]["ChangeEvent"];
                };
            };
        };
        responses: {
            /** @description The Change Event that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        change_event?: components["schemas"]["ChangeEvent"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    listEscalationPolicies: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Filters the result, showing only the records whose name matches the query. */
                query?: components["parameters"]["query"];
                /** @description Filters the results, showing only escalation policies on which any of the users is a target. */
                "user_ids[]"?: components["parameters"]["user_ids_escalation_policies"];
                /** @description An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter. */
                "team_ids[]"?: components["parameters"]["team_ids"];
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_escalation_policy"];
                /** @description Used to specify the field you wish to sort the results on. */
                sort_by?: components["parameters"]["sort_by_escalation_policy"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of escalation policy objects. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        escalation_policies: components["schemas"]["EscalationPolicy"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createEscalationPolicy: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. This is optional, and is only used for change tracking. */
                From?: components["parameters"]["optional_from_header"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description The escalation policy to be created. */
        requestBody?: {
            content: {
                "application/json": {
                    escalation_policy: components["schemas"]["EscalationPolicy"];
                };
            };
        };
        responses: {
            /** @description The escalation policy that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        escalation_policy: components["schemas"]["EscalationPolicy"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getEscalationPolicy: {
        parameters: {
            query?: {
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_escalation_policy"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The escalation policy object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        escalation_policy: components["schemas"]["EscalationPolicy"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateEscalationPolicy: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The escalation policy to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    escalation_policy: components["schemas"]["EscalationPolicy"];
                };
            };
        };
        responses: {
            /** @description The escalation policy that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        escalation_policy: components["schemas"]["EscalationPolicy"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteEscalationPolicy: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The escalation policy was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listEscalationPolicyAuditRecords: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description The start of the date range over which you want to search. If not specified, defaults to `now() - 24 hours` (past 24 hours) */
                since?: components["parameters"]["audit_since"];
                /** @description The end of the date range over which you want to search. If not specified, defaults to `now()`. May not be more than 31 days after `since`. */
                until?: components["parameters"]["audit_until"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Records matching the query criteria. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditRecordResponseSchema"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listEventOrchestrations: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /** @description Used to specify the field you wish to sort the results on. */
                sort_by?: components["parameters"]["sort_by_event_orchestration"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of Event Orchestration objects. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        orchestrations?: {
                            /** @description ID of the Orchestration. */
                            readonly id?: string;
                            /**
                             * Format: url
                             * @description The API show URL at which the object is accessible
                             */
                            readonly self?: string;
                            /** @description Name of the Orchestration. */
                            name?: string;
                            /** @description A description of this Orchestration's purpose. */
                            description?: string;
                            /** @description Reference to the team that owns the Orchestration. If none is specified, only admins have access. */
                            team?: {
                                id?: string;
                                /** @description A string that determines the schema of the object */
                                readonly type?: string;
                                /**
                                 * Format: url
                                 * @description The API show URL at which the object is accessible
                                 */
                                readonly self?: string;
                            };
                            /** @description Number of different Service Orchestration being routed to */
                            readonly routes?: number;
                            /**
                             * Format: date-time
                             * @description The date the Orchestration was created at.
                             */
                            readonly created_at?: string;
                            /** @description Reference to the user that has created the Orchestration. */
                            readonly created_by?: {
                                readonly id?: string;
                                /** @description A string that determines the schema of the object */
                                readonly type?: string;
                                /**
                                 * Format: url
                                 * @description The API show URL at which the object is accessible
                                 */
                                readonly self?: string;
                            };
                            /**
                             * Format: date-time
                             * @description The date the Orchestration was last updated.
                             */
                            readonly updated_at?: string;
                            /** @description Reference to the user that has updated the Orchestration last. */
                            readonly updated_by?: {
                                readonly id?: string;
                                /** @description A string that determines the schema of the object */
                                readonly type?: string;
                                /**
                                 * Format: url
                                 * @description The API show URL at which the object is accessible
                                 */
                                readonly self?: string;
                            };
                            /** @description Version of the Orchestration. */
                            readonly version?: string;
                        }[];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    postOrchestration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    orchestration: components["schemas"]["Orchestration"];
                };
            };
        };
        responses: {
            /** @description The Orchestration that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        orchestration?: components["schemas"]["Orchestration"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    getOrchestration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Orchestration object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        orchestration?: components["schemas"]["Orchestration"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateOrchestration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    orchestration: components["schemas"]["Orchestration"];
                };
            };
        };
        responses: {
            /** @description The Orchestration that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        orchestration?: components["schemas"]["Orchestration"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    deleteOrchestration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Orchestration was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    listOrchestrationIntegrations: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Integrations for this Event Orchestration. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        integrations?: components["schemas"]["OrchestrationIntegration"][];
                        total?: components["schemas"]["Pagination"]["total"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            405: components["responses"]["NotAllowed"];
        };
    };
    postOrchestrationIntegration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    integration: {
                        /** @description Name of the Integration. */
                        label: string;
                    };
                };
            };
        };
        responses: {
            /** @description The Integration that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        integration?: components["schemas"]["OrchestrationIntegration"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    getOrchestrationIntegration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The ID of an Integration. */
                integration_id: components["parameters"]["event_orchestration_integration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An Integration for this Event Orchestration. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        integration?: components["schemas"]["OrchestrationIntegration"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            405: components["responses"]["NotAllowed"];
        };
    };
    updateOrchestrationIntegration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The ID of an Integration. */
                integration_id: components["parameters"]["event_orchestration_integration_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    integration: {
                        /** @description Name of the Integration. */
                        label: string;
                    };
                };
            };
        };
        responses: {
            /** @description The Integration that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        integration?: components["schemas"]["OrchestrationIntegration"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    deleteOrchestrationIntegration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The ID of an Integration. */
                integration_id: components["parameters"]["event_orchestration_integration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Integration was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    migrateOrchestrationIntegration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description The ID of the Event Orchestration you'll be moving the Integration away from */
                    source_id: string;
                    /**
                     * @description The type of of the `source_id` object
                     * @enum {string}
                     */
                    source_type: "orchestration";
                    /** @description The ID of the Integration you'll be moving */
                    integration_id: string;
                };
            };
        };
        responses: {
            /** @description The Integration that was migrated */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        integrations?: components["schemas"]["OrchestrationIntegration"][];
                        total?: components["schemas"]["Pagination"]["total"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    getOrchPathGlobal: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Global Orchestration Rules object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrchestrationGlobal"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateOrchPathGlobal: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        /** @description Update Global Orchestration rules. Omitted rules and rule details are deleted. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["OrchestrationGlobal"];
            };
        };
        responses: {
            /** @description The Global Orchestration Rules object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrchestrationGlobal"] & {
                        warnings?: (components["schemas"]["OrchestrationWarningIneligible"] | components["schemas"]["OrchestrationWarningInvalidData"])[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    getOrchPathRouter: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationPathRouterTypeResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateOrchPathRouter: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        /** @description Updates to Orchestration Router details. Omitted rules and rule details are deleted. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["OrchestrationRouter"];
            };
        };
        responses: {
            /** @description The Orchestration Router object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrchestrationRouter"] & {
                        /** @description List of applicable warnings messages for each rule using a feature not available on your account plan. */
                        warnings?: components["schemas"]["OrchestrationWarningIneligible"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    getOrchPathUnrouted: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationPathUnroutedTypeResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateOrchPathUnrouted: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        /** @description Updates to Unrouted Orchestration rules. Omitted rules and rule details are deleted. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["OrchestrationUnrouted"];
            };
        };
        responses: {
            /** @description The Unrouted Orchestration object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrchestrationUnrouted"] & {
                        /** @description List of applicable warnings messages for each rule using a feature not available on your account plan. */
                        warnings?: components["schemas"]["OrchestrationWarningIneligible"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    getOrchPathService: {
        parameters: {
            query?: {
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_ruleset_migrated_metadata"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationPathServiceTypeResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateOrchPathService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
            };
            cookie?: never;
        };
        /** @description Update Service Orchestration rules. Omitted rules and rule details are deleted. */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["ServiceOrchestration"];
            };
        };
        responses: {
            /** @description The Service Orchestration object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ServiceOrchestration"] & {
                        warnings?: (components["schemas"]["OrchestrationWarningIneligible"] | components["schemas"]["OrchestrationWarningInvalidData"])[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    getOrchActiveStatus: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationPathServiceActiveResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateOrchActiveStatus: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
            };
            cookie?: never;
        };
        /** @description Update Service Orchestration's active status. */
        requestBody?: {
            content: {
                "application/json": components["responses"]["OrchestrationPathServiceActiveResponse"]["content"]["application/json"]["schema"];
            };
        };
        responses: {
            200: components["responses"]["OrchestrationPathServiceActiveResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    listCacheVarOnGlobalOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationCacheVariableListResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    createCacheVarOnGlobalOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["OrchestrationCacheVariablePostRequest"];
        responses: {
            200: components["responses"]["OrchestrationCacheVariablePostResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
        };
    };
    getCacheVarOnGlobalOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationCacheVariableGetResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateCacheVarOnGlobalOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["OrchestrationCacheVariablePutRequest"];
        responses: {
            200: components["responses"]["OrchestrationCacheVariablePutResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
        };
    };
    deleteCacheVarOnGlobalOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Cache Variable was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    getExternalDataCacheVarDataOnGlobalOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationCacheVariableGetDataResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateExternalDataCacheVarDataOnGlobalOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["OrchestrationCacheVariableDataPutRequest"];
        responses: {
            200: components["requestBodies"]["OrchestrationCacheVariableDataPutResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
        };
    };
    deleteExternalDataCacheVarDataOnGlobalOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Data was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    listCacheVarOnServiceOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationCacheVariableListResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    createCacheVarOnServiceOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["OrchestrationCacheVariablePostRequest"];
        responses: {
            200: components["responses"]["OrchestrationCacheVariablePostResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
        };
    };
    getCacheVarOnServiceOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationCacheVariableGetResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateCacheVarOnServiceOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["OrchestrationCacheVariablePutRequest"];
        responses: {
            200: components["responses"]["OrchestrationCacheVariablePutResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
        };
    };
    deleteCacheVarOnServiceOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Cache Variable was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    getExternalDataCacheVarDataOnServiceOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["OrchestrationCacheVariableGetDataResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateExternalDataCacheVarDataOnServiceOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["OrchestrationCacheVariableDataPutRequest"];
        responses: {
            200: components["requestBodies"]["OrchestrationCacheVariableDataPutResponse"];
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
        };
    };
    deleteExternalDataCacheVarDataOnServiceOrch: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The service ID */
                service_id: components["parameters"]["service_id"];
                /** @description The ID of a Cache Variable. */
                cache_variable_id: components["parameters"]["event_orchestration_cache_variable_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Data was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    listEventOrchestrationFeatureEnablements: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The list of feature enablement settings for the Event Orchestation. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Array of feature enablement settings. */
                        enablements?: components["schemas"]["FeatureEnablement"][];
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateEventOrchestrationFeatureEnablements: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of an Event Orchestration. */
                id: components["parameters"]["event_orchestration_id"];
                /** @description The feature enablement identifier, typically the name of the product addon. Currently only `aiops` is supported. */
                feature_name: components["parameters"]["enablement_feature_name"];
            };
            cookie?: never;
        };
        /** @description The feature enablement setting to apply. */
        requestBody?: {
            content: {
                "application/json": {
                    enablement: components["schemas"]["FeatureEnablement"];
                };
            };
        };
        responses: {
            /** @description The feature enablement setting was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        enablement?: components["schemas"]["FeatureEnablement"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listExtensionSchemas: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of extension schemas. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        extension_schemas: components["schemas"]["ExtensionSchema"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getExtensionSchema: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The extension vendor requested */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        extension_schema: components["schemas"]["ExtensionSchema"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listExtensions: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Filters the result, showing only the records whose name matches the query. */
                query?: components["parameters"]["query"];
                /** @description The id of the extension object you want to filter by. */
                extension_object_id?: components["parameters"]["extension_object_id"];
                /** @description Filter the extensions by extension vendor id. */
                extension_schema_id?: components["parameters"]["extension_schema_id"];
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_extensions"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of extensions. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        extensions: components["schemas"]["Extension"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
        };
    };
    createExtension: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description The extension to be created */
        requestBody?: {
            content: {
                "application/json": {
                    extension: components["schemas"]["Extension"];
                };
            };
        };
        responses: {
            /** @description The extension that was created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        extension: components["schemas"]["Extension"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
        };
    };
    getExtension: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_extensions_id"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The extension that was requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        extension: components["schemas"]["Extension"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateExtension: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The extension to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    extension: components["schemas"]["Extension"];
                };
            };
        };
        responses: {
            /** @description The extension that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        extension: components["schemas"]["Extension"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    deleteExtension: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The extension was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    enableExtension: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The extension that was successfully enabled. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        extension: components["schemas"]["Extension"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    listIncidentWorkflows: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Filters the result, showing only the records whose name matches the query. */
                query?: components["parameters"]["query"];
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_incident_workflow_children"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of Incident Workflows. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        incident_workflows: components["schemas"]["IncidentWorkflow"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    postIncidentWorkflow: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    incident_workflow: components["schemas"]["IncidentWorkflow"];
                };
            };
        };
        responses: {
            /** @description The new Incident Workflow */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident_workflow: components["schemas"]["IncidentWorkflow"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getIncidentWorkflow: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Incident Workflow */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident_workflow: components["schemas"]["IncidentWorkflow"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    putIncidentWorkflow: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    incident_workflow: components["schemas"]["IncidentWorkflow"];
                };
            };
        };
        responses: {
            /** @description The changed Incident Workflow */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident_workflow: components["schemas"]["IncidentWorkflow"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteIncidentWorkflow: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Incident Workflow was deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createIncidentWorkflowInstance: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    incident_workflow_instance: {
                        /**
                         * @description An identifier to help differentiate between workflow executions.
                         * @example P3SNKQS
                         */
                        id?: string;
                        incident?: {
                            /** @example Q1R2DLCB21K7NP */
                            id: string;
                            /** @enum {string} */
                            type?: "incident_reference";
                        };
                    };
                };
            };
        };
        responses: {
            /** @description The Incident Workflow Instance */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident_workflow_instance: components["schemas"]["IncidentWorkflowInstance"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listIncidentWorkflowActions: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description If provided, only show actions tagged with the specified keyword */
                keyword?: components["parameters"]["actions_filter_keyword"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of Incident Workflow Actions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CursorPagination"] & {
                        /** @description Indicates if there are additional records to return */
                        readonly more?: boolean;
                        actions?: components["schemas"]["IncidentWorkflowAction"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getIncidentWorkflowAction: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An Incident Workflow Action */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        action?: components["schemas"]["IncidentWorkflowAction"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listIncidentWorkflowTriggers: {
        parameters: {
            query?: {
                /** @description If provided, only show triggers configured to start the given workflow. Useful for listing all services associated with the given workflow */
                workflow_id?: components["parameters"]["triggers_filter_workflow_id"];
                /** @description If provided, only show triggers configured on the service of the given incident. Useful for finding manual triggers that are configured on the service for a specific incident. Cannot be specified if `service_id` is provided. */
                incident_id?: components["parameters"]["triggers_filter_incident_id"];
                /** @description If provided, only show triggers configured for incidents in the given service. Useful for listing all workflows associated with the given service. Cannot be specified if `incident_id` is provided. */
                service_id?: components["parameters"]["triggers_filter_service_id"];
                /** @description If provided, only show triggers of the given type. For example manual to search for manual triggers */
                trigger_type?: components["parameters"]["triggers_filter_trigger_type"];
                /** @description If provided, only show triggers configured to start workflows whose name contain the provided value. */
                workflow_name_contains?: components["parameters"]["triggers_filter_workflow_name_contains"];
                /**
                 * @deprecated
                 * @description If provided, filters between disabled and enabled Triggers.
                 *     This query parameter is deprecated, and will be removed in a future version of this API.
                 */
                is_disabled?: components["parameters"]["triggers_filter_is_disabled"];
                /** @description If provided, returns triggers sorted by the specified property. */
                sort_by?: components["parameters"]["triggers_sort_by"];
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of Incident Workflow Triggers */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CursorPagination"] & {
                        /** @description Indicates if there are additional records to return */
                        readonly more?: boolean;
                        triggers?: components["schemas"]["IncidentWorkflowTrigger"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createIncidentWorkflowTrigger: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    trigger: components["schemas"]["Tag"] & {
                        /** @enum {string} */
                        type?: "workflow_trigger";
                        /** @enum {string} */
                        trigger_type?: "conditional" | "manual" | "incident_type";
                        /**
                         * @description A PCL condition string.
                         *
                         *     If specified, the trigger will execute when the condition is met on an incident.
                         *
                         *     If unspecified, the trigger will execute on incident creation.
                         *
                         *     Required if trigger_type is conditional, not allowed for other trigger types.
                         */
                        condition?: string;
                        /** Format: url */
                        trigger_url?: string;
                        /** @description An optional array of Incident Types associated with the trigger when it is of type `incident_type`. */
                        incident_types?: string[];
                        /** @description Workflow to start when this trigger is invoked */
                        workflow?: {
                            id?: string;
                        };
                        /** @description An optional array of Services associated with this workflow. Incidents in any of the listed Services are eligible to fire this Trigger */
                        services?: {
                            id?: string;
                        }[];
                        /** @description Indicates that the Trigger should be associated with All Services */
                        is_subscribed_to_all_services?: boolean;
                        /** @description An object detailing who can start this Trigger. Applicable only to manual Triggers. */
                        permissions?: {
                            /** @description If true, indicates that the Trigger can only be started by authorized Users. If false, any user can start this Trigger. Applicable only to manual Triggers. */
                            restricted?: boolean;
                            /** @description The ID of the team whose members can manually start this Trigger. Required and allowed if and only if permissions.restricted is true. */
                            team_id?: string;
                        };
                        /**
                         * @deprecated
                         * @description Indicates whether the Trigger is disabled or not. A previous API version allowed callers to set this
                         *     property independently. This behavior is deprecated. This property's value will be set based on the
                         *     "is_enabled" property of the workflow to which this trigger belongs.
                         */
                        is_disabled?: boolean;
                    };
                };
            };
        };
        responses: {
            /** @description The newly created Incident Workflow Trigger */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        trigger: components["schemas"]["IncidentWorkflowTrigger"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getIncidentWorkflowTrigger: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Incident Workflows Trigger */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        trigger?: components["schemas"]["IncidentWorkflowTrigger"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateIncidentWorkflowTrigger: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    trigger: components["schemas"]["Tag"] & {
                        /** @enum {string} */
                        type?: "workflow_trigger";
                        /** @description Human readable name for the trigger type */
                        readonly trigger_type_name?: string;
                        /**
                         * @description A PCL condition string.
                         *
                         *     If specified, the trigger will execute when the condition is met on an incident.
                         *
                         *     If unspecified, the trigger will execute on incident creation.
                         *
                         *     Required if trigger_type is conditional, not allowed for other trigger types.
                         */
                        condition?: string;
                        /** @description An optional array of Services associated with this workflow. Incidents in any of the listed Services are eligible to fire this Trigger */
                        services?: {
                            id?: string;
                        }[];
                        /** @description Indicates that the Trigger should be associated with All Services */
                        is_subscribed_to_all_services?: boolean;
                        /** @description An object detailing who can start this Trigger. Applicable only to manual Triggers. */
                        permissions?: {
                            /** @description If true, indicates that the Trigger can only be started by authorized Users. If false, any user can start this Trigger. Applicable only to manual Triggers. */
                            restricted?: boolean;
                            /** @description The ID of the team whose members can manually start this Trigger. Required and allowed if and only if permissions.restricted is true. */
                            team_id?: string;
                        };
                        /**
                         * @deprecated
                         * @description Indicates whether the Trigger is disabled or not. A previous API version allowed callers to update this
                         *     property independently. This behavior is deprecated. To update this property set "is_enabled" on the workflow
                         *     to which this trigger belongs.
                         */
                        is_disabled?: boolean;
                        /** @description An optional array of Incident Types associated with the trigger when it is of type `incident_type`. */
                        incident_types?: string[];
                    };
                };
            };
        };
        responses: {
            /** @description The updated Incident Workflow Trigger */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        trigger: components["schemas"]["IncidentWorkflowTrigger"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteIncidentWorkflowTrigger: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Incident Workflow Trigger was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    associateServiceToIncidentWorkflowTrigger: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    service: {
                        id?: string;
                    };
                };
            };
        };
        responses: {
            /** @description The updated Incident Workflow Trigger */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        trigger: components["schemas"]["IncidentWorkflowTrigger"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteServiceFromIncidentWorkflowTrigger: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description Identifier for the Trigger */
                trigger_id: components["parameters"]["triggers_path_trigger_id"];
                /** @description Identifier for the Service */
                service_id: components["parameters"]["triggers_path_service_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The updated Incident Workflow Trigger */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        trigger: components["schemas"]["IncidentWorkflowTrigger"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listIncidents: {
        parameters: {
            query?: {
                /** @description The number of results per page. Maximum of 100. */
                limit?: components["parameters"]["incident_list_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description When set to all, the since and until parameters and defaults are ignored. */
                date_range?: components["parameters"]["date_range"];
                /** @description Incident de-duplication key. Incidents with child alerts do not have an incident key; querying by incident key will return incidents whose alerts have alert_key matching the given incident key. */
                incident_key?: components["parameters"]["incident_key"];
                /** @description Returns only the incidents associated with the passed service(s). This expects one or more service IDs. */
                "service_ids[]"?: components["parameters"]["incident_services"];
                /** @description An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter. */
                "team_ids[]"?: components["parameters"]["team_ids"];
                /** @description Returns only the incidents currently assigned to the passed user(s). This expects one or more user IDs. Note: When using the assigned_to_user filter, you will only receive incidents with statuses of triggered or acknowledged. This is because resolved incidents are not assigned to any user. */
                "user_ids[]"?: components["parameters"]["incident_assigned_to_user"];
                /** @description Array of the urgencies of the incidents to be returned. Defaults to all urgencies. Account must have the `urgencies` ability to do this. */
                "urgencies[]"?: components["parameters"]["incident_urgencies"];
                /** @description Time zone in which results will be rendered. This will default to the account time zone. */
                time_zone?: components["parameters"]["time_zone"];
                /** @description Return only incidents with the given statuses. To query multiple statuses, pass `statuses[]` more than once, for example: `https://api.pagerduty.com/incidents?statuses[]=triggered&statuses[]=acknowledged`. (More status codes may be introduced in the future.) */
                "statuses[]"?: components["parameters"]["statuses_incidents"];
                /** @description Used to specify both the field you wish to sort the results on (incident_number/created_at/resolved_at/urgency), as well as the direction (asc/desc) of the results. The sort_by field and direction should be separated by a colon. A maximum of two fields can be included, separated by a comma. Sort direction defaults to ascending. The account must have the `urgencies` ability to sort by the urgency. */
                sort_by?: components["parameters"]["sort_by_incidents"];
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_incidents"];
                /** @description The start of the date range over which you want to search. Maximum range is 6 months and default is 1 month. */
                since?: components["parameters"]["since_incidents"];
                /** @description The end of the date range over which you want to search. Maximum range is 6 months and default is 1 month. */
                until?: components["parameters"]["until_incidents"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of incidents. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        incidents: components["schemas"]["Incident"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateIncidents: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description An array of incidents, including the parameters to update. */
                    incidents: {
                        /** @description The id of the incident to update. */
                        id: string;
                        /**
                         * @description The incident type.
                         * @enum {string}
                         */
                        type: "incident" | "incident_reference";
                        /**
                         * @description The new status of the incident. If the incident is currently resolved, setting the status to "triggered" or "acknowledged" will reopen it. When reopening an incident to the "triggered" status, it will be assigned based on the assignees or escalation_policy fields in the request, otherwise it will be assigned to the current Escalation Policy. When reopening an incident to the "acknowledged" status, it will be assigned to the current user.
                         * @enum {string}
                         */
                        status?: "resolved" | "acknowledged" | "triggered";
                        /**
                         * @description The resolution for this incident. This field is used only when setting the incident status to resolved.
                         *     The value provided here is added to the incidents 'Resolve' log entry as a note and will not be displayed directly in the UI.
                         */
                        resolution?: string;
                        /** @description A succinct description of the nature, symptoms, cause, or effect of the incident. */
                        title?: string;
                        /** @description The priority of the incident. Can be provided as a priority object or a string matching a priority name. If a string is provided, the highest priority with a matching name will be used. */
                        priority?: {
                            /** @description The ID of the priority. */
                            id: string;
                            /** @description The user-provided short name of the priority. */
                            name?: string;
                            /**
                             * @description The type of the reference.
                             * @enum {string}
                             */
                            type: "priority" | "priority_reference";
                        } | string;
                        /** @description Escalate the incident to this level in the escalation policy. */
                        escalation_level?: number;
                        /** @description Assign the incident to these assignees. */
                        assignments?: {
                            assignee?: components["schemas"]["UserReference"];
                        }[];
                        incident_type?: components["schemas"]["IncidentTypeReference"];
                        escalation_policy?: components["schemas"]["EscalationPolicyReference"];
                        /**
                         * @description The urgency of the incident.
                         * @enum {string}
                         */
                        urgency?: "high" | "low";
                        conference_bridge?: components["schemas"]["ConferenceBridge"];
                    }[];
                };
            };
        };
        responses: {
            /** @description All of the updates succeeded. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        incidents: components["schemas"]["Incident"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            413: components["responses"]["RequestEntityTooLarge"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createIncident: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Details of the incident to be created. */
                    incident: {
                        /** @enum {string} */
                        type: "incident";
                        /** @description A succinct description of the nature, symptoms, cause, or effect of the incident. */
                        title: string;
                        service: components["schemas"]["ServiceReference"];
                        priority?: components["schemas"]["PriorityReference"];
                        /**
                         * @description The urgency of the incident
                         * @enum {string}
                         */
                        urgency?: "high" | "low";
                        body?: components["schemas"]["IncidentBody"];
                        /** @description A string which identifies the incident. Sending subsequent requests referencing the same service and with the same incident_key will result in those requests being rejected if an open incident matches that incident_key. */
                        incident_key?: string;
                        /** @description Assign the incident to these assignees. Cannot be specified if an escalation policy is given. */
                        assignments?: {
                            assignee?: components["schemas"]["UserReference"];
                        }[];
                        incident_type?: components["schemas"]["IncidentTypeReference"];
                        escalation_policy?: components["schemas"]["EscalationPolicyReference"];
                        conference_bridge?: components["schemas"]["ConferenceBridge"];
                    };
                };
            };
        };
        responses: {
            /** @description The incident object created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident: components["schemas"]["Incident"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getIncident: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_incident"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The incident requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident: components["schemas"]["Incident"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateIncident: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description The parameters of the incident to update. */
                    incident: {
                        /**
                         * @description The incident type.
                         * @enum {string}
                         */
                        type: "incident" | "incident_reference";
                        /**
                         * @description The new status of the incident. If the incident is currently resolved, setting the status to "triggered" or "acknowledged" will reopen it. When reopening an incident to the "triggered" status, it will be assigned based on the assignees or escalation_policy fields in the request, otherwise it will be assigned to the current Escalation Policy. When reopening an incident to the "acknowledged" status, it will be assigned to the current user.
                         * @enum {string}
                         */
                        status?: "resolved" | "acknowledged" | "triggered";
                        /** @description The priority of the incident. Can be provided as a priority object or a string matching a priority name. If a string is provided, the highest priority with a matching name will be used. */
                        priority?: {
                            /** @description The ID of the priority. */
                            id: string;
                            /** @description The user-provided short name of the priority. */
                            name?: string;
                            /**
                             * @description The type of the reference.
                             * @enum {string}
                             */
                            type: "priority" | "priority_reference";
                        } | string;
                        /**
                         * @description The resolution for this incident. This field is used only when setting the incident status to resolved.
                         *     The value provided here is added to the incidents 'Resolve' log entry as a note and will not be displayed directly in the UI.
                         */
                        resolution?: string;
                        /** @description The new title of the incident. */
                        title?: string;
                        /** @description Escalate the incident to this level in the escalation policy. */
                        escalation_level?: number;
                        /** @description Assign the incident to these assignees. */
                        assignments?: {
                            assignee?: components["schemas"]["UserReference"];
                        }[];
                        incident_type?: components["schemas"]["IncidentTypeReference"];
                        escalation_policy?: components["schemas"]["EscalationPolicyReference"];
                        /**
                         * @description The urgency of the incident.
                         * @enum {string}
                         */
                        urgency?: "high" | "low";
                        conference_bridge?: components["schemas"]["ConferenceBridge"];
                        /** @description Assign the incident to this service. */
                        service?: {
                            /** @description The ID of the service. */
                            id: string;
                            /**
                             * @description The type of the reference.
                             * @enum {string}
                             */
                            type: "service_reference";
                        };
                    };
                };
            };
        };
        responses: {
            /** @description The incident was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident: components["schemas"]["Incident"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listIncidentAlerts: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Alert de-duplication key. */
                alert_key?: components["parameters"]["alert_key"];
                /** @description Return only alerts with the given statuses. (More status codes may be introduced in the future.) */
                "statuses[]"?: components["parameters"]["statuses_incident_alerts"];
                /** @description Used to specify both the field you wish to sort the results on (created_at/resolved_at), as well as the direction (asc/desc) of the results. The sort_by field and direction should be separated by a colon. A maximum of two fields can be included, separated by a comma. Sort direction defaults to ascending. */
                sort_by?: components["parameters"]["sort_by_incident_alerts"];
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_incident_alerts"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of the incident's alerts. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        alerts: components["schemas"]["Alert"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateIncidentAlerts: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description An array of alerts, including the parameters to update for each alert. */
                    alerts: components["schemas"]["AlertUpdate"][];
                };
            };
        };
        responses: {
            /** @description All of the updates succeeded. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        alerts: components["schemas"]["Alert"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            413: components["responses"]["RequestEntityTooLarge"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getIncidentAlert: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the alert to retrieve. */
                alert_id: components["parameters"]["alert_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The alert requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        alert: components["schemas"]["Alert"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateIncidentAlert: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the alert to retrieve. */
                alert_id: components["parameters"]["alert_id"];
            };
            cookie?: never;
        };
        /** @description The parameters of the alert to update. */
        requestBody?: {
            content: {
                "application/json": {
                    alert: components["schemas"]["AlertUpdate"];
                };
            };
        };
        responses: {
            /** @description The alert that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        alert: components["schemas"]["Alert"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    putIncidentManualBusinessServiceAssociation: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The business service ID. */
                business_service_id: components["parameters"]["business_service_id"];
            };
            cookie?: never;
        };
        /**
         * @description The `impacted` relation will cause the Business Service and any Services that it supports to become impacted by this incident.
         *
         *     The `not_impacted` relation will remove the Incident's Impact from the specified Business Service.
         *
         *     The effect of adding or removing Impact to a Business Service in this way will also change the propagation of Impact to other Services supported by that Business Service.
         */
        requestBody?: {
            content: {
                "application/json": {
                    /** @enum {string} */
                    relation: "impacted" | "not_impacted";
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @enum {string} */
                        relation?: "impacted" | "not_impacted";
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getIncidentImpactedBusinessServices: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CursorPagination"] & {
                        services?: components["schemas"]["Impact"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getIncidentFieldValues: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The list of custom field values. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        custom_fields: components["schemas"]["CustomFieldsFieldValue"][];
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    setIncidentFieldValues: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** Array of Custom Field Values */
                    custom_fields: components["schemas"]["CustomFieldsEditableFieldValue"][];
                };
            };
        };
        responses: {
            /** @description Custom field values were updated. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        custom_fields: components["schemas"]["CustomFieldsFieldValue"][];
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listIncidentLogEntries: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Time zone in which results will be rendered. This will default to the account time zone. */
                time_zone?: components["parameters"]["time_zone"];
                /** @description The start of the date range over which you want to search. */
                since?: components["parameters"]["since"];
                /** @description The end of the date range over which you want to search. */
                until?: components["parameters"]["until"];
                /** @description If `true`, will return a subset of log entries that show only the most important changes to the incident. */
                is_overview?: components["parameters"]["log_entry_is_overview"];
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_log_entry"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of the incident's log entries. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        log_entries: (components["schemas"]["AcknowledgeLogEntry"] | components["schemas"]["AnnotateLogEntry"] | components["schemas"]["AssignLogEntry"] | components["schemas"]["DelegateLogEntry"] | components["schemas"]["EscalateLogEntry"] | components["schemas"]["ExhaustEscalationPathLogEntry"] | components["schemas"]["NotifyLogEntry"] | components["schemas"]["ReachAckLimitLogEntry"] | components["schemas"]["ReachTriggerLimitLogEntry"] | components["schemas"]["RepeatEscalationPathLogEntry"] | components["schemas"]["ResolveLogEntry"] | components["schemas"]["SnoozeLogEntry"] | components["schemas"]["TriggerLogEntry"] | components["schemas"]["UnacknowledgeLogEntry"] | components["schemas"]["UrgencyChangeLogEntry"] | components["schemas"]["FieldValueChangeLogEntry"] | components["schemas"]["CustomFieldValueChangeLogEntry"])[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    mergeIncidents: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description The source incidents that will be merged into the target incident and resolved. */
                    source_incidents: components["schemas"]["IncidentReference"][];
                };
            };
        };
        responses: {
            /** @description The target incident, which now contains all the alerts from the source incident. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident: components["schemas"]["IncidentReference"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listIncidentNotes: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of notes. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        notes: components["schemas"]["IncidentNote"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createIncidentNote: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    note: {
                        /** @description The note content */
                        content: string;
                    };
                };
            };
        };
        responses: {
            /** @description The new note. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        note: components["schemas"]["IncidentNote"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateIncidentNote: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the note. */
                note_id: components["parameters"]["note_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    note: {
                        /** @description The note content */
                        content: string;
                    };
                };
            };
        };
        responses: {
            /** @description The updated note. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        note: components["schemas"]["IncidentNote"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    deleteIncidentNote: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the note. */
                note_id: components["parameters"]["note_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Note deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    getOutlierIncident: {
        parameters: {
            query?: {
                /** @description The start of the date range over which you want to search. */
                since?: components["parameters"]["since"];
                /** @description Array of additional attributes to any of the returned incidents for related incidents. */
                "additional_details[]"?: components["parameters"]["additional_details"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Outlier Incident information calculated over the same Service as the given Incident. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Outlier Incident information calculated over the same Service as the given Incident. */
                        outlier_incident?: {
                            incident?: components["schemas"]["Incident"];
                            incident_template?: {
                                readonly id?: string;
                                /** @description The cluster the Incident Template pattern belongs to */
                                readonly cluster_id?: string;
                                /** @description The Incident Template mined pattern text */
                                readonly mined_text?: string;
                            };
                        };
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getPastIncidents: {
        parameters: {
            query?: {
                /** @description The number of results to be returned in the response. */
                limit?: components["parameters"]["past_incidents_limit"];
                /** @description By default the `total` field in the response body is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated with the total number of Past Incidents. */
                total?: components["parameters"]["past_incidents_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Aggregate of past incidents */
                        past_incidents?: {
                            /** @description Incident model reference */
                            incident?: {
                                /** @description The globally unique identifier of the incident */
                                id?: string;
                                /** @description The date/time the incident was first triggered */
                                created_at?: string;
                                /** @description The URL at which the object is accessible */
                                self?: string;
                                /** @description The description of the nature, symptoms, cause, or effect of the incident */
                                title?: string;
                            };
                            /** @description The computed similarity score associated with the incident and parent incident */
                            score?: number;
                        }[];
                        /** @description The total number of Past Incidents if the total parameter was set in the request */
                        total?: number;
                        /** @description The maximum number of Incidents requested */
                        limit?: number;
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listIncidentRelatedChangeEvents: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The array of Change Events returned by the query. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        change_events?: (components["schemas"]["ChangeEvent"] & {
                            correlation_reason?: {
                                /**
                                 * @description The reason a change event was determined to be related to the given incident.
                                 * @enum {string}
                                 */
                                readonly reason?: "most_recent" | "related_service" | "intelligent";
                            };
                        })[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    getRelatedIncidents: {
        parameters: {
            query?: {
                /** @description Array of additional attributes to any of the returned incidents for related incidents. */
                "additional_details[]"?: components["parameters"]["additional_details"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of Related Incidents and their relationships. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A list of Related Incidents and their relationships. */
                        related_incidents?: {
                            incident?: components["schemas"]["Incident"];
                            /** @description A list of reasons for why the Incident is considered related. */
                            relationships?: {
                                /**
                                 * @description The type of relationship. A relationship outlines the reason why two Incidents are considered related.
                                 * @enum {string}
                                 */
                                type?: "machine_learning_inferred" | "service_dependency";
                                metadata?: components["schemas"]["RelatedIncidentMachineLearningRelationship"] | components["schemas"]["RelatedIncidentServiceDependencyRelationship"];
                            }[];
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createIncidentResponderRequest: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description The user id of the requester. */
                    requester_id: string;
                    /** @description The message sent with the responder request. */
                    message: string;
                    /** @description The array of targets the responder request is sent to. */
                    responder_request_targets: unknown;
                };
            };
        };
        responses: {
            /** @description The new responder request for the given incident. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        responder_request: components["schemas"]["ResponderRequest"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createIncidentSnooze: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description The number of seconds to snooze the incident for. After this number of seconds has elapsed, the incident will return to the "triggered" state. */
                    duration: number;
                };
            };
        };
        responses: {
            /** @description The incident that was successfully snoozed. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident: components["schemas"]["Incident"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createIncidentStatusUpdate: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description The message to be posted as a status update. */
                    message: string;
                    /** @description The subject to be sent for the custom html email status update. Required if sending custom html email. */
                    subject?: string;
                    /** @description The html content to be sent for the custom html email status update. Required if sending custom html email. */
                    html_message?: string;
                };
            };
        };
        responses: {
            /** @description The new status update for the specified incident. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        status_update: components["schemas"]["StatusUpdate"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getIncidentNotificationSubscribers: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        subscribers?: components["schemas"]["NotificationSubscriberWithContext"][];
                    } & {
                        /** @description The ID of the account belonging to the subscriber entity */
                        account_id?: string;
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createIncidentNotificationSubscribers: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The entities to subscribe. */
        requestBody?: {
            content: {
                "application/json": {
                    subscribers: components["schemas"]["NotificationSubscriber"][];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        subscriptions?: components["schemas"]["NotificationSubscriptionWithContext"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    removeIncidentNotificationSubscribers: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The entities to unsubscribe. */
        requestBody?: {
            content: {
                "application/json": {
                    subscribers: components["schemas"]["NotificationSubscriber"][];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        deleted_count: number;
                        unauthorized_count: number;
                        non_existent_count: number;
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    listIncidentTypes: {
        parameters: {
            query?: {
                /** @description Filters the list of incident types based on their `enabled` state. */
                filter?: components["parameters"]["incident_type_list_filter"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of all types for the account. The default incident type will automatically return on this list. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident_types: components["schemas"]["IncidentType"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createIncidentType: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Details of the incident type to be created. */
                    incident_type: {
                        /** @description The name of the Incident Type. Usage of the suffix `_default` is prohibited. This cannot be changed once the incident type has been created. */
                        name: string;
                        /** @description The display name of the Incident Type. Usage of the prefix `PD`, `PagerDuty`, `Default` is prohibited. */
                        display_name: string;
                        /** @description The parent type of the Incident Type. Either name or id of the parent type can be used. */
                        parent_type: string;
                        /** @description Whether the Incident Type is enabled. Defaults to true if not provided. */
                        enabled?: boolean;
                        /** @description The description of the Incident Type. */
                        description?: string;
                    };
                };
            };
        };
        responses: {
            /** @description The incident type object created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident_type: components["schemas"]["IncidentType"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getIncidentType: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The incident type requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident_type: components["schemas"]["IncidentType"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateIncidentType: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Details of the incident type to be created. */
                    incident_type: {
                        /** @description The display name of the Incident Type. */
                        display_name?: string;
                        /** @description Whether the Incident Type is enabled. Defaults to true if not provided. */
                        enabled?: boolean;
                        /** @description The description of the Incident Type. */
                        description?: string;
                    };
                };
            };
        };
        responses: {
            /** @description The incident type object updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        incident_type: components["schemas"]["IncidentType"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listIncidentTypeCustomFields: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_customfields_field"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The custom fields for the incident type requested. Passing in include[]=field_options will return the field options for the custom field. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        fields: components["schemas"]["IncidentTypeCustomFieldWithOptions"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createIncidentTypeCustomField: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Details of the custom field to be created. */
                    field: {
                        /** @description The name of the custom field. */
                        name: string;
                        /** @description The display name of the Incident Type. */
                        display_name: string;
                        /** @description The data type of the custom field. */
                        data_type: string;
                        /**
                         * @description The field type of the custom field.
                         * @enum {string}
                         */
                        field_type: "single_value" | "single_value_fixed" | "multi_value" | "multi_value_fixed";
                        /** @description The description of the custom field. */
                        description?: string;
                        /** @description Whether the custom field is enabled. */
                        enabled?: boolean;
                        /** @description The default value of the custom field. */
                        default_value?: string;
                        /** @description The options for the custom field. Can only be applied to fields with a `field_type` of `single_value_fixed` or `multi_value_fixed`. When creating a fixed-value custom field, this property is required, as the field must be created with at least one field option. */
                        field_options?: components["schemas"]["CustomFieldsFieldOption"][];
                    };
                };
            };
        };
        responses: {
            /** @description The custom field object created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field: components["schemas"]["IncidentTypeCustomFields"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getIncidentTypeCustomField: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_customfields_field"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The incident type custom field requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field: components["schemas"]["IncidentTypeCustomFieldWithOptions"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateIncidentTypeCustomField: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Details of the custom field to be updated. */
                    field: {
                        /** @description The display name of the Incident Type. */
                        display_name?: string;
                        /** @description Whether the Incident Type is enabled. */
                        enabled?: boolean;
                        /** @description The default value of the custom field. */
                        default_value?: string;
                        /** @description The description of the custom field. */
                        description?: string;
                        /** @description List of options to upsert on the custom field. Can only be applied to fields with a `field_type` of `single_value_fixed` or `multi_value_fixed`. When an `id` property is included, this will update the value of the specified field option. Without an `id` property, that field option will be added to the field. Any existing field options not included in the upsert list will be deleted (unless the current default value refers to a field option to be deleted). */
                        field_options?: components["schemas"]["CustomFieldsFieldOption"][];
                    };
                };
            };
        };
        responses: {
            /** @description The updated custom field object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field: components["schemas"]["IncidentTypeCustomFieldWithOptions"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteIncidentTypeCustomField: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listIncidentTypeCustomField: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field option for the custom field requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_options: components["schemas"]["CustomFieldsFieldOption"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createIncidentTypeCustomFieldFieldOptions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Details of the field option to be created. */
                    field_option: {
                        data: {
                            /** @description The data type of the Field Option for the Custom Field. */
                            data_type: string;
                            /** @description The value of the Field Option for the Custom Field. */
                            value: string;
                        };
                    };
                };
            };
        };
        responses: {
            /** @description The field option for the custom field created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_option: components["schemas"]["CustomFieldsEditableFieldOption"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getIncidentTypeCustomFieldFieldOptions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
                /** @description The ID of the field option. */
                field_option_id: components["parameters"]["field_option_id"];
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field option of the custom field requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_option: components["schemas"]["CustomFieldsEditableFieldOption"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateIncidentTypeCustomFieldFieldOption: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
                /** @description The ID of the field option. */
                field_option_id: components["parameters"]["field_option_id"];
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Details of the field option on a custom field to be updated. */
                    field_option: {
                        data: {
                            /** @description The data type of the Field Option on the Custom Field. */
                            data_type: string;
                            /** @description The value of the Field Option on the Custom Field. */
                            value: string;
                        };
                    };
                };
            };
        };
        responses: {
            /** @description The field option for the custom field updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_option: components["schemas"]["CustomFieldsEditableFieldOption"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteIncidentTypeCustomFieldFieldOption: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID or name of the Incident Type. */
                type_id_or_name: components["parameters"]["incident_type_id_or_name"];
                /** @description The ID of the field option. */
                field_option_id: components["parameters"]["field_option_id"];
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field option was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listCustomFieldsFields: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_customfields_field"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of fields. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        fields: components["schemas"]["CustomFieldsFieldWithOptions"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createCustomFieldsField: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    field: components["schemas"]["CustomFieldsFieldWithOptions"];
                };
            };
        };
        responses: {
            /** @description The field object created, along with the Field Options if provided. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field: components["schemas"]["CustomFieldsFieldWithOptions"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getCustomFieldsField: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_customfields_field"];
            };
            header?: never;
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field: components["schemas"]["CustomFieldsFieldWithOptions"];
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateCustomFieldsField: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    field: components["schemas"]["CustomFieldsEditableField"];
                };
            };
        };
        responses: {
            /** @description The field object updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field: components["schemas"]["CustomFieldsField"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteCustomFieldsField: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listCustomFieldsFieldOptions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of field options. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_options: components["schemas"]["CustomFieldsFieldOption"][];
                    };
                };
            };
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createCustomFieldsFieldOption: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    field_option: components["schemas"]["CustomFieldsFieldOption"];
                };
            };
        };
        responses: {
            /** @description The field option created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_option: components["schemas"]["CustomFieldsFieldOption"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateCustomFieldsFieldOption: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
                /** @description The ID of the field option. */
                field_option_id: components["parameters"]["field_option_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    field_option: components["schemas"]["CustomFieldsEditableFieldOption"];
                };
            };
        };
        responses: {
            /** @description The field option object updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_option: components["schemas"]["CustomFieldsFieldOption"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteCustomFieldsFieldOption: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
                /** @description The ID of the field option. */
                field_option_id: components["parameters"]["field_option_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field option was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listLicenseAllocations: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description License allocations to Users within your Account */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        license_allocations?: {
                            user: components["schemas"]["UserReference"];
                            license: components["schemas"]["LicenseWithCounts"]["allOf"]["0"];
                            /**
                             * Format: date-time
                             * @description Indicates the date and time the License was allocated to the User
                             */
                            allocated_at: string;
                        }[];
                    } & components["schemas"]["Pagination"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    listLicenses: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Licenses associated with your Account */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        licenses?: components["schemas"]["LicenseWithCounts"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    listLogEntries: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Time zone in which results will be rendered. This will default to the account time zone. */
                time_zone?: components["parameters"]["time_zone"];
                /** @description The start of the date range over which you want to search. */
                since?: components["parameters"]["since"];
                /** @description The end of the date range over which you want to search. */
                until?: components["parameters"]["until"];
                /** @description If `true`, will return a subset of log entries that show only the most important changes to the incident. */
                is_overview?: components["parameters"]["log_entry_is_overview"];
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_log_entry"];
                /** @description An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter. */
                "team_ids[]"?: components["parameters"]["team_ids"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of log entries. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        log_entries: (components["schemas"]["AcknowledgeLogEntry"] | components["schemas"]["AnnotateLogEntry"] | components["schemas"]["AssignLogEntry"] | components["schemas"]["DelegateLogEntry"] | components["schemas"]["EscalateLogEntry"] | components["schemas"]["ExhaustEscalationPathLogEntry"] | components["schemas"]["NotifyLogEntry"] | components["schemas"]["ReachAckLimitLogEntry"] | components["schemas"]["ReachTriggerLimitLogEntry"] | components["schemas"]["RepeatEscalationPathLogEntry"] | components["schemas"]["ResolveLogEntry"] | components["schemas"]["SnoozeLogEntry"] | components["schemas"]["TriggerLogEntry"] | components["schemas"]["UnacknowledgeLogEntry"] | components["schemas"]["UrgencyChangeLogEntry"])[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getLogEntry: {
        parameters: {
            query?: {
                /** @description Time zone in which results will be rendered. This will default to the account time zone. */
                time_zone?: components["parameters"]["time_zone"];
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_log_entry"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A single log entry. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        log_entry: components["schemas"]["AcknowledgeLogEntry"] | components["schemas"]["AnnotateLogEntry"] | components["schemas"]["AssignLogEntry"] | components["schemas"]["DelegateLogEntry"] | components["schemas"]["EscalateLogEntry"] | components["schemas"]["ExhaustEscalationPathLogEntry"] | components["schemas"]["NotifyLogEntry"] | components["schemas"]["ReachAckLimitLogEntry"] | components["schemas"]["ReachTriggerLimitLogEntry"] | components["schemas"]["RepeatEscalationPathLogEntry"] | components["schemas"]["ResolveLogEntry"] | components["schemas"]["SnoozeLogEntry"] | components["schemas"]["TriggerLogEntry"] | components["schemas"]["UnacknowledgeLogEntry"] | components["schemas"]["UrgencyChangeLogEntry"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateLogEntryChannel: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The log entry channel to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    /** @description The parameters to update. */
                    channel: {
                        /** @description New channel details */
                        details: string;
                        /**
                         * @description Channel type. Cannot be changed and must match the present value.
                         * @enum {string}
                         */
                        type: "web_trigger" | "mobile";
                    };
                };
            };
        };
        responses: {
            /** @description The channel information modification was accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listMaintenanceWindows: {
        parameters: {
            query?: {
                /** @description Filters the result, showing only the records whose name matches the query. */
                query?: components["parameters"]["query"];
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter. */
                "team_ids[]"?: components["parameters"]["team_ids"];
                /** @description An array of service IDs. Only results related to these services will be returned. */
                "service_ids[]"?: components["parameters"]["services"];
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_maintenance_window"];
                /** @description Only return maintenance windows in a given state. */
                filter?: components["parameters"]["filter_maintenance_windows"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of maintenance windows. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        maintenance_windows: components["schemas"]["MaintenanceWindow"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createMaintenanceWindow: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description The maintenance window object. */
        requestBody?: {
            content: {
                "application/json": {
                    maintenance_window: components["schemas"]["MaintenanceWindow"];
                };
            };
        };
        responses: {
            /** @description The maintenance window that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        maintenance_window: components["schemas"]["MaintenanceWindow"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getMaintenanceWindow: {
        parameters: {
            query?: {
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_maintenance_window"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The maintenance window that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        maintenance_window: components["schemas"]["MaintenanceWindow"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateMaintenanceWindow: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The maintenance window to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    maintenance_window: components["schemas"]["MaintenanceWindow"];
                };
            };
        };
        responses: {
            /** @description The maintenance window that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        maintenance_window: components["schemas"]["MaintenanceWindow"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteMaintenanceWindow: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The maintenance window was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            /** @description The maintenance window can't be deleted because it has already ended. */
            405: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            429: components["responses"]["TooManyRequests"];
        };
    };
    listNotifications: {
        parameters: {
            query: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Time zone in which results will be rendered. This will default to the account time zone. */
                time_zone?: components["parameters"]["time_zone"];
                /** @description The start of the date range over which you want to search. The time element is optional. */
                since: components["parameters"]["since_notifications"];
                /** @description The end of the date range over which you want to search. This should be in the same format as since. The size of the date range must be less than 3 months. */
                until: components["parameters"]["until_notifications"];
                /** @description Return notification of this type only. */
                filter?: components["parameters"]["filter_notifications"];
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_notifications"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of notifications. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        notifications: components["schemas"]["Notification"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteOauthDelegations: {
        parameters: {
            query: {
                /** @description The ID of the user for whom this request is applicable. */
                user_id: components["parameters"]["oauth_delegation_user_id"];
                /** @description The type of OAuth delegations this request should target. Allowed values are 'mobile' (to sign users out of the mobile app) and 'web' (to sign users out of the web app). You can pass one or more types in, separated by commas (e.g., type=web,mobile). */
                type: components["parameters"]["oauth_delegation_type"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The request to delete delegations has been processed. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @example ok */
                        status?: string;
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getOauthDelegationsRevocationRequestsStatus: {
        parameters: {
            query?: {
                /** @description The end of the date range over which you want to search. If not specified, this will default to current time. */
                requested_at_end?: components["parameters"]["oauth_delegation_requested_at_end"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listOnCalls: {
        parameters: {
            query?: {
                /** @description Time zone in which results will be rendered. This will default to the account time zone. */
                time_zone?: components["parameters"]["time_zone"];
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_oncalls"];
                /** @description Filters the results, showing only on-calls for the specified user IDs. */
                "user_ids[]"?: components["parameters"]["user_ids_oncalls"];
                /** @description Filters the results, showing only on-calls for the specified escalation policy IDs. */
                "escalation_policy_ids[]"?: components["parameters"]["escalation_policy_ids_oncalls"];
                /** @description Filters the results, showing only on-calls for the specified schedule IDs. If `null` is provided in the array, it includes permanent on-calls due to direct user escalation targets. */
                "schedule_ids[]"?: components["parameters"]["schedule_ids_oncalls"];
                /** @description The start of the time range over which you want to search. If an on-call period overlaps with the range, it will be included in the result. Defaults to current time. On-call shifts are limited to 90 days in the future. */
                since?: components["parameters"]["since_oncalls"];
                /** @description The end of the time range over which you want to search. If an on-call period overlaps with the range, it will be included in the result. Defaults to current time. On-call shifts are limited to 90 days in the future, and the `until` time cannot be before the `since` time. */
                until?: components["parameters"]["until_oncalls"];
                /** @description This will filter on-calls such that only the earliest on-call for each combination of escalation policy, escalation level, and user is returned. This is useful for determining when the "next" on-calls are for a given set of filters. */
                earliest?: components["parameters"]["earliest_oncalls"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of on-call objects. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        oncalls: components["schemas"]["Oncall"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getPausedIncidentReportAlerts: {
        parameters: {
            query?: {
                /** @description The start of the date range over which you want to search. */
                since?: components["parameters"]["since"];
                /** @description The end of the date range over which you want to search. */
                until?: components["parameters"]["until"];
                /** @description Specifies a filter to limit the scope of reporting to a particular service */
                service_id?: components["parameters"]["paused_incident_reports_service_id"];
                /** @description Specifies a filter to scope the response to either alerts suspended by Auto Pause or Event Rules. */
                suspended_by?: components["parameters"]["paused_incident_reports_suspended_by"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paused Incident Reporting on Alerts for the Account or scoped to a Service. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A list of the 5 most recent paused Alerts that weere triggered and 5 most recent Alerts that were reesolved before being triggerd. */
                        paused_incident_reporting_alerts?: {
                            /** @description The start of the date range over which the report data is represented. */
                            since?: string;
                            /** @description The end of the date range over which the report data is represented. */
                            until?: string;
                            /** @description An array of Alerts that were triggered after being paused. */
                            triggered_after_pause_alerts?: {
                                /** @description The Alert ID */
                                id?: string;
                                /** @description The Alert's Service ID */
                                service_id?: string;
                                /** @description The date/time the Alert was created */
                                created_at?: string;
                            }[];
                            /** @description An array of Alerts that were resolved after being paused. */
                            resolved_after_pause_alerts?: {
                                /** @description The Alert ID */
                                id?: string;
                                /** @description The Alert's Service ID */
                                service_id?: string;
                                /** @description The date/time the Alert was created */
                                created_at?: string;
                            }[];
                        };
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getPausedIncidentReportCounts: {
        parameters: {
            query?: {
                /** @description The start of the date range over which you want to search. */
                since?: components["parameters"]["since"];
                /** @description The end of the date range over which you want to search. */
                until?: components["parameters"]["until"];
                /** @description Specifies a filter to limit the scope of reporting to a particular service */
                service_id?: components["parameters"]["paused_incident_reports_service_id"];
                /** @description Specifies a filter to scope the response to either alerts suspended by Auto Pause or Event Rules. */
                suspended_by?: components["parameters"]["paused_incident_reports_suspended_by"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Paused Incident Reporting counts for the Account or scoped to a Service. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description A representation of Alerts that were paused, triggered after pause, and resolved after pause. */
                        paused_incident_reporting_counts?: {
                            /** @description The start of the date range over which the report data is represented. */
                            since?: string;
                            /** @description The end of the date range over which the report data is represented. */
                            until?: string;
                            /** @description The total number of paused Alerts for the Account or Servce. */
                            paused_count?: number;
                            /** @description The total number of paused Alerts for the Account or Service that were triggerd after being paused (non-transient Alerts). */
                            triggered_after_pause_count?: number;
                            /** @description The total number of paused Alerts for the Account or Service that were resolved after being paused and not triggered (transient Alerts). */
                            resolved_after_pause_count?: number;
                        };
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listPriorities: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of priorities. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        priorities: components["schemas"]["Priority"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listRulesets: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of Ruleset objects. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        rulesets?: components["schemas"]["Ruleset"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    createRuleset: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    ruleset: components["schemas"]["Ruleset"];
                };
            };
        };
        responses: {
            /** @description The Ruleset that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        ruleset?: components["schemas"]["Ruleset"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    getRuleset: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Ruleset object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        ruleset?: components["schemas"]["Ruleset"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateRuleset: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    ruleset: components["schemas"]["Ruleset"];
                };
            };
        };
        responses: {
            /** @description The Ruleset that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        ruleset?: components["schemas"]["Ruleset"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    deleteRuleset: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Ruleset was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    listRulesetEventRules: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of Event Rule objects. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        /** @description The paginated list of rules of the Ruleset. */
                        rules?: components["schemas"]["EventRule"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    createRulesetEventRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    rule: components["schemas"]["EventRule"];
                };
            };
        };
        responses: {
            /** @description The Event Rule that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        rule?: components["schemas"]["EventRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            409: components["responses"]["Conflict"];
        };
    };
    getRulesetEventRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the Event Rule to retrieve. */
                rule_id: components["parameters"]["rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Event Rule object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        rule?: components["schemas"]["EventRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateRulesetEventRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the Event Rule to retrieve. */
                rule_id: components["parameters"]["rule_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    rule?: components["schemas"]["EventRule"];
                    /** @description The id of the Event Rule to update. */
                    rule_id: string;
                };
            };
        };
        responses: {
            /** @description The Event Rule that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        rule?: components["schemas"]["EventRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    deleteRulesetEventRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the Event Rule to retrieve. */
                rule_id: components["parameters"]["rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Event Rule was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    listSchedules: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Filters the result, showing only the records whose name matches the query. */
                query?: components["parameters"]["query"];
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_schedules"];
                /** @description Time zone in which results will be rendered. This will default to the current user's time zone and then the account's time zone. */
                time_zone?: components["parameters"]["schedule_list_time_zone"];
                /** @description Specify an `user_id`, and the schedule list API will return information about this user's next on-call. */
                include_next_oncall_for_user?: components["parameters"]["include_next_oncall_for_user"];
                /** @description The start of the date range over which you want to show schedule entries. Defaults to 2 weeks before until if an until is given. Optional parameter. When provided with include[] for schedule types, populates the rendered_schedule_entries fields in the response. */
                since?: components["parameters"]["schedule_since"];
                /** @description The end of the date range over which you want to show schedule entries. Defaults to 2 weeks after since if a since is given. Optional parameter. When provided with include[] for schedule types, populates the rendered_schedule_entries fields in the response. */
                until?: components["parameters"]["schedule_until"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of schedule objects. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        schedules: components["schemas"]["Schedule"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createSchedule: {
        parameters: {
            query?: {
                /**
                 * @description Any on-call schedule entries that pass the date range bounds will be truncated at the bounds, unless the parameter `overflow=true` is passed. This parameter defaults to false.
                 *     For instance, if your schedule is a rotation that changes daily at midnight UTC, and your date range is from `2011-06-01T10:00:00Z` to `2011-06-01T14:00:00Z`:
                 *
                 *
                 *     - If you don't pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T10:00:00Z` and end of `2011-06-01T14:00:00Z`.
                 *     - If you do pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T00:00:00Z` and end of `2011-06-02T00:00:00Z`.
                 */
                overflow?: components["parameters"]["schedule_overflow"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description The schedule to be created. */
        requestBody?: {
            content: {
                "application/json": {
                    schedule: components["schemas"]["Schedule"];
                };
            };
        };
        responses: {
            /** @description The schedule object created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        schedule: components["schemas"]["Schedule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getSchedule: {
        parameters: {
            query?: {
                /** @description Time zone in which results will be rendered. This will default to the schedule's time zone. */
                time_zone?: components["parameters"]["schedule_time_zone"];
                /** @description The start of the date range over which you want to show schedule entries. Defaults to 2 weeks before until if an until is given. Optional parameter. When provided with include[] for schedule types, populates the rendered_schedule_entries fields in the response. */
                since?: components["parameters"]["schedule_since"];
                /** @description The end of the date range over which you want to show schedule entries. Defaults to 2 weeks after since if a since is given. Optional parameter. When provided with include[] for schedule types, populates the rendered_schedule_entries fields in the response. */
                until?: components["parameters"]["schedule_until"];
                /**
                 * @description Any on-call schedule entries that pass the date range bounds will be truncated at the bounds, unless the parameter `overflow=true` is passed. This parameter defaults to false.
                 *     For instance, if your schedule is a rotation that changes daily at midnight UTC, and your date range is from `2011-06-01T10:00:00Z` to `2011-06-01T14:00:00Z`:
                 *
                 *
                 *     - If you don't pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T10:00:00Z` and end of `2011-06-01T14:00:00Z`.
                 *     - If you do pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T00:00:00Z` and end of `2011-06-02T00:00:00Z`.
                 */
                overflow?: components["parameters"]["schedule_overflow"];
                /** @description Specify an `user_id`, and the schedule list API will return information about this user's next on-call. */
                include_next_oncall_for_user?: components["parameters"]["include_next_oncall_for_user"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The schedule object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        schedule: components["schemas"]["Schedule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateSchedule: {
        parameters: {
            query?: {
                /**
                 * @description Any on-call schedule entries that pass the date range bounds will be truncated at the bounds, unless the parameter `overflow=true` is passed. This parameter defaults to false.
                 *     For instance, if your schedule is a rotation that changes daily at midnight UTC, and your date range is from `2011-06-01T10:00:00Z` to `2011-06-01T14:00:00Z`:
                 *
                 *
                 *     - If you don't pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T10:00:00Z` and end of `2011-06-01T14:00:00Z`.
                 *     - If you do pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T00:00:00Z` and end of `2011-06-02T00:00:00Z`.
                 */
                overflow?: components["parameters"]["schedule_overflow"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The schedule to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    schedule: components["schemas"]["Schedule"];
                };
            };
        };
        responses: {
            /** @description The updated schedule. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        schedule: components["schemas"]["Schedule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteSchedule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The schedule was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listSchedulesAuditRecords: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description The start of the date range over which you want to search. If not specified, defaults to `now() - 24 hours` (past 24 hours) */
                since?: components["parameters"]["audit_since"];
                /** @description The end of the date range over which you want to search. If not specified, defaults to `now()`. May not be more than 31 days after `since`. */
                until?: components["parameters"]["audit_until"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Records matching the query criteria. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditRecordResponseSchema"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listScheduleOverrides: {
        parameters: {
            query: {
                /** @description The start of the date range over which you want to search. */
                since: components["parameters"]["since_schedules"];
                /** @description The end of the date range over which you want to search. */
                until: components["parameters"]["until_schedules"];
                /** @description When this parameter is present, only editable overrides will be returned. The result will only include the id of the override if this parameter is present. Only future overrides are editable. */
                editable?: components["parameters"]["editable_schedules"];
                /** @description Any on-call schedule entries that pass the date range bounds will be truncated at the bounds, unless the parameter overflow=true is passed. This parameter defaults to false. */
                overflow?: components["parameters"]["overflow_schedules"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The collection of override objects returned by the query. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        overrides: components["schemas"]["Override"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createScheduleOverride: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The overrides to be created */
        requestBody: {
            content: {
                "application/json": {
                    overrides?: components["schemas"]["Override"][];
                };
            };
        };
        responses: {
            /** @description A list of overrides requested and a status code indicating whether they were created or rejected */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description HTTP Status Code reflecting the result of creating this specific override, e.g. 201 for success, 400 for invalid parameters. */
                        status?: number;
                        /** @description If present, an array of strings representing human-readable explanations for errors found. */
                        errors?: string[];
                        override: components["schemas"]["Override"];
                    }[];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteScheduleOverride: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The override ID on the schedule. */
                override_id: components["parameters"]["schedule_override_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The override was truncated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description The override was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listScheduleUsers: {
        parameters: {
            query?: {
                /** @description The start of the date range over which you want to search. */
                since?: components["parameters"]["since"];
                /** @description The end of the date range over which you want to search. */
                until?: components["parameters"]["until"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The users on the given schedule. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        readonly users: components["schemas"]["User"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createSchedulePreview: {
        parameters: {
            query?: {
                /** @description The start of the date range over which you want to search. */
                since?: components["parameters"]["since"];
                /** @description The end of the date range over which you want to search. */
                until?: components["parameters"]["until"];
                /**
                 * @description Any on-call schedule entries that pass the date range bounds will be truncated at the bounds, unless the parameter `overflow=true` is passed. This parameter defaults to false.
                 *     For instance, if your schedule is a rotation that changes daily at midnight UTC, and your date range is from `2011-06-01T10:00:00Z` to `2011-06-01T14:00:00Z`:
                 *
                 *
                 *     - If you don't pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T10:00:00Z` and end of `2011-06-01T14:00:00Z`.
                 *     - If you do pass the `overflow=true` parameter, you will get one schedule entry returned with a start of `2011-06-01T00:00:00Z` and end of `2011-06-02T00:00:00Z`.
                 */
                overflow?: components["parameters"]["schedule_overflow"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description The schedule to be previewed. */
        requestBody?: {
            content: {
                "application/json": {
                    schedule: components["schemas"]["Schedule"];
                };
            };
        };
        responses: {
            /** @description What the schedule will look like if posted. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        schedule: components["schemas"]["Schedule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createServiceDependency: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description List of all service dependencies to be created. */
                    relationships?: {
                        /** @description The reference to the service that supports the dependent service. */
                        supporting_service?: {
                            id?: string;
                            type?: string;
                        };
                        /** @description The reference to the service that is dependent on the supporting service. */
                        dependent_service?: {
                            id?: string;
                            type?: string;
                        };
                    }[];
                };
            };
        };
        responses: {
            /** @description An array of service relationships that were successfully associated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of all the technical service's dependencies */
                        relationships?: {
                            /** @description The reference to the service that supports the technical service. */
                            supporting_service?: {
                                id?: string;
                                type?: string;
                            };
                            /** @description The reference to the service that is dependent on the technical service. */
                            dependent_service?: {
                                id?: string;
                                type?: string;
                            };
                            id?: string;
                            type?: string;
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    getBusinessServiceServiceDependencies: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of service relationships. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of all the Business Service's dependencies. */
                        relationships?: {
                            /** @description The reference to the service that supports the Business Service. */
                            supporting_service?: {
                                id?: string;
                                type?: string;
                            };
                            /** @description The reference to the service that is dependent on the Business Service. */
                            dependent_service?: {
                                id?: string;
                                type?: string;
                            };
                            id?: string;
                            type?: string;
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    deleteServiceDependency: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description List of all service dependencies to be deleted. */
                    relationships?: {
                        /** @description The reference to the service that supports the dependent service. */
                        supporting_service?: {
                            id?: string;
                            type?: string;
                        };
                        /** @description The reference to the service that is dependent on the supporting service. */
                        dependent_service?: {
                            id?: string;
                            type?: string;
                        };
                    }[];
                };
            };
        };
        responses: {
            /** @description An array of service relationships that were successfully disassociated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of all the technical service's dependencies */
                        relationships?: {
                            /** @description The reference to the service that supports the technical service. */
                            supporting_service?: {
                                id?: string;
                                type?: string;
                            };
                            /** @description The reference to the service that is dependent on the technical service. */
                            dependent_service?: {
                                id?: string;
                                type?: string;
                            };
                            id?: string;
                            type?: string;
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    getTechnicalServiceServiceDependencies: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of service relationships. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description List of all the technical service's dependencies */
                        relationships?: {
                            /** @description The reference to the service that supports the technical service. */
                            supporting_service?: {
                                id?: string;
                                type?: string;
                            };
                            /** @description The reference to the service that is dependent on the technical service. */
                            dependent_service?: {
                                id?: string;
                                type?: string;
                            };
                            id?: string;
                            type?: string;
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    listServices: {
        parameters: {
            query?: {
                /** @description Filters the result, showing only the records whose name matches the query. */
                query?: components["parameters"]["query"];
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter. */
                "team_ids[]"?: components["parameters"]["team_ids"];
                /** @description Time zone in which results will be rendered. This will default to the account time zone. */
                time_zone?: components["parameters"]["time_zone"];
                /** @description Used to specify the field you wish to sort the results on. */
                sort_by?: components["parameters"]["sort_by_service"];
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_services"];
                /** @description Filters the results, showing only services with the specified name. */
                name?: components["parameters"]["service_name"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of services. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        services: components["schemas"]["Service"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
        };
    };
    createService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description The service to be created */
        requestBody?: {
            content: {
                "application/json": {
                    service: components["schemas"]["Service"];
                };
            };
        };
        responses: {
            /** @description The service that was created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        service: components["schemas"]["Service"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
        };
    };
    getService: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_services_id"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The service requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        service: components["schemas"]["Service"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The service to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    service: components["schemas"]["Service"];
                };
            };
        };
        responses: {
            /** @description The service that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        service: components["schemas"]["Service"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    deleteService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The service was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
        };
    };
    listServiceAuditRecords: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description The start of the date range over which you want to search. If not specified, defaults to `now() - 24 hours` (past 24 hours) */
                since?: components["parameters"]["audit_since"];
                /** @description The end of the date range over which you want to search. If not specified, defaults to `now()`. May not be more than 31 days after `since`. */
                until?: components["parameters"]["audit_until"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Records matching the query criteria. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditRecordResponseSchema"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listServiceChangeEvents: {
        parameters: {
            query?: {
                /** @description The start of the date range over which you want to search, as a UTC ISO 8601 datetime string. Will return an HTTP 400 for non-UTC datetimes. */
                since?: components["parameters"]["change_since"];
                /** @description The end of the date range over which you want to search, as a UTC ISO 8601 datetime string. Will return an HTTP 400 for non-UTC datetimes. */
                until?: components["parameters"]["change_until"];
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter. */
                "team_ids[]"?: components["parameters"]["team_ids"];
                /** @description An array of integration IDs. Only results related to these integrations will be returned. */
                "integration_ids[]"?: components["parameters"]["integration_ids"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The array of Change Events returned by the query. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        change_events?: components["schemas"]["ChangeEvent"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    createServiceIntegration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The integration to be created */
        requestBody?: {
            content: {
                "application/json": {
                    integration: components["schemas"]["Integration"];
                };
            };
        };
        responses: {
            /** @description The integration that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        integration: components["schemas"]["Integration"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getServiceIntegration: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_services_integrations"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The integration ID on the service. */
                integration_id: components["parameters"]["integration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The integration that was requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        integration: components["schemas"]["Integration"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateServiceIntegration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The integration ID on the service. */
                integration_id: components["parameters"]["integration_id"];
            };
            cookie?: never;
        };
        /** @description The integration to be updated */
        requestBody?: {
            content: {
                "application/json": {
                    integration: components["schemas"]["Integration"];
                };
            };
        };
        responses: {
            /** @description The integration that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        integration: components["schemas"]["Integration"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listServiceEventRules: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_ruleset_migrated_metadata"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of Event Rule objects. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        /**
                         * Format: date-time
                         * @description The date/time the service's Event Rules were converted to a Service Orchestration. This property is only included if the `migrated_metadata` query parameter is provided.
                         */
                        readonly migrated_at?: string;
                        /** @description Reference to the user that converted the service's Event Rules to a Service Orchestration. This property is only included if the `migrated_metadata` query parameter is provided. */
                        readonly migrated_by?: {
                            readonly id?: string;
                            /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
                            readonly type?: string;
                            /**
                             * Format: url
                             * @description The API show URL at which the object is accessible
                             */
                            readonly self?: string;
                        };
                        /**
                         * @description The status indicating whether the service's Event Rules were successfully converted to a Service Orchestration. This property is only included if the `migrated_metadata` query parameter is provided.
                         * @enum {string}
                         */
                        readonly migrated_status?: "completed";
                        /** @description Reference to the Service Orchestration that the service's Event Rules were converted to. This property is only included if the `migrated_metadata` query parameter is provided. */
                        readonly migrated_to?: {
                            readonly id?: string;
                            /** @description A string that determines the schema of the object. This must be the standard name for the entity, suffixed by `_reference` if the object is a reference. */
                            readonly type?: string;
                            /**
                             * Format: url
                             * @description The API show URL at which the object is accessible
                             */
                            readonly self?: string;
                        };
                        /**
                         * @description Indicates whether the conversion was performed via the PagerDuty API or PagerDuty website. This property is only included if the `migrated_metadata` query parameter is provided.
                         * @enum {string}
                         */
                        readonly migrated_via?: "API" | "UI";
                    } & {
                        /** @description The paginated list of Event Rules of the Service. */
                        rules?: components["schemas"]["ServiceEventRule"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    createServiceEventRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    rule: components["schemas"]["ServiceEventRule"];
                };
            };
        };
        responses: {
            /** @description The Event Rule that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        rule?: components["schemas"]["ServiceEventRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            409: components["responses"]["Conflict"];
        };
    };
    convertServiceEventRulesToEventOrchestration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Event Orchestration Rules were successfully created */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Did PagerDuty successfully create equivalent Event Orchestration rules */
                        readonly convert_status?: string;
                        /**
                         * Format: url
                         * @description the API URL at which the newly created Event Orchestration rules are accessible
                         */
                        readonly converted_to?: string;
                    };
                };
            };
            /** @description Could not create equivalent Event Orchestration Rules based on the Service's current Event Rules */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        readonly error?: {
                            /** @description Error message string */
                            readonly message?: string;
                            readonly errors?: {
                                /** @description The ID of the Service Event Rule that couldn't be successfully converted. */
                                readonly rule_id?: string;
                                /** @description The position of the Service Event Rule that couldn't be successfully converted. */
                                readonly position?: number;
                                /** @description Human friendly explanations of why this Event Rule couldn't be converted into an equivalent Event Orchestration Rule. */
                                readonly messages?: string[];
                            }[];
                        };
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    getServiceEventRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the Event Rule to retrieve. */
                rule_id: components["parameters"]["rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Event Rule object. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        rule?: components["schemas"]["ServiceEventRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    updateServiceEventRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the Event Rule to retrieve. */
                rule_id: components["parameters"]["rule_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    rule?: components["schemas"]["ServiceEventRule"];
                    /** @description The id of the Event Rule to update on the Service. */
                    rule_id: string;
                };
            };
        };
        responses: {
            /** @description The Event Rule that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        rule?: components["schemas"]["ServiceEventRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    deleteServiceEventRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The id of the Event Rule to retrieve. */
                rule_id: components["parameters"]["rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Event Rule was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            405: components["responses"]["NotAllowed"];
            409: components["responses"]["Conflict"];
        };
    };
    listServiceCustomFields: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_customfields_field"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of fields. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        fields?: components["schemas"]["ServiceCustomFieldsFieldReadModel"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createServiceCustomField: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    field: components["schemas"]["ServiceCustomFieldsFieldCreateModel"];
                };
            };
        };
        responses: {
            /** @description The field object created, along with the Field Options if provided. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field: components["schemas"]["ServiceCustomFieldsFieldReadModel"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getServiceCustomField: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_customfields_field"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field?: components["schemas"]["ServiceCustomFieldsFieldReadModel"];
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateServiceCustomField: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    field: components["schemas"]["ServiceCustomFieldsFieldUpdateModel"];
                };
            };
        };
        responses: {
            /** @description The field object updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field?: components["schemas"]["ServiceCustomFieldsFieldReadModel"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteServiceCustomField: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listServiceCustomFieldOptions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of field options. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_options?: components["schemas"]["ServiceCustomFieldsFieldOptionReadModel"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createServiceCustomFieldOption: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    field_option: components["schemas"]["ServiceCustomFieldsFieldOptionUpdateModel"];
                };
            };
        };
        responses: {
            /** @description The field option created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_option?: components["schemas"]["ServiceCustomFieldsFieldOptionReadModel"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getServiceCustomFieldOption: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
                /** @description The ID of the field option. */
                field_option_id: components["parameters"]["field_option_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requested field option. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_option?: components["schemas"]["ServiceCustomFieldsFieldOptionReadModel"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateServiceCustomFieldOption: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
                /** @description The ID of the field option. */
                field_option_id: components["parameters"]["field_option_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    field_option: components["schemas"]["ServiceCustomFieldsFieldOptionUpdateModel"];
                };
            };
        };
        responses: {
            /** @description The field option updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        field_option?: components["schemas"]["ServiceCustomFieldsFieldOptionReadModel"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteServiceCustomFieldOption: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the field. */
                field_id: components["parameters"]["field_id"];
                /** @description The ID of the field option. */
                field_option_id: components["parameters"]["field_option_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The field option was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getServiceCustomFieldValues: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The list of custom field values. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        custom_fields?: components["schemas"]["ServiceCustomFieldsFieldValueReadModel"][];
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateServiceCustomFieldValues: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    custom_fields: components["schemas"]["ServiceCustomFieldsFieldValueUpdateModel"][];
                };
            };
        };
        responses: {
            /** @description The custom field values were updated. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        custom_fields: components["schemas"]["ServiceCustomFieldsFieldValueReadModel"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listServiceFeatureEnablements: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The list of feature enablement settings for the service. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Array of feature enablement settings. */
                        enablements?: components["schemas"]["FeatureEnablement"][];
                    };
                };
            };
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateServiceFeatureEnablement: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The feature enablement identifier, typically the name of the product addon. Currently only `aiops` is supported. */
                feature_name: components["parameters"]["enablement_feature_name"];
            };
            cookie?: never;
        };
        /** @description The feature enablement setting to apply. */
        requestBody?: {
            content: {
                "application/json": {
                    enablement: components["schemas"]["FeatureEnablement"];
                };
            };
        };
        responses: {
            /** @description The feature enablement setting was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        enablement?: components["schemas"]["FeatureEnablement"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getSessionConfigurations: {
        parameters: {
            query?: {
                /** @description Session configuration type. If omitted, returns both mobile and web configurations. */
                type?: components["parameters"]["optional_session_configuration_type"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Session Configurations retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        session_configurations: {
                            /**
                             * @description The session configuration type (mobile or web)
                             * @example web
                             * @enum {string}
                             */
                            type: "mobile" | "web";
                            /**
                             * @description Absolute session time to live in seconds
                             * @example 3600
                             */
                            absolute_session_ttl: number;
                            /**
                             * @description Idle session time to live in seconds
                             * @example 1800
                             */
                            idle_session_ttl: number;
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateSessionConfigurations: {
        parameters: {
            query: {
                /** @description Session configuration type. This can be either 'mobile' or 'web', or a comma-separated list of both. */
                type: components["parameters"]["session_configuration_type"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    session_configuration: {
                        /**
                         * @description Absolute session time to live in seconds
                         * @example 3600
                         */
                        absolute_session_ttl: number;
                        /**
                         * @description Idle session time to live in seconds
                         * @example 600
                         */
                        idle_session_ttl: number;
                    };
                };
            };
        };
        responses: {
            /** @description Session Configurations updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        session_configurations: {
                            /**
                             * @description The session configuration type (mobile or web)
                             * @example web
                             * @enum {string}
                             */
                            type: "mobile" | "web";
                            /**
                             * @description Absolute session time to live in seconds
                             * @example 3600
                             */
                            absolute_session_ttl: number;
                            /**
                             * @description Idle session time to live in seconds
                             * @example 1800
                             */
                            idle_session_ttl: number;
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteSessionConfigurations: {
        parameters: {
            query: {
                /** @description Session configuration type. This can be either 'mobile' or 'web', or a comma-separated list of both. */
                type: components["parameters"]["session_configuration_type"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Session Configurations deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStandards: {
        parameters: {
            query?: {
                active?: components["parameters"]["active_standard"];
                resource_type?: components["parameters"]["query_resource_type_standard"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        standards?: components["schemas"]["Standard"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateStandard: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description Id of the standard */
                id: components["parameters"]["id_standard"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    active?: boolean;
                    values?: {
                        regex?: string;
                    };
                    description?: string;
                    inclusions?: components["schemas"]["StandardInclusionExclusion"][];
                    exclusions?: components["schemas"]["StandardInclusionExclusion"][];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Standard"];
                };
            };
            400: components["responses"]["UnprocessableEntity"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listResourceStandardsManyServices: {
        parameters: {
            query: {
                /** @description Ids of resources to apply the standards. Maximum of 100 items */
                ids: components["parameters"]["resource_ids_standard"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                resource_type: components["parameters"]["resource_type_standard"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        resources?: components["schemas"]["StandardApplied"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listResourceStandards: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description Id of the resource to apply the standards. */
                id: components["parameters"]["resource_id_standard"];
                resource_type: components["parameters"]["resource_type_standard"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StandardApplied"];
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStatusDashboards: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CursorPagination"] & {
                        status_dashboards?: components["schemas"]["StatusDashboard"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusDashboardById: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        status_dashboard?: components["schemas"]["StatusDashboard"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusDashboardServiceImpactsById: {
        parameters: {
            query?: {
                /** @description Provides access to additional fields such as highest priority per business service and total impacted count */
                "additional_fields[]"?: components["parameters"]["impacts_additional_fields"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LiveListResponse"] & {
                        services?: components["schemas"]["Impact"][];
                    } & {
                        additional_fields?: {
                            total_impacted_count?: number;
                        };
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusDashboardByUrlSlug: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The `url_slug` for a status dashboard */
                url_slug: components["parameters"]["url_slug"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        status_dashboard?: components["schemas"]["StatusDashboard"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusDashboardServiceImpactsByUrlSlug: {
        parameters: {
            query?: {
                /** @description Provides access to additional fields such as highest priority per business service and total impacted count */
                "additional_fields[]"?: components["parameters"]["impacts_additional_fields"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The `url_slug` for a status dashboard */
                url_slug: components["parameters"]["url_slug"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LiveListResponse"] & {
                        services?: components["schemas"]["Impact"][];
                    } & {
                        additional_fields?: {
                            total_impacted_count?: number;
                        };
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStatusPages: {
        parameters: {
            query?: {
                /** @description The type of the Status Page. */
                status_page_type?: components["parameters"]["status_page_type"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        status_pages?: components["schemas"]["StatusPage"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStatusPageImpacts: {
        parameters: {
            query?: {
                /** @description Filter by Post type. */
                post_type?: components["parameters"]["status_page_impact_post_type"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        impacts?: components["schemas"]["StatusPageImpact"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusPageImpact: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Impact. */
                impact_id: components["parameters"]["status_page_impact_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        impact?: components["schemas"]["StatusPageImpact"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStatusPageServices: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        services?: components["schemas"]["StatusPageService"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusPageService: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page service. */
                service_id: components["parameters"]["status_page_service_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        service?: components["schemas"]["StatusPageService"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStatusPageSeverities: {
        parameters: {
            query?: {
                /** @description Filter by Post type. */
                post_type?: components["parameters"]["status_page_severity_post_type"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        severities?: components["schemas"]["StatusPageSeverity"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusPageSeverity: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page severity. */
                severity_id: components["parameters"]["status_page_severity_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        severity?: components["schemas"]["StatusPageSeverity"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStatusPageStatuses: {
        parameters: {
            query?: {
                /** @description Filter by Post type. */
                post_type?: components["parameters"]["status_page_status_post_type"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        statuses?: components["schemas"]["StatusPageStatus"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusPageStatus: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page status. */
                status_id: components["parameters"]["status_page_status_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        status?: components["schemas"]["StatusPageStatus"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStatusPagePosts: {
        parameters: {
            query?: {
                /** @description Filter by Post type. */
                post_type?: components["parameters"]["status_page_post_type"];
                /** @description Filter by the reviewed status of the Post to retrieve. */
                reviewed_status?: components["parameters"]["status_page_post_reviewed_status"];
                /** @description Filter by an array of Status identifiers. */
                "status[]"?: components["parameters"]["status_page_post_status"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        posts?: components["schemas"]["StatusPagePost"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createStatusPagePost: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /**
                 * @example {
                 *       "post": {
                 *         "ends_at": "2023-12-12T11:00:00.000Z",
                 *         "post_type": "maintenance",
                 *         "starts_at": "2023-12-12T11:00:00.000Z",
                 *         "status_page": {
                 *           "id": "PR5LMML",
                 *           "type": "status_page"
                 *         },
                 *         "title": "maintenance window for database upgrade",
                 *         "type": "status_page_post",
                 *         "updates": [
                 *           {
                 *             "impacted_services": [
                 *               {
                 *                 "impact": {
                 *                   "id": "PY5OM08",
                 *                   "type": "status_page_impact"
                 *                 },
                 *                 "service": {
                 *                   "id": "PYHMEI3",
                 *                   "type": "status_page_service"
                 *                 }
                 *               }
                 *             ],
                 *             "message": "<p>Message</p>",
                 *             "update_frequency_ms": null,
                 *             "notify_subscribers": false,
                 *             "severity": {
                 *               "id": "PY5OM08",
                 *               "type": "status_page_severity"
                 *             },
                 *             "status": {
                 *               "id": "P0400H4",
                 *               "type": "status_page_status"
                 *             },
                 *             "type": "status_page_post_update"
                 *           }
                 *         ]
                 *       }
                 *     }
                 */
                "application/json": {
                    post: components["schemas"]["StatusPagePostPostRequest"];
                };
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "post": {
                     *         "ends_at": "2023-12-12T11:00:00.000Z",
                     *         "id": "PIJ90N7",
                     *         "post_type": "maintenance",
                     *         "postmortem": {
                     *           "id": "PWZ0PTR",
                     *           "self": "https://api.pagerduty.com/status_pages/PR5LMML/posts/PIJ90N7/postmortem",
                     *           "type": "status_page_postmortem"
                     *         },
                     *         "self": "https://api.pagerduty.com/status_pages/PR5LMML/posts/PIJ90N7",
                     *         "starts_at": "2023-12-12T11:00:00.000Z",
                     *         "status_page": {
                     *           "id": "PR5LMML",
                     *           "type": "status_page"
                     *         },
                     *         "title": "maintenance window for database upgrade",
                     *         "type": "status_page_post",
                     *         "updates": [
                     *           {
                     *             "id": "P7HUBBZ",
                     *             "self": "https://api.pagerduty.com/status_pages/PR5LMML/posts/PIJ90N7/post_updates/P7HUBBZ",
                     *             "type": "status_page_post_update"
                     *           }
                     *         ]
                     *       }
                     *     }
                     */
                    "application/json": {
                        post?: components["schemas"]["StatusPagePost"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusPagePost: {
        parameters: {
            query?: {
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["status_page_post_include"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        post?: components["schemas"]["StatusPagePost"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateStatusPagePost: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /**
                 * @example {
                 *       "post": {
                 *         "ends_at": "2023-12-12T11:00:00.000Z",
                 *         "post_type": "maintenance",
                 *         "starts_at": "2023-12-12T11:00:00.000Z",
                 *         "status_page": {
                 *           "id": "PR5LMML",
                 *           "type": "status_page"
                 *         },
                 *         "title": "maintenance window for database upgrade",
                 *         "type": "status_page_post"
                 *       }
                 *     }
                 */
                "application/json": {
                    post: components["schemas"]["StatusPagePostPutRequest"];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        post?: components["schemas"]["StatusPagePost"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteStatusPagePost: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStatusPagePostUpdates: {
        parameters: {
            query?: {
                /** @description Filter by the reviewed status of the Post Update to retrieve. */
                reviewed_status?: components["parameters"]["status_page_post_update_reviewed_status"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        post_updates?: components["schemas"]["StatusPagePostUpdate"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createStatusPagePostUpdate: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /**
                 * @example {
                 *       "post_update": {
                 *         "impacted_services": [
                 *           {
                 *             "impact": {
                 *               "id": "PY5OM08",
                 *               "type": "status_page_impact"
                 *             },
                 *             "service": {
                 *               "id": "PYHMEI3",
                 *               "type": "status_page_service"
                 *             }
                 *           }
                 *         ],
                 *         "message": "<p>Message</p>",
                 *         "notify_subscribers": false,
                 *         "post": {
                 *           "id": "P6F2CJ3",
                 *           "type": "status_page_post"
                 *         },
                 *         "severity": {
                 *           "id": "PY5OM08",
                 *           "type": "status_page_severity"
                 *         },
                 *         "status": {
                 *           "id": "P0400H4",
                 *           "type": "status_page_status"
                 *         },
                 *         "type": "status_page_post_update"
                 *       }
                 *     }
                 */
                "application/json": {
                    post_update: components["schemas"]["StatusPagePostUpdateRequest"];
                };
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "post_update": {
                     *         "id": "PXSOCH0",
                     *         "impacted_services": [
                     *           {
                     *             "impact": {
                     *               "id": "PY5OM08",
                     *               "self": "https://api.pagerduty.com/status_pages/PR5LMML/impacts/PY5OM08",
                     *               "type": "status_page_impact"
                     *             },
                     *             "service": {
                     *               "id": "PYHMEI3",
                     *               "self": "https://api.pagerduty.com/status_pages/PR5LMML/services/PYHMEI3",
                     *               "type": "status_page_service"
                     *             }
                     *           }
                     *         ],
                     *         "message": "<p>We will be undergoing schedule maitenance at this date and time</p>",
                     *         "notify_subscribers": false,
                     *         "post": {
                     *           "id": "P6F2CJ3",
                     *           "self": "https://api.pagerduty.com/status_pages/PR5LMML/posts/P6F2CJ3",
                     *           "type": "status_page_post"
                     *         },
                     *         "reported_at": "2023-12-12T10:08:19.000Z",
                     *         "self": "https://api.pagerduty.com/status_pages/PR5LMML/posts/P6F2CJ3/post_updates/PXSOCH0",
                     *         "severity": {
                     *           "id": "P6F2CJ4",
                     *           "self": "https://api.pagerduty.com/status_pages/PR5LMML/severities/P6F2CJ4",
                     *           "type": "status_page_severity"
                     *         },
                     *         "status": {
                     *           "id": "P6F2CJ3",
                     *           "self": "https://api.pagerduty.com/status_pages/PR5LMML/statuses/P6F2CJ3",
                     *           "type": "status_page_status"
                     *         },
                     *         "type": "status_page_post_update",
                     *         "update_frequency_ms": 300000
                     *       }
                     *     }
                     */
                    "application/json": {
                        post_update?: components["schemas"]["StatusPagePostUpdate"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getPostUpdate: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
                /** @description The ID of the Status Page Post Update. */
                post_update_id: components["parameters"]["status_page_post_update_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        post_update?: components["schemas"]["StatusPagePostUpdate"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateStatusPagePostUpdate: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
                /** @description The ID of the Status Page Post Update. */
                post_update_id: components["parameters"]["status_page_post_update_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /**
                 * @example {
                 *       "post_update": {
                 *         "impacted_services": [
                 *           {
                 *             "impact": {
                 *               "id": "PY5OM08",
                 *               "type": "status_page_impact"
                 *             },
                 *             "service": {
                 *               "id": "PYHMEI3",
                 *               "type": "status_page_service"
                 *             }
                 *           }
                 *         ],
                 *         "message": "<p>Message</p>",
                 *         "notify_subscribers": false,
                 *         "post": {
                 *           "id": "P6F2CJ3",
                 *           "type": "status_page_post"
                 *         },
                 *         "severity": {
                 *           "id": "PY5OM08",
                 *           "type": "status_page_severity"
                 *         },
                 *         "status": {
                 *           "id": "P0400H4",
                 *           "type": "status_page_status"
                 *         },
                 *         "type": "status_page_post_update"
                 *       }
                 *     }
                 */
                "application/json": {
                    post_update: components["schemas"]["StatusPagePostUpdateRequest"];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        post_update?: components["schemas"]["StatusPagePostUpdate"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteStatusPagePostUpdate: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
                /** @description The ID of the Status Page Post Update. */
                post_update_id: components["parameters"]["status_page_post_update_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getPostmortem: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        postmortem?: components["schemas"]["StatusPagePostmortem"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateStatusPagePostmortem: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /**
                 * @example {
                 *       "postmortem": {
                 *         "message": "<p>Something wrong happened and this is a postmortem.<p>",
                 *         "notify_subscribers": true,
                 *         "post": {
                 *           "id": "P6F2CJ3",
                 *           "self": "https://api.pagerduty.com/status_pages/PR5LMML/posts/P6F2CJ3",
                 *           "type": "status_page_post"
                 *         },
                 *         "type": "status_page_post_postmortem"
                 *       }
                 *     }
                 */
                "application/json": {
                    postmortem: components["schemas"]["StatusPagePostmortemRequest"];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        postmortem?: components["schemas"]["StatusPagePostmortem"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createStatusPagePostmortem: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /**
                 * @example {
                 *       "postmortem": {
                 *         "message": "<p>Something wrong happened and this is a postmortem.<p>",
                 *         "notify_subscribers": true,
                 *         "post": {
                 *           "id": "P6F2CJ3",
                 *           "self": "https://api.pagerduty.com/status_pages/PR5LMML/posts/P6F2CJ3",
                 *           "type": "status_page_post"
                 *         },
                 *         "type": "status_page_post_postmortem"
                 *       }
                 *     }
                 */
                "application/json": {
                    postmortem?: components["schemas"]["StatusPagePostmortemRequest"];
                };
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "postmortem": {
                     *         "id": "PIJ90N7",
                     *         "message": "<p>Something wrong happened and this is a postmortem.<p>",
                     *         "notify_subscribers": true,
                     *         "post": {
                     *           "id": "P6F2CJ3",
                     *           "self": "https://api.pagerduty.com/status_pages/PR5LMML/posts/P6F2CJ3",
                     *           "type": "status_page_post"
                     *         },
                     *         "reported_at": "2023-09-13T10:34:04.000Z",
                     *         "self": "https://api.pagerduty.com/status_pages/PR5LMML/posts/P6F2CJ3/postmortem",
                     *         "type": "status_page_post_postmortem"
                     *       }
                     *     }
                     */
                    "application/json": {
                        postmortem?: components["schemas"]["StatusPagePostmortem"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteStatusPagePostmortem: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page Post. */
                post_id: components["parameters"]["status_page_post_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listStatusPageSubscriptions: {
        parameters: {
            query?: {
                /** @description Filter by Subscription status. */
                status?: components["parameters"]["status_page_subscription_status"];
                /** @description Filter by Subscription channel. */
                channel?: components["parameters"]["status_page_subscription_channel"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        subscriptions?: components["schemas"]["StatusPageSubscription"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createStatusPageSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                /**
                 * @example {
                 *       "subscription": {
                 *         "channel": "email",
                 *         "contact": "joe@email.example",
                 *         "status_page": {
                 *           "id": "PIJ90N7",
                 *           "type": "status_page"
                 *         },
                 *         "subscribable_object": {
                 *           "id": "PSX4LJI",
                 *           "type": "status_page_service"
                 *         },
                 *         "type": "status_page_subscription"
                 *       }
                 *     }
                 */
                "application/json": {
                    /**
                     * StatusPageSubscriptionRequest
                     * @description Request schema for creating a StatusPageSubscription.
                     */
                    subscription: {
                        /**
                         * SubscriptionChannel
                         * @description The channel of the Subscription.
                         * @enum {string}
                         */
                        channel: "webhook" | "email";
                        /** @description The subscriber's contact - email address or webhook URL. */
                        contact: string;
                        /** @description Status Page */
                        status_page: {
                            /** @description The id of the status page. */
                            id: string;
                            /** @description A string that determines the schema of the object. */
                            type?: string;
                        };
                        /**
                         * SubscribableObject
                         * @description The subscribed entity for a given subscription.
                         */
                        subscribable_object: {
                            /** @description The ID of the subscribed entity for a given subscription. */
                            id?: string;
                            /**
                             * @description The type of the subscribed entity for a given subscription.
                             * @enum {string}
                             */
                            type?: "status_page" | "status_page_service" | "status_page_post";
                        };
                        /** @description A string that determines the schema of the object. */
                        type: string;
                    };
                };
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    /**
                     * @example {
                     *       "subscription": {
                     *         "channel": "email",
                     *         "contact": "address@email.example",
                     *         "id": "PWZ0PTR",
                     *         "self": "https://api.pagerduty.com/status_pages/PIJ90N7/subscriptions/PWZ0PTR",
                     *         "status": "active",
                     *         "status_page": {
                     *           "id": "PIJ90N7",
                     *           "type": "status_page"
                     *         },
                     *         "subscribable_object": {
                     *           "id": "PSX4LJI",
                     *           "type": "status_page_service"
                     *         },
                     *         "type": "status_page_subscription"
                     *       }
                     *     }
                     */
                    "application/json": {
                        subscription?: components["schemas"]["StatusPageSubscription"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getStatusPageSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page subscription. */
                subscription_id: components["parameters"]["status_page_subscription_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        subscription?: components["schemas"]["StatusPageSubscription"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteStatusPageSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The ID of the Status Page subscription. */
                subscription_id: components["parameters"]["status_page_subscription_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listTags: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Filters the result, showing only the tags whose label matches the query. */
                query?: components["parameters"]["tag_query"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of tags names. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        tags: components["schemas"]["Tag"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createTags: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    tag: components["schemas"]["Tag"];
                };
            };
        };
        responses: {
            /** @description The tag that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        tag: components["schemas"]["Tag"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getTag: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The tag requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        tag: components["schemas"]["Tag"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteTag: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The tag was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getTagsByEntityType: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description Type of entity related with the tag */
                entity_type: components["parameters"]["entity_type"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of connected entities. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        users?: components["schemas"]["EntityReference"][];
                        teams?: components["schemas"]["EntityReference"][];
                        escalation_policies?: components["schemas"]["EntityReference"][];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listTeams: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Filters the result, showing only the records whose name matches the query. */
                query?: components["parameters"]["query"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of teams. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        teams: components["schemas"]["Team"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createTeam: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description The team to be created. */
        requestBody?: {
            content: {
                "application/json": {
                    team: components["schemas"]["Team"];
                };
            };
        };
        responses: {
            /** @description The team that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        team: components["schemas"]["Team"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getTeam: {
        parameters: {
            query?: {
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_teams"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The team requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        team: components["schemas"]["Team"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateTeam: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The team to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    team: components["schemas"]["Team"];
                };
            };
        };
        responses: {
            /** @description The team that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        team: components["schemas"]["Team"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteTeam: {
        parameters: {
            query?: {
                /**
                 * @description Team to reassign unresolved incident to.
                 *     If an unresolved incident exists on both the reassignment team and
                 *     the team being deleted, a duplicate will not be made. If not supplied,
                 *     unresolved incidents will be made account-level.
                 */
                reassignment_team?: components["parameters"]["reassignment_team"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The team was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listTeamsAuditRecords: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description The start of the date range over which you want to search. If not specified, defaults to `now() - 24 hours` (past 24 hours) */
                since?: components["parameters"]["audit_since"];
                /** @description The end of the date range over which you want to search. If not specified, defaults to `now()`. May not be more than 31 days after `since`. */
                until?: components["parameters"]["audit_until"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Records matching the query criteria. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditRecordResponseSchema"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateTeamEscalationPolicy: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The escalation policy ID on the team. */
                escalation_policy_id: components["parameters"]["team_escalation_policy_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The escalation policy was added to the team. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteTeamEscalationPolicy: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The escalation policy ID on the team. */
                escalation_policy_id: components["parameters"]["team_escalation_policy_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The escalation policy was removed from the team. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listTeamUsers: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_teams_members"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of users within the requested team. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        members?: {
                            user?: components["schemas"]["UserReference"];
                            role?: string;
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getTeamNotificationSubscriptions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        subscriptions: {
                            subscription?: components["schemas"]["NotificationSubscription"];
                            /** @description The name of the subscribable */
                            subscribable_name?: string | null;
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createTeamNotificationSubscriptions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The entities to subscribe to. */
        requestBody?: {
            content: {
                "application/json": {
                    subscribables: components["schemas"]["NotificationSubscribable"][];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        subscriptions?: components["schemas"]["NotificationSubscriptionWithContext"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    removeTeamNotificationSubscriptions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The entities to unsubscribe from. */
        requestBody?: {
            content: {
                "application/json": {
                    subscribables: components["schemas"]["NotificationSubscribable"][];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        deleted_count: number;
                        unauthorized_count: number;
                        non_existent_count: number;
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    updateTeamUser: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The user ID on the team. */
                user_id: components["parameters"]["team_user_id"];
            };
            cookie?: never;
        };
        /** @description The role of the user on the team. */
        requestBody?: {
            content: {
                "application/json": {
                    /**
                     * @description The role of the user on the team.
                     * @enum {string}
                     */
                    role?: "observer" | "responder" | "manager";
                };
            };
        };
        responses: {
            /** @description The user was added to the team. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteTeamUser: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The user ID on the team. */
                user_id: components["parameters"]["team_user_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user was removed to the team. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getTemplates: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Template name or description to search */
                query?: components["parameters"]["template_query"];
                /** @description Filters templates by type. */
                template_type?: components["parameters"]["template_type"];
                /** @description Used to specify both the field you wish to sort the results on (name/created_at), as well as the direction (asc/desc) of the results. The sort_by field and direction should be separated by a colon. Sort direction defaults to ascending. */
                sort_by?: components["parameters"]["sort_by_template"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of templates. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        templates: components["schemas"]["Template"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    createTemplate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    template: components["schemas"]["EditableTemplate"];
                };
            };
        };
        responses: {
            /** @description Template successfully created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        template: components["schemas"]["Template"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getTemplate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        template: components["schemas"]["Template"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    updateTemplate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    template: components["schemas"]["EditableTemplate"];
                };
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        template: components["schemas"]["Template"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    deleteTemplate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful operation */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    renderTemplate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StatusUpdateTemplateInput"];
            };
        };
        responses: {
            /** @description Successful operation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RenderedTemplate"];
                };
            };
            400: components["responses"]["ArgumentError"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getTemplateFields: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description An array of template fields. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        fields: {
                            /**
                             * @description The kind of data the template field is allowed to contain.
                             * @enum {string}
                             */
                            data_type?: "boolean" | "integer" | "float" | "string" | "datetime" | "url";
                            /** @description The default value of the template field. */
                            default_value?: string | null;
                            /** @description A short description of the template field. */
                            description?: string | null;
                            domain_name?: {
                                order?: number;
                                summary?: string;
                            };
                            /** @description An example value for the template field. */
                            example?: string | null;
                            keyword?: string | null;
                            /** @description A short summary of the template field. */
                            summary?: string;
                            /**
                             * @description The type of template field.
                             * @enum {string}
                             */
                            type?: "standard_field" | "custom_field";
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            500: components["responses"]["InternalServerError"];
        };
    };
    listUsers: {
        parameters: {
            query?: {
                /** @description Filters the result, showing only the records whose name matches the query. */
                query?: components["parameters"]["query"];
                /** @description An array of team IDs. Only results related to these teams will be returned. Account must have the `teams` ability to use this parameter. */
                "team_ids[]"?: components["parameters"]["team_ids"];
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_user"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of users. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        users: components["schemas"]["User"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createUser: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
                /** @description The email address of a valid user associated with the account making the request. */
                From: components["parameters"]["from_header"];
            };
            path?: never;
            cookie?: never;
        };
        /** @description The user to be created. */
        requestBody?: {
            content: {
                "application/json": {
                    user: components["schemas"]["User"] & {
                        license?: unknown & components["schemas"]["LicenseReference"];
                    };
                };
            };
        };
        responses: {
            /** @description The user that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        user: components["schemas"]["User"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUser: {
        parameters: {
            query?: {
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_user"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        user: components["schemas"]["User"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateUser: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The user to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    user: components["schemas"]["User"] & {
                        license?: unknown & components["schemas"]["LicenseReference"];
                    };
                };
            };
        };
        responses: {
            /** @description The user that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        user: components["schemas"]["User"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteUser: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listUsersAuditRecords: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description The start of the date range over which you want to search. If not specified, defaults to `now() - 24 hours` (past 24 hours) */
                since?: components["parameters"]["audit_since"];
                /** @description The end of the date range over which you want to search. If not specified, defaults to `now()`. May not be more than 31 days after `since`. */
                until?: components["parameters"]["audit_until"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Records matching the query criteria. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuditRecordResponseSchema"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
            500: components["responses"]["InternalServerError"];
        };
    };
    getUserContactMethods: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of contact methods. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        contact_methods?: (components["schemas"]["PhoneContactMethod"] | components["schemas"]["PushContactMethod"] | components["schemas"]["EmailContactMethod"])[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createUserContactMethod: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The contact method to be created. */
        requestBody?: {
            content: {
                "application/json": {
                    contact_method: components["schemas"]["PhoneContactMethod"] | components["schemas"]["PushContactMethod"] | components["schemas"]["EmailContactMethod"];
                };
            };
        };
        responses: {
            /** @description The contact method that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        contact_method?: components["schemas"]["PhoneContactMethod"] | components["schemas"]["PushContactMethod"] | components["schemas"]["EmailContactMethod"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUserContactMethod: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The contact method ID on the user. */
                contact_method_id: components["parameters"]["user_contact_method_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user's contact method requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        contact_method?: components["schemas"]["PhoneContactMethod"] | components["schemas"]["PushContactMethod"] | components["schemas"]["EmailContactMethod"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateUserContactMethod: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The contact method ID on the user. */
                contact_method_id: components["parameters"]["user_contact_method_id"];
            };
            cookie?: never;
        };
        /** @description The user's contact method to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    contact_method: components["schemas"]["PhoneContactMethod"] | components["schemas"]["PushContactMethod"] | components["schemas"]["EmailContactMethod"];
                };
            };
        };
        responses: {
            /** @description The user's contact method that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        contact_method?: components["schemas"]["PhoneContactMethod"] | components["schemas"]["PushContactMethod"] | components["schemas"]["EmailContactMethod"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteUserContactMethod: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The contact method ID on the user. */
                contact_method_id: components["parameters"]["user_contact_method_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The contact method was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUserLicense: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The License allocated to the User */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        license: components["schemas"]["LicenseWithCounts"]["allOf"]["0"];
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
        };
    };
    getUserNotificationRules: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_notification_rules"];
                /** @description The incident urgency for which the notification rules are applied. If not specified, defaults to `high`. */
                urgency?: components["parameters"]["urgency"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of notification rules. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        notification_rules: components["schemas"]["NotificationRule"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createUserNotificationRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The notification rule to be created. */
        requestBody?: {
            content: {
                "application/json": {
                    notification_rule: components["schemas"]["NotificationRule"];
                };
            };
        };
        responses: {
            /** @description The notification rule that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        notification_rule: components["schemas"]["NotificationRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUserNotificationRule: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_notification_rules"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The notification rule ID on the user. */
                notification_rule_id: components["parameters"]["user_notification_rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user's notification rule requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        notification_rule: components["schemas"]["NotificationRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateUserNotificationRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The notification rule ID on the user. */
                notification_rule_id: components["parameters"]["user_notification_rule_id"];
            };
            cookie?: never;
        };
        /** @description The user's notification rule to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    notification_rule: components["schemas"]["NotificationRule"];
                };
            };
        };
        responses: {
            /** @description The user's notification rule that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        notification_rule?: components["schemas"]["NotificationRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteUserNotificationRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The notification rule ID on the user. */
                notification_rule_id: components["parameters"]["user_notification_rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The notification rule was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUserNotificationSubscriptions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        subscriptions: {
                            subscription?: components["schemas"]["NotificationSubscription"];
                            /** @description The name of the subscribable */
                            subscribable_name?: string | null;
                        }[];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createUserNotificationSubscriptions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The entities to subscribe to. */
        requestBody?: {
            content: {
                "application/json": {
                    subscribables: components["schemas"]["NotificationSubscribable"][];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        subscriptions?: components["schemas"]["NotificationSubscriptionWithContext"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    unsubscribeUserNotificationSubscriptions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The entities to unsubscribe from. */
        requestBody?: {
            content: {
                "application/json": {
                    subscribables: components["schemas"]["NotificationSubscribable"][];
                };
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        deleted_count: number;
                        unauthorized_count: number;
                        non_existent_count: number;
                    };
                };
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            422: components["responses"]["UnprocessableEntity"];
        };
    };
    getUserHandoffNotificationRules: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of Handoff Notification Rules. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        oncall_handoff_notification_rules: components["schemas"]["HandoffNotificationRule"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createUserHandoffNotificationRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The Handoff Notification Rule to be created. */
        requestBody?: {
            content: {
                "application/json": {
                    oncall_handoff_notification_rule: components["schemas"]["HandoffNotificationRule"];
                };
            };
        };
        responses: {
            /** @description The Handoff Notification Rule that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        oncall_handoff_notification_rule: components["schemas"]["HandoffNotificationRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUserHandoffNotifiactionRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The oncall handoff notification rule ID on the user. */
                oncall_handoff_notification_rule_id: components["parameters"]["oncall_handoff_notification_rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user's handoff notification rule requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        oncall_handoff_notification_rule: components["schemas"]["HandoffNotificationRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateUserHandoffNotification: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The oncall handoff notification rule ID on the user. */
                oncall_handoff_notification_rule_id: components["parameters"]["oncall_handoff_notification_rule_id"];
            };
            cookie?: never;
        };
        /** @description The User's Handoff Notification Rule to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    oncall_handoff_notification_rule: components["schemas"]["HandoffNotificationRule"];
                };
            };
        };
        responses: {
            /** @description The User's Handoff Notification Rule that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        oncall_handoff_notification_rule?: components["schemas"]["HandoffNotificationRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteUserHandoffNotificationRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The oncall handoff notification rule ID on the user. */
                oncall_handoff_notification_rule_id: components["parameters"]["oncall_handoff_notification_rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The handoff notification rule was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUserSessions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of the user's active sessions. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        user_sessions: components["schemas"]["UserSession"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteUserSessions: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user sessions were all deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUserSession: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The session type for the user session ID. */
                type: components["parameters"]["type"];
                /** @description The session ID for the user. */
                session_id: components["parameters"]["session_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user's session requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        user_session: components["schemas"]["UserSession"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteUserSession: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The session type for the user session ID. */
                type: components["parameters"]["type"];
                /** @description The session ID for the user. */
                session_id: components["parameters"]["session_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user session was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUserStatusUpdateNotificationRules: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_notification_rules"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of status update notification rules. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        status_update_notification_rules: components["schemas"]["StatusUpdateNotificationRule"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createUserStatusUpdateNotificationRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        /** @description The status update notification rule to be created. */
        requestBody?: {
            content: {
                "application/json": {
                    status_update_notification_rule: components["schemas"]["StatusUpdateNotificationRule"];
                };
            };
        };
        responses: {
            /** @description The status update notification rule that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        status_update_notification_rule: components["schemas"]["StatusUpdateNotificationRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getUserStatusUpdateNotificationRule: {
        parameters: {
            query?: {
                /** @description Array of additional details to include. */
                "include[]"?: components["parameters"]["include_notification_rules"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The status update notification rule ID on the user. */
                status_update_notification_rule_id: components["parameters"]["user_status_update_notification_rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The user's status update notification rule requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        notification_rule: components["schemas"]["StatusUpdateNotificationRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateUserStatusUpdateNotificationRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The status update notification rule ID on the user. */
                status_update_notification_rule_id: components["parameters"]["user_status_update_notification_rule_id"];
            };
            cookie?: never;
        };
        /** @description The user's status update notification rule to be updated. */
        requestBody?: {
            content: {
                "application/json": {
                    status_update_notification_rule: components["schemas"]["StatusUpdateNotificationRule"];
                };
            };
        };
        responses: {
            /** @description The user's status update notification rule that was updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        notification_rule?: components["schemas"]["StatusUpdateNotificationRule"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            402: components["responses"]["PaymentRequired"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteUserStatusUpdateNotificationRule: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
                /** @description The status update notification rule ID on the user. */
                status_update_notification_rule_id: components["parameters"]["user_status_update_notification_rule_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The status update notification rule was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getCurrentUser: {
        parameters: {
            query?: {
                /** @description Array of additional Models to include in response. */
                "include[]"?: components["parameters"]["include_user"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requesting user. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        user: components["schemas"]["User"];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listVendors: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated array of vendors. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Pagination"] & {
                        vendors: components["schemas"]["Vendor"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getVendor: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The vendor requested */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        vendor: components["schemas"]["Vendor"][];
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listWebhookSubscriptions: {
        parameters: {
            query?: {
                /** @description The number of results per page. */
                limit?: components["parameters"]["offset_limit"];
                /** @description Offset to start pagination search results. */
                offset?: components["parameters"]["offset_offset"];
                /**
                 * @description By default the `total` field in pagination responses is set to `null` to provide the fastest possible response times. Set `total` to `true` for this field to be populated.
                 *
                 *     See our [Pagination Docs](https://developer.pagerduty.com/docs/rest-api-v2/pagination/) for more information.
                 */
                total?: components["parameters"]["offset_total"];
                /** @description The type of resource to filter upon. */
                filter_type?: components["parameters"]["webhooks_filter_type"];
                /** @description The id of the resource to filter upon. Required if filter_type is service or team. */
                filter_id?: components["parameters"]["webhooks_filter_id"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A set of webhook subscriptions matching the request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        webhook_subscriptions: components["schemas"]["WebhookSubscription"][];
                    } & components["schemas"]["Pagination"];
                };
            };
            400: components["responses"]["WebhookBadRequest"];
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
        };
    };
    createWebhookSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    webhook_subscription: components["schemas"]["WebhookSubscription"];
                };
            };
        };
        responses: {
            /** @description The webhook subscription that was created. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        webhook_subscription: components["schemas"]["WebhookSubscription"];
                    };
                };
            };
            400: components["responses"]["WebhookBadRequest"];
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
        };
    };
    getWebhookSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The webhook subscription that was requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        webhook_subscription: components["schemas"]["WebhookSubscription"];
                    };
                };
            };
            400: components["responses"]["WebhookBadRequest"];
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
            404: components["responses"]["WebhookNotFound"];
        };
    };
    updateWebhookSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["WebhookSubscriptionUpdate"];
            };
        };
        responses: {
            /** @description The updated webhook subscription. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        webhook_subscription: components["schemas"]["WebhookSubscription"];
                    };
                };
            };
            400: components["responses"]["WebhookBadRequest"];
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
            404: components["responses"]["WebhookNotFound"];
        };
    };
    deleteWebhookSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The webhook subscription was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["WebhookBadRequest"];
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
            404: components["responses"]["WebhookNotFound"];
        };
    };
    enableWebhookSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The webhook subscription that was successfully enabled. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        webhook_subscription: components["schemas"]["WebhookSubscription"];
                    };
                };
            };
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
            404: components["responses"]["WebhookNotFound"];
        };
    };
    testWebhookSubscription: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Accepted */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
            404: components["responses"]["WebhookNotFound"];
        };
    };
    listOauthClients: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of OAuth clients */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        oauth_clients?: components["schemas"]["OAuthClient"][];
                    };
                };
            };
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
        };
    };
    createOauthClient: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOAuthClientRequest"];
            };
        };
        responses: {
            /** @description OAuth client created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        oauth_client?: components["schemas"]["OAuthClient"];
                    };
                };
            };
            400: components["responses"]["WebhookBadRequest"];
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
        };
    };
    getOauthClient: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OAuth client details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        oauth_client?: components["schemas"]["OAuthClient"];
                    };
                };
            };
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
            404: components["responses"]["WebhookNotFound"];
        };
    };
    updateOauthClient: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateOAuthClientRequest"];
            };
        };
        responses: {
            /** @description OAuth client updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        oauth_client?: components["schemas"]["OAuthClient"];
                    };
                };
            };
            400: components["responses"]["WebhookBadRequest"];
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
            404: components["responses"]["WebhookNotFound"];
        };
    };
    deleteOauthClient: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OAuth client deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            401: components["responses"]["WebhookUnauthorized"];
            403: components["responses"]["WebhookForbidden"];
            404: components["responses"]["WebhookNotFound"];
        };
    };
    listWorkflowIntegrations: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description Whether to include deprecated Integrations in the response. */
                include_deprecated?: components["parameters"]["include_deprecated"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated list of Workflow Integrations. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CursorPagination"] & {
                        integrations: components["schemas"]["WorkflowIntegration"][];
                        limit?: number;
                        next_cursor?: string | null;
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getWorkflowIntegration: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Workflow Integration requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkflowIntegration"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listWorkflowIntegrationConnections: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description Filter Integrations by partial name. */
                name?: components["parameters"]["name"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated list of Workflow Integration Connections. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CursorPagination"] & {
                        connections: components["schemas"]["WorkflowIntegrationConnection"][];
                        limit?: number;
                        next_cursor?: string | null;
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    listWorkflowIntegrationConnectionsByIntegration: {
        parameters: {
            query?: {
                /** @description The minimum of the `limit` parameter used in the request or the maximum request size of the API. */
                limit?: components["parameters"]["cursor_limit"];
                /** @description Optional parameter used to request the "next" set of results from an API.  The value provided here is most commonly obtained from the `next_cursor` field of the previous request.  When no value is provided, the request starts at the beginning of the result set. */
                cursor?: components["parameters"]["cursor_cursor"];
                /** @description Filter Integrations by partial name. */
                name?: components["parameters"]["name"];
            };
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the Workflow Integration */
                integration_id: components["parameters"]["workflow_integrations_integration_id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated list of Workflow Integration Connections. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CursorPagination"] & {
                        connections: components["schemas"]["WorkflowIntegrationConnection"][];
                        limit?: number;
                        next_cursor?: string | null;
                    };
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    createWorkflowIntegrationConnection: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the Workflow Integration */
                integration_id: components["parameters"]["workflow_integrations_integration_id"];
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["CreateWorkflowIntegrationConnection"];
        responses: {
            /** @description The Workflow Integration Connection that was created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkflowIntegrationConnection"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    getWorkflowIntegrationConnection: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the Workflow Integration */
                integration_id: components["parameters"]["workflow_integrations_integration_id"];
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Workflow Integration Connection requested. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkflowIntegrationConnection"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    deleteWorkflowIntegrationConnection: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
            };
            path: {
                /** @description The ID of the Workflow Integration */
                integration_id: components["parameters"]["workflow_integrations_integration_id"];
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Workflow Integration Connection was deleted successfully. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
    updateWorkflowIntegrationConnection: {
        parameters: {
            query?: never;
            header: {
                /** @description The `Accept` header is used as a versioning header. */
                Accept: components["parameters"]["header_Accept"];
                "Content-Type": components["parameters"]["header_Content-Type"];
            };
            path: {
                /** @description The ID of the Workflow Integration */
                integration_id: components["parameters"]["workflow_integrations_integration_id"];
                /** @description The ID of the resource. */
                id: components["parameters"]["id"];
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["UpdateWorkflowIntegrationConnection"];
        responses: {
            /** @description The updated Workflow Integration Connection. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkflowIntegrationConnection"];
                };
            };
            400: components["responses"]["ArgumentError"];
            401: components["responses"]["Unauthorized"];
            403: components["responses"]["Forbidden"];
            404: components["responses"]["NotFound"];
            429: components["responses"]["TooManyRequests"];
        };
    };
}
